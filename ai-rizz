#!/bin/sh
#
# ai-rizz - A CLI tool to manage Cursor rules and rulesets
# Supports progressive initialization with local and commit modes
#
# Usage: ai-rizz <command> [options]
# 
# Copyright 2024 ai-rizz project
# POSIX-compliant shell script for maximum portability
#
# Environment Variable Support:
# This script supports environment variables as fallbacks for CLI arguments:
# - AI_RIZZ_MANIFEST: Fallback for --manifest/--skibidi option
# - AI_RIZZ_SOURCE_REPO: Fallback for <source_repo> argument in init
# - AI_RIZZ_TARGET_DIR: Fallback for -d <target_dir> option
# - AI_RIZZ_RULE_PATH: Fallback for --rule-path option
# - AI_RIZZ_RULESET_PATH: Fallback for --ruleset-path option
# - AI_RIZZ_MODE: Fallback for --local/--commit mode selection

set -e  # Exit on error

# Configuration constants
COMMIT_MANIFEST_FILE="ai-rizz.skbd"
LOCAL_MANIFEST_FILE="ai-rizz.local.skbd"
SHARED_DIR="shared"
LOCAL_DIR="local" 
CONFIG_DIR="$HOME/.config/ai-rizz"
DEFAULT_TARGET_DIR=".cursor/rules"
DEFAULT_RULES_PATH="rules"
DEFAULT_RULESETS_PATH="rulesets"

# Source repository information (set during initialization)
SOURCE_REPO=""      # Source repository URL
TARGET_DIR=""       # Target directory for rules

# Repository directory (set during initialization)
REPO_DIR=""

# Global mode repository directory (separate from REPO_DIR for cache isolation)
# This ensures global mode uses a fixed cache path regardless of PWD
GLOBAL_REPO_DIR=""

# Source repository paths (set during initialization, identical across modes)
RULES_PATH=""                                       # Rules path from manifest
RULESETS_PATH=""                                    # Rulesets path from manifest

# Global mode configuration (user-wide, repo-independent)
# These paths are computed dynamically to respect HOME changes in tests
# Use the accessor functions below rather than these variables directly
GLOBAL_MANIFEST_FILE=""          # Set to "${HOME}/ai-rizz.skbd" at runtime
GLOBAL_RULES_DIR=""              # Set to "${HOME}/.cursor/rules/ai-rizz" at runtime
GLOBAL_COMMANDS_DIR=""           # Set to "${HOME}/.cursor/commands/ai-rizz" at runtime

# Initialize global paths (called after script loading and during tests)
init_global_paths() {
	GLOBAL_MANIFEST_FILE="${HOME}/ai-rizz.skbd"
	GLOBAL_RULES_DIR="${HOME}/.cursor/rules/ai-rizz"
	GLOBAL_COMMANDS_DIR="${HOME}/.cursor/commands/ai-rizz"
}

# Initialize global paths on script load
init_global_paths

# Display formatting variables  
COMMITTED_GLYPH="●"
LOCAL_GLYPH="◐"
GLOBAL_GLYPH="★"
UNINSTALLED_GLYPH="○"

# Utilities
# =========

# Get repository directory for the current project
#
# Globals:
#   CONFIG_DIR - Base configuration directory path
#
# Arguments:
#   None
#
# Outputs:
#   Stdout: Repository directory path for current project
#
# Returns:
#   0 on success
#
get_repo_dir() {
	# Use git root directory name as project name, fallback to current directory
	if grd_git_root=$(git rev-parse --show-toplevel 2>/dev/null); then
		grd_project_name=$(basename "${grd_git_root}")
	else
		grd_project_name=$(basename "$(pwd)")
	fi
	echo "${CONFIG_DIR}/repos/${grd_project_name}/repo"
}

# Get global mode repository directory (fixed cache path)
#
# Returns a fixed cache path for global mode that is independent of PWD.
# Uses "_ai-rizz.global" as the cache name which cannot conflict with
# git repository names.
#
# Globals:
#   CONFIG_DIR - Base configuration directory path
#
# Arguments:
#   None
#
# Outputs:
#   Stdout: Global repository directory path
#
# Returns:
#   0 on success
#
get_global_repo_dir() {
	echo "${CONFIG_DIR}/repos/_ai-rizz.global/repo"
}

# Print error message to stderr and exit with specified code
#
# Globals:
#   None
#
# Arguments:
#   $1 - Error message to display (required)
#   $2 - Exit code (optional, defaults to 1)
#
# Outputs:
#   Stderr: Error message prefixed with "Error: "
#
# Returns:
#   Never returns (exits with specified code)
#
error() {
  printf '%b' "Error: ${1}\n" >&2
  exit "${2:-1}"
}

# Print warning message to stderr
#
# Globals:
#   None
#
# Arguments:
#   $1 - Warning message to display (required)
#
# Outputs:
#   Stderr: Warning message prefixed with "Warning: "
#
# Returns:
#   0 on success
#
warn() {
  printf '%b' "Warning: ${1}\n" >&2
}

# Entity Type Detection Utilities
# ================================

# Check if an entity is a command (*.md) vs a rule (*.mdc)
#
# Commands are identified by their .md extension in the rules/ directory.
# Rules have .mdc extension. This enables mixed entity management in the
# same source repository.
#
# Globals:
#   None
#
# Arguments:
#   $1 - Entity name/path (e.g., "my-command.md", "rules/niko/plan.md")
#
# Outputs:
#   Stdout: "true" if entity is a command, "false" otherwise
#
# Returns:
#   0 always
#
is_command() {
	ic_entity="${1}"
	
	# Extract extension
	case "${ic_entity}" in
		*.md)
			echo "true"
			;;
		*)
			echo "false"
			;;
	esac
	
	return 0
}

# Get the entity type based on file extension
#
# Returns "command" for *.md files, "rule" for everything else
# (including *.mdc files and directories/rulesets).
#
# Globals:
#   None
#
# Arguments:
#   $1 - Entity name/path
#
# Outputs:
#   Stdout: "command" or "rule"
#
# Returns:
#   0 always
#
get_entity_type() {
	get_entity="${1}"
	
	if [ "$(is_command "${get_entity}")" = "true" ]; then
		echo "command"
	else
		echo "rule"
	fi
	
	return 0
}

# Get the commands target directory for a given mode
#
# Returns the appropriate .cursor/commands/ subdirectory based on mode.
# Commands use a parallel structure to rules:
#   - local:  .cursor/commands/local/
#   - commit: .cursor/commands/shared/
#   - global: ~/.cursor/commands/ai-rizz/
#
# Globals:
#   GLOBAL_COMMANDS_DIR - Global commands directory
#   LOCAL_DIR - Local directory name
#   SHARED_DIR - Shared directory name
#
# Arguments:
#   $1 - Mode: "local", "commit", or "global"
#
# Outputs:
#   Stdout: Target commands directory path
#
# Returns:
#   0 always
#
get_commands_target_dir() {
	gctd_mode="${1}"
	
	case "${gctd_mode}" in
		local)
			echo ".cursor/commands/${LOCAL_DIR}"
			;;
		commit)
			echo ".cursor/commands/${SHARED_DIR}"
			;;
		global)
			# Ensure global paths are current
			init_global_paths
			echo "${GLOBAL_COMMANDS_DIR}"
			;;
		*)
			# Default to shared for unknown modes
			echo ".cursor/commands/${SHARED_DIR}"
			;;
	esac
	
	return 0
}

# Resolve symlink to absolute path (portable readlink -f)
#
# POSIX-compliant implementation based on readlinkf_posix from
# https://github.com/ko1nksm/readlinkf
#
# This function provides cross-platform symlink resolution using only
# POSIX-specified commands (cd -P, ls -dl). It resolves symlinks to their
# absolute target paths, handling both absolute and relative symlinks,
# nested symlink chains, and circular references.
#
# The upstream implementation is extensively tested across 9+ shells and
# 5+ platforms (macOS, FreeBSD, Cygwin, etc.). We trust the upstream
# tests and do not duplicate them here.
#
# Globals:
#   None
#
# Arguments:
#   $1 - Path to resolve (symlink, file, or directory)
#
# Outputs:
#   Stdout: Absolute resolved path, or empty string if resolution fails
#
# Returns:
#   0 on success
#   1 if path doesn't exist or resolution fails
#
_readlink_f() {
	_rlf_path="${1}"
	
	# Return empty if no path provided
	if [ -z "${_rlf_path}" ]; then
		echo ""
		return 1
	fi
	
	# Implementation based on readlinkf_posix from
	# https://github.com/ko1nksm/readlinkf
	# Uses only POSIX-specified commands: cd -P, ls -dl
	_rlf_max_symlinks=40
	_rlf_cdpath=''
	
	_rlf_target="${_rlf_path}"
	# Trim trailing slashes
	[ -e "${_rlf_target%/}" ] || _rlf_target="${_rlf_path%"${_rlf_path##*[!/]}"}"
	# Add trailing slash for directories
	[ -d "${_rlf_target:-/}" ] && _rlf_target="${_rlf_target}/"
	
	# Save original directory
	_rlf_orig_pwd=$(pwd)
	
	# Change to current directory (cd -P resolves symlinks)
	if ! cd -P . 2>/dev/null; then
		echo ""
		return 1
	fi
	
	# Resolve symlinks iteratively
	while [ "${_rlf_max_symlinks}" -ge 0 ] && _rlf_max_symlinks=$(expr ${_rlf_max_symlinks} - 1); do
		# Navigate to directory containing target
		if [ ! "${_rlf_target}" = "${_rlf_target%/*}" ]; then
			case "${_rlf_target}" in
				/*)
					cd -P "${_rlf_target%/*}/" 2>/dev/null || break
					;;
				*)
					cd -P "./${_rlf_target%/*}" 2>/dev/null || break
					;;
			esac
			_rlf_target="${_rlf_target##*/}"
		fi
		
		# If not a symlink, we're done
		if [ ! -L "${_rlf_target}" ]; then
			_rlf_result="${PWD%/}${_rlf_target:+/}${_rlf_target}"
			cd "${_rlf_orig_pwd}" 2>/dev/null
			printf '%s\n' "${_rlf_result:-/}"
			return 0
		fi
		
		# Read symlink target from ls -dl output
		# ls -dl format: "%s %u %s %s %u %s %s -> %s\n"
		# See: https://pubs.opengroup.org/onlinepubs/9699919799/utilities/ls.html
		_rlf_link=$(ls -dl -- "${_rlf_target}" 2>/dev/null) || break
		_rlf_target="${_rlf_link#*" ${_rlf_target} -> "}"
	done
	
	# Resolution failed, restore directory and return empty
	cd "${_rlf_orig_pwd}" 2>/dev/null
	echo ""
	return 1
}

# Show command usage error with example and exit
#
# Displays a user-friendly error message for command usage errors
# with an example of correct usage to guide the user
#
# Globals:
#   None
#
# Arguments:
#   $1 - Error message to display (required)
#   $2 - Command example to show (required)
#   $3 - Exit code (optional, defaults to 1)
#
# Outputs:
#   Stderr: Formatted error message with usage example
#
# Returns:
#   Never returns (exits with specified code)
#
show_command_usage_error() {
  cat >&2 << EOF
Error: $(printf "%b" "${1}")

Example usage:
  $(printf "%b" "${2}" | sed '2,$s/^/  /')

Run 'ai-rizz help' for full documentation of available commands.
EOF
  exit "${3:-1}"
}

# Show file permission error with potential solutions
#
# Displays a user-friendly error message for file permission issues
# with specific guidance on how to resolve the problem
#
# Globals:
#   None
#
# Arguments:
#   $1 - Path that has permission issues (required)
#   $2 - Operation that failed (e.g., "write to", "read from") (required)
#   $3 - Exit code (optional, defaults to 1)
#
# Outputs:
#   Stderr: Formatted error message with resolution steps
#
# Returns:
#   Never returns (exits with specified code)
#
show_permission_error() {
  cat >&2 << EOF
Error: Cannot ${2} ${1} (permission denied)

Possible solutions:
  1. Check ownership: ls -la ${1}
  2. Fix permissions: chmod u+rw ${1}
  3. Use a different location with sufficient permissions
EOF
  exit "${3:-1}"
}

# Show repository error with troubleshooting steps
#
# Displays a user-friendly error message for repository access issues
# with specific guidance on how to resolve common problems
#
# Globals:
#   None
#
# Arguments:
#   $1 - Repository URL with issue (required)
#   $2 - Exit code (optional, defaults to 1)
#
# Outputs:
#   Stderr: Formatted error message with troubleshooting steps
#
# Returns:
#   Never returns (exits with specified code)
#
show_repository_error() {
  cat >&2 << EOF
Error: Failed to access repository: ${1}

Possible issues:
  1. Network connection problem
  2. Repository URL is incorrect
  3. Repository requires authentication
  4. Repository no longer exists

Troubleshooting:
  • Verify network connection: ping github.com
  • Check URL manually: git ls-remote ${1}
  • Try with explicit protocol: https://github.com/user/repo.git
EOF
  exit "${2:-1}"
}

# Show initialization error with setup instructions
#
# Displays a user-friendly error message when ai-rizz is not initialized
# with specific instructions on how to initialize it
#
# Globals:
#   None
#
# Arguments:
#   $1 - Exit code (optional, defaults to 1)
#
# Outputs:
#   Stderr: Formatted error message with initialization instructions
#
# Returns:
#   Never returns (exits with specified code)
#
show_initialization_error() {
  cat >&2 << EOF
Error: No ai-rizz configuration found. Run 'ai-rizz init' first.

You need to initialize ai-rizz with one of these commands:

  ai-rizz init <repository-url>                     # Interactive initialization
  ai-rizz init <repository-url> --local             # Local mode (git-ignored)
  ai-rizz init <repository-url> --commit            # Commit mode (git-tracked)
  ai-rizz init <repository-url> -d <target-dir>     # Custom target directory

Example:
  ai-rizz init https://github.com/user/repo.git --local
EOF
  exit "${1:-1}"
}

# Show mode selection error with guidance
#
# Displays a user-friendly error message when mode selection is ambiguous
# with clear instructions on how to specify the desired mode
#
# Globals:
#   None
#
# Arguments:
#   $1 - Command being used (e.g., "add rule", "add ruleset") (required)
#   $2 - Exit code (optional, defaults to 1)
#
# Outputs:
#   Stderr: Formatted error message with mode selection instructions
#
# Returns:
#   Never returns (exits with specified code)
#
show_mode_selection_error() {
  cat >&2 << EOF
Error: Multiple modes available. Please specify which mode to use.

To specify mode:
  ai-rizz ${1} --local     # Use local mode (git-ignored)
  ai-rizz ${1} --commit    # Use commit mode (git-tracked)
  ai-rizz ${1} --global    # Use global mode (user-wide)

For more information on modes, run: ai-rizz help
EOF
  exit "${2:-1}"
}

# Show invalid mode error with guidance
#
# Displays a user-friendly error message when an invalid mode is specified
# with clear instructions on valid mode options
#
# Globals:
#   None
#
# Arguments:
#   $1 - Invalid mode that was provided (required)
#   $2 - Exit code (optional, defaults to 1)
#
# Outputs:
#   Stderr: Formatted error message with valid mode options
#
# Returns:
#   Never returns (exits with specified code)
#
show_invalid_mode_error() {
  cat >&2 << EOF
Error: Invalid mode: '${1}'

Valid modes are:
  --local, -l     Local mode (git-ignored)
  --commit, -c    Commit mode (git-tracked)
  --global, -g    Global mode (user-wide)

Example usage:
  ai-rizz add rule example-rule --local
  ai-rizz add rule example-rule --global
EOF
  exit "${2:-1}"
}

# Show git repository context error with setup instructions
#
# Displays a user-friendly error message when ai-rizz is not run in a git repository
# with instructions on how to set up a git repository
#
# Globals:
#   None
#
# Arguments:
#   $1 - Exit code (optional, defaults to 1)
#
# Outputs:
#   Stderr: Formatted error message with git setup instructions
#
# Returns:
#   Never returns (exits with specified code)
#
show_git_context_error() {
  cat >&2 << EOF
Error: Not in a git repository.

ai-rizz must be run inside a git repository. To set up a new git repository:

  mkdir myproject
  cd myproject
  git init
  ai-rizz init <repository-url>

Or initialize git in the current directory:

  git init
  ai-rizz init <repository-url>
EOF
  exit "${1:-1}"
}

# Progressive Manifest Utilities  
# ==============================

# Read manifest metadata line from specified file
#
# Globals:
#   None
#
# Arguments:
#   $1 - Path to manifest file (required)
#
# Outputs:
#   Stdout: Tab-separated "source_repo\ttarget_dir" line
#   Stderr: Error message if invalid format
#
# Returns:
#   0 on success
#   1 if file doesn't exist or on error (via error() function)
#
read_manifest_metadata() {
	rmm_manifest_file="${1}"
	
	if [ ! -f "${rmm_manifest_file}" ]; then
		return 1
	fi
	
	# Read first line
	read -r rmm_first_line < "${rmm_manifest_file}"
	
	# Validate format
	if ! echo "${rmm_first_line}" | grep -q "	"; then
		error "Invalid manifest format in ${rmm_manifest_file}: First line must be 'source_repo<tab>target_dir'"
	fi
	
	echo "${rmm_first_line}"
}

# Read manifest entries from specified file
#
# Globals:
#   None
#
# Arguments:
#   $1 - Path to manifest file (required)
#
# Outputs:
#   Stdout: Manifest entries, one per line (excluding metadata line)
#
# Returns:
#   0 on success (including empty manifests)
#   1 if file doesn't exist
#
read_manifest_entries() {
	rme_manifest_file="${1}"
	
	if [ ! -f "${rme_manifest_file}" ]; then
		return 1
	fi
	
	# Skip first line (metadata), return rest (handle empty manifests gracefully)
	tail -n +2 "${rme_manifest_file}" | grep -v '^$' || true
}

# Write manifest file with metadata header and entries from stdin
#
# Globals:
#   None
#
# Arguments:
#   $1 - Path to manifest file to write (required)
#   $2 - Source repository URL (required)
#   $3 - Target directory path (required)
#   $4 - Rules path (optional, defaults to "rules")
#   $5 - Rulesets path (optional, defaults to "rulesets")
#
# Outputs:
#   None (writes to file)
#
# Returns:
#   0 on success
#
write_manifest_with_entries() {
	wmwe_manifest_file="${1}"
	wmwe_source_repo="${2}"
	wmwe_target_dir="${3}"
	wmwe_rules_path="${4:-$DEFAULT_RULES_PATH}"         # Default to DEFAULT_RULES_PATH if not provided
	wmwe_rulesets_path="${5:-$DEFAULT_RULESETS_PATH}"    # Default to DEFAULT_RULESETS_PATH if not provided
	
	# Write header with all fields using printf to ensure literal tabs
	printf "%s\t%s\t%s\t%s\n" "${wmwe_source_repo}" "${wmwe_target_dir}" "${wmwe_rules_path}" "${wmwe_rulesets_path}" > "${wmwe_manifest_file}"
	
	# Read from stdin and append if there's content
	while IFS= read -r wmwe_line; do
		if [ -n "${wmwe_line}" ]; then
			echo "${wmwe_line}" >> "${wmwe_manifest_file}"
		fi
	done
}

# Add entry to specified manifest file
#
# Globals:
#   None
#
# Arguments:
#   $1 - Path to manifest file (required)
#   $2 - Entry to add (required)
#
# Outputs:
#   Stderr: Error message if write fails
#
# Returns:
#   0 on success (including if entry already exists)
#   1 on error (via error() function)
#
add_manifest_entry_to_file() {
	ametf_target_manifest_file="${1}"
	ametf_entry="${2}"
	
	# Check if entry already exists
	if [ -f "${ametf_target_manifest_file}" ]; then
		if read_manifest_entries "${ametf_target_manifest_file}" | grep -q "^${ametf_entry}$"; then
			return 0  # Already exists
		fi
	fi
	
	# Add the entry with error handling
	if ! echo "${ametf_entry}" >> "${ametf_target_manifest_file}" 2>/dev/null; then
		show_permission_error "${ametf_target_manifest_file}" "write to"
	fi
}

# Remove entry from specified manifest file
#
# Globals:
#   None
#
# Arguments:
#   $1 - Path to manifest file (required)
#   $2 - Entry to remove (required)
#
# Outputs:
#   Stderr: Error message if metadata read fails
#
# Returns:
#   0 on success (including if file doesn't exist or entry not found)
#   1 on error (via error() function)
#
remove_manifest_entry_from_file() {
	rmeff_local_manifest_file="${1}"
	rmeff_entry="${2}"
	
	if [ ! -f "${rmeff_local_manifest_file}" ]; then
		return 0  # Nothing to remove
	fi
	
	# Get metadata
	if ! rmeff_metadata=$(read_manifest_metadata "${rmeff_local_manifest_file}"); then
		error "Failed to read manifest metadata from ${rmeff_local_manifest_file}"
	fi
	
	# Get entries excluding the one to remove
	rmeff_entries=$(read_manifest_entries "${rmeff_local_manifest_file}" | grep -v "^${rmeff_entry}$" || true)
	
	# Count tabs to determine format version
	rmeff_tab_count=$(echo "${rmeff_metadata}" | tr -cd '\t' | wc -c)
	
	# Extract fields based on format
	rmeff_source_repo=$(echo "${rmeff_metadata}" | cut -f1 -d"	")
	rmeff_target_dir=$(echo "${rmeff_metadata}" | cut -f2 -d"	")
	
	if [ "${rmeff_tab_count}" -eq 1 ]; then
		# Old format - upgrade to new format with defaults
		rmeff_rules_path="${DEFAULT_RULES_PATH}"
		rmeff_rulesets_path="${DEFAULT_RULESETS_PATH}"
	else
		# New format - extract values
		rmeff_rules_path=$(echo "${rmeff_metadata}" | cut -f3 -d"	")
		rmeff_rulesets_path=$(echo "${rmeff_metadata}" | cut -f4 -d"	")
	fi
	
	# Write header with all fields (new format)
	printf "%s\t%s\t%s\t%s\n" "${rmeff_source_repo}" "${rmeff_target_dir}" "${rmeff_rules_path}" "${rmeff_rulesets_path}" > "${rmeff_local_manifest_file}"
	
	# Append entries if any exist
	if [ -n "${rmeff_entries}" ]; then
		echo "${rmeff_entries}" >> "${rmeff_local_manifest_file}"
	fi
}

# Get metadata from any available manifest file for lazy initialization
#
# Globals:
#   COMMIT_MANIFEST_FILE - Path to commit manifest file
#   LOCAL_MANIFEST_FILE - Path to local manifest file
#
# Arguments:
#   None
#
# Outputs:
#   Stdout: Tab-separated "source_repo\ttarget_dir" line from first available manifest
#
# Returns:
#   0 on success (manifest found and read)
#   1 if no manifests available
#
get_any_manifest_metadata() {
	# Ensure global paths are current
	init_global_paths
	
	# Try commit manifest first (highest priority)
	if [ -f "${COMMIT_MANIFEST_FILE}" ]; then
		read_manifest_metadata "${COMMIT_MANIFEST_FILE}"
		return $?
	fi
	
	# Try local manifest
	if [ -f "${LOCAL_MANIFEST_FILE}" ]; then
		read_manifest_metadata "${LOCAL_MANIFEST_FILE}"
		return $?
	fi
	
	# Try global manifest (lowest priority, repo-independent)
	if [ -f "${GLOBAL_MANIFEST_FILE}" ]; then
		read_manifest_metadata "${GLOBAL_MANIFEST_FILE}"
		return $?
	fi
	
	# No manifests available
	return 1
}

# Parse manifest metadata and set global variables for custom paths
#
# Globals:
#   SOURCE_REPO - Set from manifest metadata
#   TARGET_DIR - Set from manifest metadata
#   RULES_PATH, RULESETS_PATH - Set from manifest (identical across modes)
#   DEFAULT_RULES_PATH, DEFAULT_RULESETS_PATH - Default values
#
# Arguments:
#   $1 - Path to manifest file (required)
#   $2 - Mode (optional, unused but kept for backward compatibility)
#
# Outputs:
#   None (sets global variables)
#
# Returns:
#   0 on success
#   1 if file doesn't exist
#
parse_manifest_metadata() {
	pmm_manifest_file="${1}"
	
	if [ ! -f "${pmm_manifest_file}" ]; then
		return 1
	fi
	
	# Read metadata line
	pmm_metadata=$(read_manifest_metadata "${pmm_manifest_file}")
	
	# Count tabs to determine format version
	pmm_tab_count=$(echo "${pmm_metadata}" | tr -cd '\t' | wc -c)
	
	# Extract fields based on format
	pmm_source_repo=$(echo "${pmm_metadata}" | cut -f1 -d"	")
	pmm_target_dir=$(echo "${pmm_metadata}" | cut -f2 -d"	")
	
	if [ "${pmm_tab_count}" -eq 1 ]; then
		# Old format - use defaults
		pmm_rules_path="${DEFAULT_RULES_PATH}"
		pmm_rulesets_path="${DEFAULT_RULESETS_PATH}"
	else
		# New format - extract values
		pmm_rules_path=$(echo "${pmm_metadata}" | cut -f3 -d"	")
		pmm_rulesets_path=$(echo "${pmm_metadata}" | cut -f4 -d"	")
	fi
	
	# Set global paths (identical across modes)
	RULES_PATH="${pmm_rules_path}"
	RULESETS_PATH="${pmm_rulesets_path}"
	
	# Set unified variables
	SOURCE_REPO="${pmm_source_repo}"
	TARGET_DIR="${pmm_target_dir}"
	
	return 0
}

# Clone or update the rules repository cache
#
# This is the core sync function - all rule operations depend on having
# an up-to-date local cache of the rules repository. Uses graceful error
# handling so ai-rizz can work offline with cached content.
#
# Suppresses git output to avoid cluttering user interface while preserving
# error detection for proper failure reporting.
#
# Globals:
#   REPO_DIR - Target directory for repository cache
#
# Arguments:
#   $1 - Repository URL to clone/update
#
# Outputs:
#   Stderr: Warning messages on failure
#
# Returns:
#   0 on success
#   1 on failure (network issues, invalid URL, permissions)
#
git_sync() {
  gs_repo_url="${1}"
  
  # Ensure config directory exists
  mkdir -p "$(dirname "${REPO_DIR}")"
  
  # Clone/update project repository
  if [ ! -d "${REPO_DIR}" ]; then
	if ! git clone "${gs_repo_url}" "${REPO_DIR}" >/dev/null; then
	  warn "Failed to clone repository: ${gs_repo_url} (repository unavailable or invalid URL)"
	  return 1
	fi
  else
	if ! (cd "${REPO_DIR}" && git pull >/dev/null); then
	  warn "Failed to update repository: ${gs_repo_url} (repository unavailable or network issue)"
	  return 1
	fi
  fi
  
  return 0
}

# Sync global mode's source repository
#
# Syncs the global manifest's source repo to the global cache directory.
# Uses the fixed GLOBAL_REPO_DIR path for cache isolation.
#
# Globals:
#   GLOBAL_REPO_DIR - Target directory for global repository cache
#   GLOBAL_MANIFEST_FILE - Global manifest file path
#
# Arguments:
#   None
#
# Outputs:
#   Stderr: Warning messages on failure
#
# Returns:
#   0 on success
#   1 on failure
#
sync_global_repo() {
	# Get global source repo from manifest
	sgr_source_repo=$(get_global_source_repo)
	
	if [ -z "${sgr_source_repo}" ]; then
		return 1
	fi
	
	# Ensure global cache directory exists
	mkdir -p "$(dirname "${GLOBAL_REPO_DIR}")"
	
	# Clone/update global repository
	if [ ! -d "${GLOBAL_REPO_DIR}" ]; then
		if ! git clone "${sgr_source_repo}" "${GLOBAL_REPO_DIR}" >/dev/null; then
			warn "Failed to clone global repository: ${sgr_source_repo}"
			return 1
		fi
	else
		if ! (cd "${GLOBAL_REPO_DIR}" && git pull >/dev/null); then
			warn "Failed to update global repository: ${sgr_source_repo}"
			return 1
		fi
	fi
	
	return 0
}

# Get source repository URL from global manifest
#
# Extracts the source repository URL from the global manifest file.
# Returns empty string if global mode is not active.
#
# Globals:
#   GLOBAL_MANIFEST_FILE - Global manifest file path
#
# Arguments:
#   None
#
# Outputs:
#   Stdout: Global source repository URL, or empty string
#
# Returns:
#   0 always
#
get_global_source_repo() {
	if [ -f "${GLOBAL_MANIFEST_FILE}" ]; then
		ggsr_metadata=$(read_manifest_metadata "${GLOBAL_MANIFEST_FILE}" 2>/dev/null || echo "")
		if [ -n "${ggsr_metadata}" ]; then
			echo "${ggsr_metadata}" | cut -f1 -d"	"
			return 0
		fi
	fi
	echo ""
	return 0
}

# Get source repository URL from local/commit manifest
#
# Extracts the source repository URL from the local or commit manifest file.
# Checks commit manifest first, then local.
# Returns empty string if neither mode is active.
#
# Globals:
#   COMMIT_MANIFEST_FILE - Commit manifest file path
#   LOCAL_MANIFEST_FILE - Local manifest file path
#
# Arguments:
#   None
#
# Outputs:
#   Stdout: Local/commit source repository URL, or empty string
#
# Returns:
#   0 always
#
get_local_commit_source_repo() {
	# Try commit manifest first
	if [ -f "${COMMIT_MANIFEST_FILE}" ]; then
		glcsr_metadata=$(read_manifest_metadata "${COMMIT_MANIFEST_FILE}" 2>/dev/null || echo "")
		if [ -n "${glcsr_metadata}" ]; then
			echo "${glcsr_metadata}" | cut -f1 -d"	"
			return 0
		fi
	fi
	
	# Try local manifest
	if [ -f "${LOCAL_MANIFEST_FILE}" ]; then
		glcsr_metadata=$(read_manifest_metadata "${LOCAL_MANIFEST_FILE}" 2>/dev/null || echo "")
		if [ -n "${glcsr_metadata}" ]; then
			echo "${glcsr_metadata}" | cut -f1 -d"	"
			return 0
		fi
	fi
	
	echo ""
	return 0
}

# Check if global and local/commit modes use the same source repository
#
# Compares source repos between global mode and local/commit modes.
# Returns success (0) if:
# - Only one mode is active (no comparison needed)
# - Both modes use the same source repository
# Returns failure (1) if source repos differ.
#
# Globals:
#   COMMIT_MANIFEST_FILE - Commit manifest file path
#   LOCAL_MANIFEST_FILE - Local manifest file path
#   GLOBAL_MANIFEST_FILE - Global manifest file path
#
# Arguments:
#   None
#
# Outputs:
#   None
#
# Returns:
#   0 if repos match or only one mode active
#   1 if repos differ
#
repos_match() {
	# Get global source repo
	rm_global_source=$(get_global_source_repo)
	
	# If global mode not active, repos "match" (no conflict possible)
	if [ -z "${rm_global_source}" ]; then
		return 0
	fi
	
	# Get local/commit source repo directly from manifest (not cached SOURCE_REPO)
	rm_local_source=$(get_local_commit_source_repo)
	
	# If local/commit not active, repos "match"
	if [ -z "${rm_local_source}" ]; then
		return 0
	fi
	
	# Compare source repos
	if [ "${rm_global_source}" = "${rm_local_source}" ]; then
		return 0
	fi
	
	return 1
}

# Git Exclude Management  
# ======================

# Update .git/info/exclude for specific paths
#
# Uses exact line matching to avoid partial matches. Idempotent.
#
# Globals:
#   None
#
# Arguments:
#   $1 - Path to add/remove from git excludes
#   $2 - Action: "add" or "remove"
#
# Outputs:
#   Stderr: Error message if invalid action
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
update_git_exclude() {
	uge_path="${1}"
	uge_action="${2}"  # "add" or "remove"
	
	# Return early if no git repository exists
	if [ ! -d ".git" ]; then
		return 0
	fi
	
	# Create .git/info directory if it doesn't exist
	mkdir -p ".git/info"
	
	# Create exclude file if it doesn't exist  
	touch ".git/info/exclude"
	
	case "${uge_action}" in
		add)
			if ! grep -q "^${uge_path}$" ".git/info/exclude"; then
				echo "${uge_path}" >> ".git/info/exclude"
			fi
			;;
		remove)
			# Create a temporary file
			uge_tmp_file=$(mktemp)
			# Filter out the path
			grep -v "^${uge_path}$" ".git/info/exclude" > "${uge_tmp_file}" || true
			# Replace the original file
			cat "${uge_tmp_file}" > ".git/info/exclude"
			# Remove the temporary file
			rm -f "${uge_tmp_file}"
			;;
		*)
			error "Invalid action: ${uge_action}. Must be 'add' or 'remove'"
			;;
	esac
}

# Setup git excludes for local mode
#
# Adds local manifest and target directory to git excludes.
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename to exclude
#   LOCAL_DIR - Local directory name to exclude
#
# Arguments:
#   $1 - Target directory base path
#
# Outputs:
#   None
#
# Returns:
#   0 on success
#
setup_local_mode_excludes() {
	slme_target_dir="${1}"
	
	update_git_exclude "${LOCAL_MANIFEST_FILE}" "add"
	update_git_exclude "${slme_target_dir}/${LOCAL_DIR}" "add"
}

# Remove all local mode excludes
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename to unexclude
#   LOCAL_DIR - Local directory name to unexclude
#
# Arguments:
#   $1 - Target directory base path
#
# Outputs:
#   None
#
# Returns:
#   0 on success
#
remove_local_mode_excludes() {
	rlme_target_dir="${1}"
	
	update_git_exclude "${LOCAL_MANIFEST_FILE}" "remove"
	update_git_exclude "${rlme_target_dir}/${LOCAL_DIR}" "remove"
}

# Check if hook-based mode is active
#
# Checks if the pre-commit hook exists and contains the ai-rizz marker.
# Used by validate_git_exclude_state to determine if hook handles local files.
#
# Globals:
#   None
#
# Arguments:
#   None
#
# Outputs:
#   Stdout: "true" if hook-based mode active, "false" otherwise
#
# Returns:
#   0 always
#
is_hook_based_mode_active() {
	# Return early if no git repository exists
	if [ ! -d ".git" ]; then
		echo "false"
		return 0
	fi
	
	# Check if hook exists and contains marker
	if [ -f ".git/hooks/pre-commit" ] && grep -q "BEGIN ai-rizz hook" ".git/hooks/pre-commit" 2>/dev/null; then
		echo "true"
	else
		echo "false"
	fi
	
	return 0
}

# Setup pre-commit hook for hook-based local mode
#
# Creates or updates the pre-commit hook to unstage local mode files.
# Appends ai-rizz section to existing hooks if present, preserving user hooks.
# Hook reads manifest dynamically to get target directory.
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename pattern
#   LOCAL_DIR - Local directory name
#
# Arguments:
#   $1 - Target directory base path
#
# Outputs:
#   None
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
setup_pre_commit_hook() {
	sph_target_dir="${1}"
	
	# Return early if no git repository exists
	if [ ! -d ".git" ]; then
		return 0
	fi
	
	# Create .git/hooks directory if it doesn't exist
	mkdir -p ".git/hooks"
	
	# Hook content using HEREDOC (command substitution to assign to variable)
	sph_hook_content=$(cat <<'HOOKEOF'
# BEGIN ai-rizz hook (do not edit this section manually)
# Find local manifest in repo root
REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null || pwd)
LOCAL_MANIFEST=""
for file in "$REPO_ROOT"/*.local.skbd; do
    [ -f "$file" ] && LOCAL_MANIFEST=$(basename "$file") && break
done
[ -z "$LOCAL_MANIFEST" ] && exit 0

# Parse target directory from manifest
MANIFEST_PATH="$REPO_ROOT/$LOCAL_MANIFEST"
TARGET_DIR=$(head -n1 "$MANIFEST_PATH" 2>/dev/null | cut -f2)
[ -z "$TARGET_DIR" ] && exit 0

# Unstage local files (safe even if already ignored)
git reset HEAD -- "$TARGET_DIR/local/" "$LOCAL_MANIFEST" 2>/dev/null || true
# END ai-rizz hook
HOOKEOF
)
	
	# Check if hook already exists
	if [ -f ".git/hooks/pre-commit" ]; then
		# Check if ai-rizz section already exists
		if grep -q "BEGIN ai-rizz hook" ".git/hooks/pre-commit" 2>/dev/null; then
			# Already present, skip
			return 0
		fi
		
		# Append to existing hook
		echo "" >> ".git/hooks/pre-commit"
		echo "${sph_hook_content}" >> ".git/hooks/pre-commit"
	else
		# Create new hook file
		printf "#!/bin/sh\n%s\n" "${sph_hook_content}" > ".git/hooks/pre-commit"
	fi
	
	# Make hook executable
	chmod +x ".git/hooks/pre-commit"
	
	return 0
}

# Remove pre-commit hook section for hook-based local mode
#
# Removes the ai-rizz section from the pre-commit hook, preserving
# any user hooks outside the BEGIN/END markers. If the hook file
# only contains the ai-rizz section, removes the entire file.
#
# Globals:
#   None
#
# Arguments:
#   None
#
# Outputs:
#   None
#
# Returns:
#   0 on success
#
remove_pre_commit_hook() {
	# Return early if no git repository or hook exists
	if [ ! -d ".git" ] || [ ! -f ".git/hooks/pre-commit" ]; then
		return 0
	fi
	
	# Check if ai-rizz section exists
	if ! grep -q "BEGIN ai-rizz hook" ".git/hooks/pre-commit" 2>/dev/null; then
		# No ai-rizz section, nothing to remove
		return 0
	fi
	
	# Check if hook only contains ai-rizz section (plus shebang)
	sph_before_marker=$(sed '/BEGIN ai-rizz hook/,$d' ".git/hooks/pre-commit" | grep -v "^#!/bin/sh" | grep -v "^$" | wc -l)
	sph_after_marker=$(sed '1,/END ai-rizz hook/d' ".git/hooks/pre-commit" | grep -v "^$" | wc -l)
	
	if [ "${sph_before_marker}" -eq 0 ] && [ "${sph_after_marker}" -eq 0 ]; then
		# Only ai-rizz section, remove entire file
		rm -f ".git/hooks/pre-commit"
	else
		# Has user content, remove only ai-rizz section
		sph_tmp_file=$(mktemp)
		# Keep everything before BEGIN marker
		sed '/BEGIN ai-rizz hook/,$d' ".git/hooks/pre-commit" > "${sph_tmp_file}"
		# Keep everything after END marker
		sed '1,/END ai-rizz hook/d' ".git/hooks/pre-commit" >> "${sph_tmp_file}" 2>/dev/null || true
		# Replace original file
		cat "${sph_tmp_file}" > ".git/hooks/pre-commit"
		rm -f "${sph_tmp_file}"
		# Ensure executable
		chmod +x ".git/hooks/pre-commit"
	fi
	
	return 0
}

# Validate git exclude state matches mode configuration
#
# Warns about mismatched git exclude state - helps debug when users
# manually edit .git/info/exclude and break mode separation.
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   LOCAL_DIR - Local directory name
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   SHARED_DIR - Shared directory name
#
# Arguments:
#   $1 - Target directory base path
#
# Outputs:
#   Stderr: Warning messages for mismatched state
#
# Returns:
#   0 always
#
validate_git_exclude_state() {
	vges_target_dir="${1}"
	
	# Return early if no git repository exists
	if [ ! -d ".git" ]; then
		return 0
	fi
	
	if [ "$(is_mode_active local)" = "true" ]; then
		# Check if hook-based mode is active
		if [ "$(is_hook_based_mode_active)" = "true" ]; then
			# Hook-based mode: files don't need to be in git exclude
			return 0
		fi
		
		# Regular mode: Local mode should be excluded
		if [ ! -f ".git/info/exclude" ] || ! grep -q "^${LOCAL_MANIFEST_FILE}$" ".git/info/exclude"; then
			warn "Local manifest file not in git exclude (should be git-ignored)"
		fi
		if [ ! -f ".git/info/exclude" ] || ! grep -q "^${vges_target_dir}/${LOCAL_DIR}$" ".git/info/exclude"; then
			warn "Local directory not in git exclude (should be git-ignored)"
		fi
	fi
	
	if [ "$(is_mode_active commit)" = "true" ]; then
		# Commit mode should NOT be excluded
		if [ -f ".git/info/exclude" ] && grep -q "^${COMMIT_MANIFEST_FILE}$" ".git/info/exclude"; then
			warn "Commit manifest file in git exclude (should be git-tracked)"
		fi
		if [ -f ".git/info/exclude" ] && grep -q "^${vges_target_dir}/${SHARED_DIR}$" ".git/info/exclude"; then
			warn "Shared directory in git exclude (should be git-tracked)"
		fi
	fi
}

# Mode Detection Utilities
# ========================

# Check if a specific mode is currently active
#
# Uses the same logic as detect_initialized_modes but for a single mode.
# Checks both manifest file existence and target directory existence.
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   GLOBAL_MANIFEST_FILE - Global manifest filename (~/ai-rizz.skbd)
#   LOCAL_DIR - Local directory name
#   SHARED_DIR - Shared directory name
#
# Arguments:
#   $1 - Mode to check: "local", "commit", or "global"
#
# Outputs:
#   Stdout: "true" if mode is active, "false" otherwise
#
# Returns:
#   0 always
#
is_mode_active() {
	ima_mode="${1}"
	
	# Ensure global paths are current (handles HOME changes in tests)
	init_global_paths
	
	case "${ima_mode}" in
		local)
			if [ -f "${LOCAL_MANIFEST_FILE}" ]; then
				echo "true"
			else
				echo "false"
			fi
			;;
		commit)
			if [ -f "${COMMIT_MANIFEST_FILE}" ]; then
				echo "true"
			else
				echo "false"
			fi
			;;
		global)
			if [ -f "${GLOBAL_MANIFEST_FILE}" ]; then
				echo "true"
			else
				echo "false"
			fi
			;;
		*)
			echo "false"
			;;
	esac
	
	return 0
}

# Get which mode (if any) an entity is currently installed in
#
# Checks all active manifests to determine if an entity is already installed
# in any mode. Used for mode transition warnings.
#
# Priority order for checking: commit > local > global
# (Returns the strongest mode if entity exists in multiple modes)
#
# Globals:
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   GLOBAL_MANIFEST_FILE - Global manifest filename
#
# Arguments:
#   $1 - Entity path to check (e.g., "rules/foo.mdc" or "rulesets/bar")
#
# Outputs:
#   Stdout: "commit", "local", "global", or "none"
#
# Returns:
#   0 always
#
get_entity_installed_mode() {
	geim_entity="${1}"
	
	# Check commit mode first (strongest)
	if [ "$(is_mode_active commit)" = "true" ]; then
		if read_manifest_entries "${COMMIT_MANIFEST_FILE}" 2>/dev/null | grep -q "^${geim_entity}$"; then
			echo "commit"
			return 0
		fi
	fi
	
	# Check local mode
	if [ "$(is_mode_active local)" = "true" ]; then
		if read_manifest_entries "${LOCAL_MANIFEST_FILE}" 2>/dev/null | grep -q "^${geim_entity}$"; then
			echo "local"
			return 0
		fi
	fi
	
	# Check global mode (weakest)
	if [ "$(is_mode_active global)" = "true" ]; then
		if read_manifest_entries "${GLOBAL_MANIFEST_FILE}" 2>/dev/null | grep -q "^${geim_entity}$"; then
			echo "global"
			return 0
		fi
	fi
	
	echo "none"
	return 0
}

# Warn about mode transitions when adding entities
#
# Displays a warning message when an entity is being added to a different
# mode than it currently exists in. Helps users understand scope changes.
#
# Globals:
#   None
#
# Arguments:
#   $1 - Entity name (for display)
#   $2 - Current mode the entity is in ("commit", "local", "global")
#   $3 - Target mode being added to ("commit", "local", "global")
#
# Outputs:
#   Stderr: Warning message about the mode transition
#
# Returns:
#   0 always
#
warn_mode_transition() {
	wmt_entity="${1}"
	wmt_current_mode="${2}"
	wmt_target_mode="${3}"
	
	# No warning needed if same mode or no current mode
	if [ "${wmt_current_mode}" = "none" ] || [ "${wmt_current_mode}" = "${wmt_target_mode}" ]; then
		return 0
	fi
	
	case "${wmt_current_mode}→${wmt_target_mode}" in
		"global→commit")
			warn "⚠️  WARNING: ${wmt_entity} was globally-available but will now only be in this repository. (global → commit)"
			;;
		"global→local")
			warn "⚠️  WARNING: ${wmt_entity} was globally-available but will now only be in this repository (local). (global → local)"
			;;
		"commit→global")
			warn "⚠️  WARNING: ${wmt_entity} will be removed from this repository (other devs may lose access). (commit → global)"
			;;
		"commit→local")
			warn "⚠️  WARNING: ${wmt_entity} will be removed from git-tracked mode and become local-only. (commit → local)"
			;;
		"local→global")
			warn "⚠️  WARNING: ${wmt_entity} will be removed from this repository and become globally-available. (local → global)"
			;;
		"local→commit")
			warn "⚠️  WARNING: ${wmt_entity} will move from local to git-tracked mode. (local → commit)"
			;;
		*)
			# Unknown transition - no warning
			;;
	esac
	
	return 0
}

# Get target directory from available manifests
#
# Tries commit manifest first, then local, then default. The default
# is only used during initialization when no manifests exist yet.
#
# Globals:
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   DEFAULT_TARGET_DIR - Default target directory
#
# Arguments:
#   None
#
# Outputs:
#   Stdout: Target directory path
#
# Returns:
#   0 always
#
get_target_directory() {
	# Try commit manifest first
	if [ -f "${COMMIT_MANIFEST_FILE}" ]; then
		if ! gtd_metadata=$(read_manifest_metadata "${COMMIT_MANIFEST_FILE}"); then
			error "Failed to read commit manifest metadata"
		fi
		echo "${gtd_metadata}" | cut -f2 -d"	"
		return 0
	fi
	
	# Try local manifest
	if [ -f "${LOCAL_MANIFEST_FILE}" ]; then
		if ! gtd_metadata=$(read_manifest_metadata "${LOCAL_MANIFEST_FILE}"); then
			error "Failed to read local manifest metadata"
		fi
		echo "${gtd_metadata}" | cut -f2 -d"	"
		return 0
	fi
	
	# No manifests available - use default only during initialization
	echo "${DEFAULT_TARGET_DIR}"
}

# Cache manifest metadata in globals for efficiency
#
# Avoids repeatedly parsing manifest files during operations.
#
# Globals:
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   COMMIT_SOURCE_REPO - Set from commit manifest
#   COMMIT_TARGET_DIR - Set from commit manifest
#   COMMIT_RULES_PATH - Set from commit manifest
#   COMMIT_RULESETS_PATH - Set from commit manifest
#   LOCAL_SOURCE_REPO - Set from local manifest
#   LOCAL_TARGET_DIR - Set from local manifest
#   LOCAL_RULES_PATH - Set from local manifest
#   LOCAL_RULESETS_PATH - Set from local manifest
#
# Arguments:
#   None
#
# Outputs:
#   None
#
# Returns:
#   0 always
#
cache_manifest_metadata() {
	# Ensure global paths are current
	init_global_paths
	
	# Cache commit manifest metadata
	if [ -f "${COMMIT_MANIFEST_FILE}" ]; then
		parse_manifest_metadata "${COMMIT_MANIFEST_FILE}" "commit"
	fi
	
	# Cache local manifest metadata
	if [ -f "${LOCAL_MANIFEST_FILE}" ]; then
		parse_manifest_metadata "${LOCAL_MANIFEST_FILE}" "local"
	fi
	
	# Cache global manifest metadata and set GLOBAL_REPO_DIR
	if [ -f "${GLOBAL_MANIFEST_FILE}" ]; then
		parse_manifest_metadata "${GLOBAL_MANIFEST_FILE}" "global"
		# Set the global repo directory to the fixed cache path
		GLOBAL_REPO_DIR=$(get_global_repo_dir)
	else
		GLOBAL_REPO_DIR=""
	fi
}

# Lazy Initialization Utilities
# =============================

# Initialize a mode that doesn't exist yet, copying metadata from existing mode
#
# Enables progressive mode switching by creating the missing mode with
# matching configuration. Copies source repo and target dir from existing
# mode to maintain consistency.
#
# Globals:
#   LOCAL_DIR - Local directory name
#   SHARED_DIR - Shared directory name
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   SOURCE_REPO - Source repository URL
#   TARGET_DIR - Target directory for rules
#
# Arguments:
#   $1 - Target mode: "local" or "commit"
#
# Outputs:
#   None
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
lazy_init_mode() {
	lim_target_mode="${1}"  # "local" or "commit"
	
	# Get metadata from any existing manifest
	if ! lim_metadata=$(get_any_manifest_metadata); then
		error "No manifest available to copy metadata from for lazy initialization"
	fi
	
	# Count tabs to determine format version
	lim_tab_count=$(echo "${lim_metadata}" | tr -cd '\t' | wc -c)
	
	# Extract fields based on format
	lim_source_repo=$(echo "${lim_metadata}" | cut -f1 -d"	")
	lim_target_dir=$(echo "${lim_metadata}" | cut -f2 -d"	")
	
	if [ "${lim_tab_count}" -eq 1 ]; then
		# Old format - use defaults
		lim_rules_path="${DEFAULT_RULES_PATH}"
		lim_rulesets_path="${DEFAULT_RULESETS_PATH}"
		
		# Debug info
		warn "Using default paths for lazy init: rules=${lim_rules_path}, rulesets=${lim_rulesets_path}"
	else
		# New format - extract values
		lim_rules_path=$(echo "${lim_metadata}" | cut -f3 -d"	")
		lim_rulesets_path=$(echo "${lim_metadata}" | cut -f4 -d"	")
	fi
	
	# Set unified paths (identical across modes)
	RULES_PATH="${lim_rules_path}"
	RULESETS_PATH="${lim_rulesets_path}"
	
	# Set unified variables
	SOURCE_REPO="${lim_source_repo}"
	TARGET_DIR="${lim_target_dir}"
	
	case "${lim_target_mode}" in
		local)
			# Create local mode structure
			mkdir -p "${lim_target_dir}/${LOCAL_DIR}"
			
			# Write empty manifest with metadata (including custom paths)
			echo "" | write_manifest_with_entries "${LOCAL_MANIFEST_FILE}" "${lim_source_repo}" "${lim_target_dir}" "${lim_rules_path}" "${lim_rulesets_path}"
			
			# Update git excludes
			setup_local_mode_excludes "${lim_target_dir}"
			;;
			
		commit)
			# Create commit mode structure  
			mkdir -p "${lim_target_dir}/${SHARED_DIR}"
			
			# Write empty manifest with metadata (including custom paths)
			echo "" | write_manifest_with_entries "${COMMIT_MANIFEST_FILE}" "${lim_source_repo}" "${lim_target_dir}" "${lim_rules_path}" "${lim_rulesets_path}"
			;;
			
		*)
			error "Invalid target mode: ${lim_target_mode}. Must be 'local' or 'commit'"
			;;
	esac
}

# Check if lazy initialization is needed for a mode
#
# Returns success only when one mode exists and the other doesn't.
#
# Globals:
#  None
#
# Arguments:
#   $1 - Target mode: "local" or "commit"
#
# Outputs:
#   None
#
# Returns:
#   0 if lazy initialization needed
#   1 otherwise
#
needs_lazy_init() {
	nli_target_mode="${1}"
	
	case "${nli_target_mode}" in
		local)
			[ "$(is_mode_active local)" = "false" ] && [ "$(is_mode_active commit)" = "true" ]
			;;
		commit)
			[ "$(is_mode_active commit)" = "false" ] && [ "$(is_mode_active local)" = "true" ]
			;;
		*)
			return 1
			;;
	esac
}

# Conflict Resolution Utilities
# =============================

# Get all .mdc files that would be deployed by a manifest
#
# Core function for conflict resolution - determines which individual files
# would be deployed by expanding rulesets into their component files.
# Returns just filenames (not paths) for file-level conflict detection.
#
# Globals:
#   REPO_DIR - Repository directory for resolving entries
#
# Arguments:
#   $1 - Manifest file path
#
# Outputs:
#   Stdout: One filename per line (just filename, not full path)
#
# Returns:
#   0 on success
#   1 if manifest file doesn't exist
#
get_files_from_manifest() {
	gffm_manifest_file="${1}"
	
	if [ ! -f "${gffm_manifest_file}" ]; then
		return 1
	fi
	
	# Use the global repository directory
	gffm_repo_dir="${REPO_DIR}"
	
	# Get all entries from the manifest
	gffm_entries=$(read_manifest_entries "${gffm_manifest_file}" 2>/dev/null || true)
	
	if [ -n "${gffm_entries}" ]; then
		echo "${gffm_entries}" | while IFS= read -r gffm_entry; do
			if [ -n "${gffm_entry}" ]; then
				# Get the source path for this entry
				gffm_source_path="${gffm_repo_dir}/${gffm_entry}"
				
				if [ -f "${gffm_source_path}" ]; then
					# Single file - extract just the filename
					basename "${gffm_source_path}"
				elif [ -d "${gffm_source_path}" ]; then
					# Directory (ruleset) - list all .mdc files in it
					find "${gffm_source_path}" -name "*.mdc" -type f -o -name "*.mdc" -type l | \
					while IFS= read -r gffm_rule_file; do
						basename "${gffm_rule_file}"
					done
				fi
			fi
		done
	fi
}

# Remove local manifest entries that would deploy the given filename
#
# Handles complex conflict resolution logic for partial ruleset conflicts.
# For individual rules, removes the conflicting entry. For rulesets, only
# removes if the exact same ruleset exists in commit mode - otherwise
# preserves the local ruleset and lets sync handle file-level conflicts.
#
# This preserves user intent: if they have a local ruleset with extra rules,
# don't remove the whole thing just because one file conflicts.
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest to modify
#   COMMIT_MANIFEST_FILE - Commit manifest to check for exact matches
#   REPO_DIR - Repository directory for resolving paths
#
# Arguments:
#   $1 - Filename that would conflict
#
# Outputs:
#   None
#
# Returns:
#   0 always
#
remove_local_entries_deploying_file() {
	rledf_filename="${1}"
	
	# Get all local entries
	rledf_local_entries=$(read_manifest_entries "${LOCAL_MANIFEST_FILE}" 2>/dev/null || true)
	
	if [ -n "${rledf_local_entries}" ]; then
		# Use a temporary file to avoid subshell issues
		rledf_temp_entries=$(mktemp)
		echo "${rledf_local_entries}" > "${rledf_temp_entries}"
		
		while IFS= read -r rledf_entry; do
			if [ -n "${rledf_entry}" ]; then
				# Check if this entry would deploy the target filename
				rledf_source_path="${REPO_DIR}/${rledf_entry}"
				
				if [ -f "${rledf_source_path}" ]; then
					# Single file - check if it matches
					if [ "$(basename "${rledf_source_path}")" = "${rledf_filename}" ]; then
						remove_manifest_entry_from_file "${LOCAL_MANIFEST_FILE}" "${rledf_entry}"
					fi
				elif [ -d "${rledf_source_path}" ]; then
					# Directory (ruleset) - check if it contains the file
					if find "${rledf_source_path}" -name "${rledf_filename}" -type f -o -name "${rledf_filename}" -type l | \
						   grep -q .; then
						# For rulesets containing a conflicting file, we have a partial conflict.
						# We should NOT remove the entire local ruleset because it may contain
						# other rules that should remain local. Instead, let the sync process
						# handle the file-level conflict (commit wins for individual files).
						#
						# The only case where we remove the entire local ruleset is if the
						# commit manifest contains the exact same ruleset entry.
						rledf_ruleset_path="${rledf_entry}"
						if [ -f "${COMMIT_MANIFEST_FILE}" ] && read_manifest_entries "${COMMIT_MANIFEST_FILE}" | grep -q "^${rledf_ruleset_path}$"; then
							# Exact same ruleset in both modes - remove from local (commit wins)
							remove_manifest_entry_from_file "${LOCAL_MANIFEST_FILE}" "${rledf_entry}"
						else
							# Partial conflict - keep local ruleset, let sync handle file-level conflicts
							continue
						fi
					fi
				fi
			fi
		done < "${rledf_temp_entries}"
		
		# Clean up temporary file
		rm -f "${rledf_temp_entries}"
	fi
}



# Detect and resolve conflicts between commit and local modes
#
# Implements "commit wins" policy by removing local entries that would deploy
# the same files as commit mode. Works at file level, not just entry level,
# so "rules/rule1.mdc" conflicts with "rulesets/set1" if set1 contains rule1.
#
# Uses temporary files to avoid subshell variable issues in the conflict
# resolution loop.
#
# Globals:
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   LOCAL_MANIFEST_FILE - Local manifest filename
#
# Arguments:
#   None
#
# Outputs:
#   None
#
# Returns:
#   0 always
#
resolve_conflicts() {
	if [ "$(is_mode_active commit)" = "false" ] || [ "$(is_mode_active local)" = "false" ]; then
		return 0  # No conflicts possible with single mode
	fi
	
	if [ ! -f "${COMMIT_MANIFEST_FILE}" ] || [ ! -f "${LOCAL_MANIFEST_FILE}" ]; then
		return 0  # Can't have conflicts if manifests don't exist
	fi
	
	# Get all .mdc files that would be deployed by commit manifest
	rc_commit_files=$(get_files_from_manifest "${COMMIT_MANIFEST_FILE}" 2>/dev/null || true)
	
	if [ -n "${rc_commit_files}" ]; then
		# Use a temporary file to avoid subshell issues
		rc_temp_file=$(mktemp)
		echo "${rc_commit_files}" > "${rc_temp_file}"
		
		# For each file that commit would deploy, remove any local entries that would deploy the same file
		while IFS= read -r rc_filename; do
			if [ -n "${rc_filename}" ]; then
				remove_local_entries_deploying_file "${rc_filename}"
			fi
		done < "${rc_temp_file}"
		
		# Clean up temporary file
		rm -f "${rc_temp_file}"
	fi
}

# Validation Utilities
# ===================

# Validate manifest file format (minimal implementation)
#
# Globals:
#   None
#
# Arguments:
#   $1 - Manifest file path
#
# Outputs:
#   Stderr: Warning messages for invalid format
#
# Returns:
#   0 if valid format
#   1 if invalid or missing
#
validate_manifest_format() {
	vmf_manifest_file="${1}"
	
	if [ ! -f "${vmf_manifest_file}" ]; then
		return 1
	fi
	
	# Check if file is empty
	if [ ! -s "${vmf_manifest_file}" ]; then
		warn "Manifest file ${vmf_manifest_file} is empty"
		return 1
	fi
	
	# Check first line format
	vmf_first_line=$(head -n1 "${vmf_manifest_file}")
	if ! echo "${vmf_first_line}" | grep -q "	"; then
		warn "Invalid manifest format in ${vmf_manifest_file}: First line must be 'source_repo<tab>target_dir'"
		return 1
	fi
	
	return 0
}

# Validate that both manifests use the same source repository (hard error)
#
# Globals:
#   COMMIT_SOURCE_REPO - Commit mode source repository
#   LOCAL_SOURCE_REPO - Local mode source repository
#
# Arguments:
#   None
#
# Outputs:
#   None
#
# Returns:
#   Never returns on error (calls error() function)
#   0 if valid or single mode
#
# Show detailed manifest integrity error with fix options
#
# Displays comprehensive error message for repository mismatches with
# copy-pasteable commands to resolve the issue. Provides three clear
# options for users to sync their manifests.
#
# Globals:
#   LOCAL_SOURCE_REPO - Local mode source repository
#   COMMIT_SOURCE_REPO - Commit mode source repository
#
# Arguments:
#   None
#
# Outputs:
#   Stderr: Detailed error message with fix options
#
# Returns:
#   None (function only outputs error message)
#
show_manifest_integrity_error() {
	# Read the first line of each manifest to show the exact difference
	local_metadata=""
	commit_metadata=""
	
	if [ -f "${LOCAL_MANIFEST_FILE}" ]; then
		local_metadata=$(head -n1 "${LOCAL_MANIFEST_FILE}")
	fi
	
	if [ -f "${COMMIT_MANIFEST_FILE}" ]; then
		commit_metadata=$(head -n1 "${COMMIT_MANIFEST_FILE}")
	fi
	
	cat >&2 << EOF
Error: Manifest integrity error - manifests have different metadata:

  Local manifest:  ${local_metadata}
  Commit manifest: ${commit_metadata}

To fix this, choose which configuration you want to use for both modes:

Option 1: Switch local mode to match commit mode
  ai-rizz deinit --local -y && ai-rizz init ${SOURCE_REPO} -d "${TARGET_DIR}" --local

Option 2: Switch commit mode to match local mode  
  ai-rizz deinit --commit -y && ai-rizz init ${SOURCE_REPO} -d "${TARGET_DIR}" --commit

Option 3: Reset everything and start fresh
  ai-rizz deinit --all -y && ai-rizz init
EOF
}

# Validate that both manifests have matching metadata (hard error)
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#
# Arguments:
#   None
#
# Outputs:
#   None
#
# Returns:
#   Never returns on error (calls error() function)
#   0 if valid or single mode
#
validate_manifest_integrity() {
	if [ "$(is_mode_active commit)" = "true" ] && [ "$(is_mode_active local)" = "true" ]; then
		# Check if manifests exist
		if [ ! -f "${LOCAL_MANIFEST_FILE}" ] || [ ! -f "${COMMIT_MANIFEST_FILE}" ]; then
			return 0
		fi
		
		# Read the first line (metadata) of each manifest
		local_metadata=$(head -n1 "${LOCAL_MANIFEST_FILE}")
		commit_metadata=$(head -n1 "${COMMIT_MANIFEST_FILE}")
		
		# Compare the entire metadata line
		if [ "${local_metadata}" != "${commit_metadata}" ]; then
			show_manifest_integrity_error
			exit 1
		fi
	fi
}

# Consolidated Helper Functions for Command Logic
# ============================================

# Consolidate initialization check and integrity validation
#
# Performs both the basic initialization check and manifest integrity validation
# that commonly appear together throughout command functions.
#
# Globals:
#   None
#
# Arguments:
#   None
#
# Outputs:
#   Stderr: Error messages on failure
#
# Returns:
#   Never returns on error (calls error() function)
#   0 if any mode is initialized and integrity is valid
#
ensure_initialized_and_valid() {
	# Check if any mode is initialized (including global)
	if [ "$(is_mode_active commit)" = "false" ] && \
	   [ "$(is_mode_active local)" = "false" ] && \
	   [ "$(is_mode_active global)" = "false" ]; then
		show_initialization_error
	fi
	
	# Cache manifest metadata to populate target directory globals
	cache_manifest_metadata
	
	# Validate manifest integrity (hard error for mismatched source repos)
	validate_manifest_integrity
}

# Handle smart mode selection
#
# Implements the common pattern of selecting a mode when not explicitly provided
# by choosing the single available mode or prompting for selection when multiple exist.
# Will check AI_RIZZ_MODE environment variable as a fallback if no mode is provided.
#
# Supports three modes: local, commit, and global
#
# Globals:
#   None
#
# Arguments:
#   $1 - Current mode value (may be empty)
#
# Outputs:
#   Stdout: Selected mode ("local", "commit", or "global")
#   Stderr: Error messages on failure
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
select_mode() {
	sm_current_mode="${1}"
	
	# If mode already specified, validate and return
	if [ -n "${sm_current_mode}" ]; then
		case "${sm_current_mode}" in
			local|commit|global)
				echo "${sm_current_mode}"
				return 0
				;;
			*)
				show_invalid_mode_error "${sm_current_mode}"
				;;
			esac
	fi

	# Check environment variable as fallback
	if [ -n "${AI_RIZZ_MODE}" ]; then
		case "${AI_RIZZ_MODE}" in
			local|commit|global)
				echo "${AI_RIZZ_MODE}"
				return 0
				;;
			*)
				# Invalid mode in environment variable - just ignore it
				;;
		esac
	fi
	
	# Smart mode selection - count active modes
	sm_local_active=$(is_mode_active local)
	sm_commit_active=$(is_mode_active commit)
	sm_global_active=$(is_mode_active global)
	
	sm_active_count=0
	sm_single_mode=""
	
	if [ "${sm_local_active}" = "true" ]; then
		sm_active_count=$((sm_active_count + 1))
		sm_single_mode="local"
	fi
	if [ "${sm_commit_active}" = "true" ]; then
		sm_active_count=$((sm_active_count + 1))
		sm_single_mode="commit"
	fi
	if [ "${sm_global_active}" = "true" ]; then
		sm_active_count=$((sm_active_count + 1))
		sm_single_mode="global"
	fi
	
	# Auto-select if only one mode is active
	if [ "${sm_active_count}" -eq 1 ]; then
		echo "${sm_single_mode}"
		return 0
	fi
	
	# Multiple modes active - require explicit selection
	show_mode_selection_error "command"
}

# Handle lazy initialization with tracking
#
# Implements the pattern of checking if lazy initialization is needed and tracking
# whether it occurred, commonly used in add operations.
#
# Globals:
#   None (calls needs_lazy_init and lazy_init_mode functions)
#
# Arguments:
#   $1 - Mode to potentially initialize
#
# Outputs:
#   Stdout: "true" if lazy initialization occurred, "false" otherwise
#   Stderr: May output from lazy_init_mode function
#
# Returns:
#   0 on success
#
initialize_mode_if_needed() {
	imn_mode="${1}"
	
	# Check if lazy initialization is needed and track it
	if needs_lazy_init "${imn_mode}"; then
		lazy_init_mode "${imn_mode}"
		# Refresh cached metadata after lazy initialization
		cache_manifest_metadata
		echo "true"
	else
		echo "false"
	fi
	
	return 0
}

# Select manifest file and target directory based on mode
#
# Implements the common pattern of selecting the correct manifest file and target
# directory based on the mode
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename (read)
#   COMMIT_MANIFEST_FILE - Commit manifest filename (read)
#   TARGET_DIR - Target directory (read)
#   LOCAL_DIR - Local directory name (read)
#   SHARED_DIR - Shared directory name (read)
#   SOURCE_REPO - Source repository (read)
#
# Arguments:
#   $1 - Mode ("local" or "commit")
#
# Outputs:
#   Stdout: Tab-separated "manifest_file<TAB>target_dir"
#   Stderr: Warning messages from git_sync if repository update fails
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
get_manifest_and_target() {
	gmt_mode="${1}"
	
	# Ensure global paths are current
	init_global_paths
	
	# Select manifest and target based on mode (clean output)
	case "${gmt_mode}" in
		local)
			printf "%s\t%s\n" "${LOCAL_MANIFEST_FILE}" "${TARGET_DIR}/${LOCAL_DIR}"
			;;
		commit)
			printf "%s\t%s\n" "${COMMIT_MANIFEST_FILE}" "${TARGET_DIR}/${SHARED_DIR}"
			;;
		global)
			printf "%s\t%s\n" "${GLOBAL_MANIFEST_FILE}" "${GLOBAL_RULES_DIR}"
			;;
	esac
	
	return 0
}

# Add .mdc extension to an item if not present
#
# Implements the common pattern of ensuring an item has the .mdc extension.
#
# Globals:
#   None
#
# Arguments:
#   $1 - Item name to normalize
#
# Outputs:
#   Stdout: Item name with .mdc extension
#
# Returns:
#   0 on success
#
ensure_mdc_extension() {
	eme_item="${1}"
	
	# Add .mdc extension if not present
	case "${eme_item}" in
		*".mdc") 
			echo "${eme_item}"
			;;  
		*) 
			echo "${eme_item}.mdc"
			;;  
	esac
	
	return 0
}

# Check if an item exists in the repository
#
# Implements the common pattern of checking if an item exists in the source
# repository and outputting a warning if not found. Handles both files and
# directories.
#
# Globals:
#   REPO_DIR - Repository directory (read)
#
# Arguments:
#   $1 - Item path relative to repository
#   $2 - Item type description (e.g., "rule", "ruleset") for warning message
#   $3 - Type expected: "file" or "dir" (optional, defaults to "file")
#
# Outputs:
#   Stderr: Warning message if item not found
#
# Returns:
#   0 if item exists
#   1 if item not found
#
check_repository_item() {
	cri_item_path="${1}"
	cri_item_type="${2}"
	cri_expected_type="${3:-file}"  # Default to file if not specified
	cri_repo_dir="${4:-${REPO_DIR}}"  # Default to REPO_DIR if not specified
	
	# Check if item exists in source repo based on expected type
	case "${cri_expected_type}" in
		file)
			if [ ! -f "${cri_repo_dir}/${cri_item_path}" ]; then
				warn "${cri_item_type} not found: ${cri_item_path}"
				return 1
			fi
			;;
		dir)
			if [ ! -d "${cri_repo_dir}/${cri_item_path}" ]; then
				warn "${cri_item_type} not found: ${cri_item_path}"
				return 1
			fi
			;;
		*)
			warn "Invalid type check: ${cri_expected_type}. Must be 'file' or 'dir'"
			return 1
			;;
	esac
	
	return 0
}

# Get the appropriate repository directory for a given mode
#
# Returns GLOBAL_REPO_DIR for global mode, REPO_DIR for local/commit modes.
# This enables cache isolation where global mode uses a separate cache.
#
# Globals:
#   REPO_DIR - Local/commit mode repository directory
#   GLOBAL_REPO_DIR - Global mode repository directory
#
# Arguments:
#   $1 - Mode ("local", "commit", or "global")
#
# Outputs:
#   Stdout: Appropriate repository directory path
#
# Returns:
#   0 always
#
get_repo_dir_for_mode() {
	grdm_mode="${1}"
	
	case "${grdm_mode}" in
		global)
			echo "${GLOBAL_REPO_DIR}"
			;;
		*)
			echo "${REPO_DIR}"
			;;
	esac
}

# Handle conflict resolution migration logic
#
# Implements the complex pattern of migrating entries between modes to resolve
# conflicts, handling both normal operation and post-lazy-initialization scenarios.
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename (read)
#   COMMIT_MANIFEST_FILE - Commit manifest filename (read)
#
# Arguments:
#   $1 - Item path to migrate
#   $2 - Target mode ("local" or "commit")
#   $3 - Lazy initialization occurred flag ("true" or "false")
#
# Outputs:
#   None (may call remove_manifest_entry_from_file)
#
# Returns:
#   0 on success
#
migrate_from_opposite_mode() {
	mfom_item_path="${1}"
	mfom_target_mode="${2}"
	mfom_lazy_init_occurred="${3}"
	
	# Check if item exists in opposite mode (conflict resolution)
	# Skip migration check if we just lazy-initialized the target mode (it's empty)
	if [ "${mfom_lazy_init_occurred}" = "false" ]; then
		case "${mfom_target_mode}" in
			local)
				if [ "$(is_mode_active commit)" = "true" ]; then
					if read_manifest_entries "${COMMIT_MANIFEST_FILE}" | grep -q "^${mfom_item_path}$"; then
						# Remove from commit mode, add to local mode
						remove_manifest_entry_from_file "${COMMIT_MANIFEST_FILE}" "${mfom_item_path}"
					fi
				fi
				;;
			commit)
				if [ "$(is_mode_active local)" = "true" ]; then
					if read_manifest_entries "${LOCAL_MANIFEST_FILE}" | grep -q "^${mfom_item_path}$"; then
						# Remove from local mode, add to commit mode
						remove_manifest_entry_from_file "${LOCAL_MANIFEST_FILE}" "${mfom_item_path}"
					fi
				fi
				;;
		esac
	else
		# Lazy initialization occurred - need to migrate from opposite mode
		case "${mfom_target_mode}" in
			local)
				# We just created local mode, migrate from commit mode if item exists there
				if [ "$(is_mode_active commit)" = "true" ]; then
					if read_manifest_entries "${COMMIT_MANIFEST_FILE}" | grep -q "^${mfom_item_path}$"; then
						remove_manifest_entry_from_file "${COMMIT_MANIFEST_FILE}" "${mfom_item_path}"
					fi
				fi
				;;
			commit)
				# We just created commit mode, migrate from local mode if item exists there
				if [ "$(is_mode_active local)" = "true" ]; then
					if read_manifest_entries "${LOCAL_MANIFEST_FILE}" | grep -q "^${mfom_item_path}$"; then
						remove_manifest_entry_from_file "${LOCAL_MANIFEST_FILE}" "${mfom_item_path}"
					fi
				fi
				;;
		esac
	fi
	
	return 0
}

# Commands
# ========

# Initialize the repository (progressive initialization)
#
# Creates local or commit mode with manifest file, target directory structure,
# and git excludes (for local mode). 
#
# Prompts for missing parameters, validates mode compatibility, syncs source 
# repository, and handles idempotent re-init. Supports progressive dual-mode 
# by preserving existing mode configuration.
#
# Key behaviors:
# • Prompts for missing source repo, target dir, and mode
# • Validates git repository context and mode compatibility  
# • Creates manifest files and directory structure
# • Sets up git excludes for local mode only
# • Handles idempotent re-initialization
# • Uses environment variable fallbacks if available
#
# Globals:
#   COMMIT_MANIFEST_FILE - Commit manifest filename (read)
#   LOCAL_MANIFEST_FILE - Local manifest filename (read)
#   CUSTOM_MANIFEST_ROOT - Custom manifest root filename (read)
#   DEFAULT_TARGET_DIR - Default target directory
#   LOCAL_DIR - Local directory name
#   SHARED_DIR - Shared directory name
#
# Arguments:
#   [source_repo]        - Repository URL (prompted if not provided)
#   [-d target_dir]      - Target directory (defaults to .cursor/rules)
#   [--local|-l]         - Initialize local mode (git-ignored)
#   [--commit|-c]        - Initialize commit mode (git-tracked)
#   [-s, --skibidi file]  - Use custom manifest root filename (processed globally)
#   [-f, --manifest file] - Alias for --skibidi (processed globally)
#   [--rule-path]        - Rules path (optional, defaults to "rules")
#   [--ruleset-path]     - Rulesets path (optional, defaults to "rulesets")
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
cmd_init() {
	ci_source_repo=""
	ci_target_dir=""
	ci_mode=""
	ci_rule_path=""
	ci_ruleset_path=""
	ci_hook_based=false
	
	# Parse arguments
	while [ $# -gt 0 ]; do
		case "$1" in
			-d)
				ci_target_dir="$2"
				shift 2
				;;
			--local|-l)
				ci_mode="local"
				shift
				;;
			--commit|-c)
				ci_mode="commit"
				shift
				;;
			--global|-g)
				ci_mode="global"
				shift
				;;
			--hook-based-ignore)
				ci_hook_based=true
				shift
				;;
			--rule-path)
				ci_rule_path="$2"
				shift 2
				;;
			--ruleset-path)
				ci_ruleset_path="$2"
				shift 2
				;;
			*)
				if [ -z "${ci_source_repo}" ]; then
					ci_source_repo="$1"
					shift
				else
					error "Unknown argument: $1"
				fi
				;;
		esac
	done
	
	# Use environment variables as fallbacks
	if [ -z "${ci_source_repo}" ] && [ -n "${AI_RIZZ_SOURCE_REPO}" ]; then
		ci_source_repo="${AI_RIZZ_SOURCE_REPO}"
	fi
	
	if [ -z "${ci_target_dir}" ] && [ -n "${AI_RIZZ_TARGET_DIR}" ]; then
		ci_target_dir="${AI_RIZZ_TARGET_DIR}"
	fi
	
	if [ -z "${ci_mode}" ] && [ -n "${AI_RIZZ_MODE}" ]; then
		ci_mode="${AI_RIZZ_MODE}"
	fi
	
	if [ -z "${ci_rule_path}" ] && [ -n "${AI_RIZZ_RULE_PATH}" ]; then
		ci_rule_path="${AI_RIZZ_RULE_PATH}"
	fi
	
	if [ -z "${ci_ruleset_path}" ] && [ -n "${AI_RIZZ_RULESET_PATH}" ]; then
		ci_ruleset_path="${AI_RIZZ_RULESET_PATH}"
	fi
	
	# Use defaults if still not provided
	if [ -z "${ci_rule_path}" ]; then
		ci_rule_path="${DEFAULT_RULES_PATH}"
	fi
	
	if [ -z "${ci_ruleset_path}" ]; then
		ci_ruleset_path="${DEFAULT_RULESETS_PATH}"
	fi
	
	# Prompt for source repo if not provided
	if [ -z "${ci_source_repo}" ]; then
		printf "Source repository URL: "
		read -r ci_source_repo
		if [ -z "${ci_source_repo}" ]; then
			error "Source repository URL is required"
		fi
	fi
	
	# Use default target directory if not provided
	if [ -z "${ci_target_dir}" ]; then
		ci_target_dir="${DEFAULT_TARGET_DIR}"
	fi
	
	# Prompt for mode if not provided
	if [ -z "${ci_mode}" ]; then
		printf "Mode [local/commit/global]: "
		read -r ci_mode
		if [ -z "${ci_mode}" ]; then
			ci_mode="local"
		fi
	fi
	
	# Validate mode
	case "${ci_mode}" in
		local|commit|global)
			;;
		*)
			error "Invalid mode: ${ci_mode}. Must be 'local', 'commit', or 'global'"
			;;
	esac

	# If any mode already exists, use its source_repo (no override allowed)
	# This enables `ai-rizz init --global` to inherit the source repo from an existing mode
	if [ "$(is_mode_active commit)" = "true" ] || [ "$(is_mode_active local)" = "true" ]; then
		# Use the unified SOURCE_REPO variable from repo modes
		ci_source_repo="${SOURCE_REPO}"
	elif [ "$(is_mode_active global)" = "true" ]; then
		# If only global mode exists, use its source repo
		ci_global_metadata=$(read_manifest_metadata "${GLOBAL_MANIFEST_FILE}" 2>/dev/null || echo "")
		if [ -n "${ci_global_metadata}" ]; then
			ci_source_repo=$(echo "${ci_global_metadata}" | cut -f1 -d"	")
		fi
	fi

	# Check if repository is already initialized in the requested mode
	case "${ci_mode}" in
		local)
			if [ "$(is_mode_active local)" = "true" ]; then
				# Check if parameters match existing configuration using the unified variables
				if [ "${SOURCE_REPO}" = "${ci_source_repo}" ] && [ "${TARGET_DIR}" = "${ci_target_dir}" ]; then
					# Check if mode switching is needed
					ci_current_hook_based=$(is_hook_based_mode_active)
					if [ "${ci_hook_based}" = "true" ] && [ "${ci_current_hook_based}" = "false" ]; then
						# Switch from regular to hook-based mode
						remove_local_mode_excludes "${ci_target_dir}"
						setup_pre_commit_hook "${ci_target_dir}"
						cat <<EOF
Switched local mode to pre-commit hook
	source: ${ci_source_repo}
	target: ${ci_target_dir}
	mode: ${ci_mode} (pre-commit)
EOF
						return 0
					elif [ "${ci_hook_based}" = "false" ] && [ "${ci_current_hook_based}" = "true" ]; then
						# Switch from hook-based to regular mode
						remove_pre_commit_hook
						setup_local_mode_excludes "${ci_target_dir}"
						cat <<EOF
Switched local mode to .git/info/exclude
	source: ${ci_source_repo}
	target: ${ci_target_dir}
	mode: ${ci_mode} (.git/info/exclude)
EOF
						return 0
					else
						# Same mode, idempotent success
						printf "(already initialized; no changes needed)\n"
						return 0  # Idempotent success
					fi
				else
					error "Local mode already initialized with different parameters. Use 'ai-rizz deinit --local' first."
				fi
			fi
			;;
		commit)
			if [ "$(is_mode_active commit)" = "true" ]; then
				# Check if parameters match existing configuration using the unified variables
				if [ "${SOURCE_REPO}" = "${ci_source_repo}" ] && [ "${TARGET_DIR}" = "${ci_target_dir}" ]; then
					printf "Initialized ai-rizz with\\n\\tsource: %s\\n\\ttarget: %s\\n\\tmode: %s\\n" "${ci_source_repo}" "${ci_target_dir}" "${ci_mode}"
					return 0  # Idempotent success
				else
					error "Commit mode already initialized with different parameters. Use 'ai-rizz deinit --commit' first."
				fi
			fi
			;;
		global)
			if [ "$(is_mode_active global)" = "true" ]; then
				# Check if parameters match existing global configuration
				ci_global_meta=$(read_manifest_metadata "${GLOBAL_MANIFEST_FILE}" 2>/dev/null || echo "")
				ci_global_source=$(echo "${ci_global_meta}" | cut -f1 -d"	")
				if [ "${ci_global_source}" = "${ci_source_repo}" ]; then
					printf "(already initialized; no changes needed)\n"
					return 0  # Idempotent success
				else
					error "Global mode already initialized with different source repository. Use 'ai-rizz deinit --global' first."
				fi
			fi
			;;
	esac
	
	# Ensure git repository context for local and commit modes
	# Only global mode can work outside a git repository
	if [ "${ci_mode}" != "global" ] && [ ! -d ".git" ]; then
		show_git_context_error
	fi
	
	# Clone/sync source repository first
	if ! git_sync "${ci_source_repo}"; then
		show_repository_error "${ci_source_repo}"
	fi
	
	# Initialize the requested mode
	case "${ci_mode}" in
		local)
			# Create local mode structure
			mkdir -p "${ci_target_dir}/${LOCAL_DIR}"
			
			# Write empty manifest with metadata (including custom paths)
			echo "" | write_manifest_with_entries "${LOCAL_MANIFEST_FILE}" "${ci_source_repo}" "${ci_target_dir}" "${ci_rule_path}" "${ci_ruleset_path}"
			
			# Setup based on hook-based flag
			if [ "${ci_hook_based}" = "true" ]; then
				# Hook-based mode: setup hook, don't use git exclude
				setup_pre_commit_hook "${ci_target_dir}"
			else
				# Regular mode: setup git excludes
				setup_local_mode_excludes "${ci_target_dir}"
			fi
			
			# Update mode state and cache - set unified variables
			SOURCE_REPO="${ci_source_repo}"
			TARGET_DIR="${ci_target_dir}"
			;;
			
		commit)
			# Create commit mode structure  
			mkdir -p "${ci_target_dir}/${SHARED_DIR}"
			
			# Write empty manifest with metadata (including custom paths)
			echo "" | write_manifest_with_entries "${COMMIT_MANIFEST_FILE}" "${ci_source_repo}" "${ci_target_dir}" "${ci_rule_path}" "${ci_ruleset_path}"
			
			# Update mode state and cache - set unified variables
			SOURCE_REPO="${ci_source_repo}"
			TARGET_DIR="${ci_target_dir}"
			;;
			
		global)
			# Ensure global paths are current
			init_global_paths
			
			# Create global mode directory structure
			mkdir -p "${GLOBAL_RULES_DIR}"
			mkdir -p "${GLOBAL_COMMANDS_DIR}"
			
			# Write manifest to home directory
			# Global mode uses its own target dir (the global dirs) but stores the source repo
			echo "" | write_manifest_with_entries "${GLOBAL_MANIFEST_FILE}" "${ci_source_repo}" ".cursor/rules" "${ci_rule_path}" "${ci_ruleset_path}"
			
			# Update unified variables for global mode
			SOURCE_REPO="${ci_source_repo}"
			TARGET_DIR=".cursor/rules"
			
			printf "Initialized ai-rizz with\\n\\tsource: %s\\n\\ttarget: %s (global)\\n\\tmode: %s\\n" "${ci_source_repo}" "${GLOBAL_RULES_DIR}" "${ci_mode}"
			return 0
			;;
	esac
	
	# Set unified paths (identical across modes)
	RULES_PATH="${ci_rule_path}"
	RULESETS_PATH="${ci_ruleset_path}"
	
	printf "Initialized ai-rizz with\\n\\tsource: %s\\n\\ttarget: %s\\n\\tmode: %s\\n" "${ci_source_repo}" "${ci_target_dir}" "${ci_mode}"
	return 0
}

# Recursively remove empty parent directories
#
# Globals:
#   HOME - User home directory (used as stop condition)
#
# Arguments:
#   $1 - Directory to check and potentially remove
#
# Outputs:
#   Stdout: Messages about removed directories
#
# Returns:
#   0 always
#
cleanup_empty_parents() {
  cep_dir="${1}"
  # Check if directory exists and is empty
  if [ -d "${cep_dir}" ] && [ -z "$(ls -A "${cep_dir}")" ]; then
	cep_parent_dir=$(dirname "${cep_dir}")
	echo "Removing empty directory: ${cep_dir}"
	rmdir "${cep_dir}"
	
	# Stop at filesystem root, home directory, or current directory
	if [ "${cep_parent_dir}" != "/" ] && [ "${cep_parent_dir}" != "${HOME}" ] && [ "${cep_parent_dir}" != "." ]; then
	  cleanup_empty_parents "${cep_parent_dir}"
	fi
  fi
}

# Deinitialize the repository (progressive mode-aware)
#
# Removes specified mode(s) including manifest files, target directories,
# and git exclude configurations. Interactive with confirmation prompt unless -y flag
# is used. Performs cleanup of empty parent directories after removal.
# Uses AI_RIZZ_MODE environment variable as a fallback when no mode flag is provided.
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   TARGET_DIR - Target directory base path
#   SOURCE_REPO - Source repository URL
#
# Arguments:
#   [--local|-l]         - Remove local mode only
#   [--commit|-c]        - Remove commit mode only
#   [--all|-a]           - Remove all modes (default if neither --local nor --commit specified)
#   [-y]                 - Skip confirmation prompts
#
# Outputs:
#   Stdout: Confirmation prompts and success messages
#   Stderr: Error messages
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
cmd_deinit() {
	cd_force=false
	cd_mode=""
	
	# Parse arguments
	while [ $# -gt 0 ]; do
		case "$1" in
			-y)
				cd_force=true
				shift
				;;
			--local|-l)
				cd_mode="local"
				shift
				;;
			--commit|-c)
				cd_mode="commit"
				shift
				;;
			--global|-g)
				cd_mode="global"
				shift
				;;
			--all|-a)
				cd_mode="all"
				shift
				;;
			*)
				error "Unknown argument: $1"
				;;
		esac
	done
	
	# Check for environment variable fallback if no mode provided
	if [ -z "${cd_mode}" ] && [ -n "${AI_RIZZ_MODE}" ]; then
		case "${AI_RIZZ_MODE}" in
			local|commit|global)
				cd_mode="${AI_RIZZ_MODE}"
				;;
			all)
				cd_mode="all"
				;;
			*)
				# Invalid mode in environment variable - just ignore it
				;;
		esac
	fi

	# Just cache metadata without validation for deinit
	# This allows deinit to work with invalid or partially initialized states
	cache_manifest_metadata
	
	# Prompt for mode if still not provided
	if [ -z "${cd_mode}" ]; then
		# Count active modes
		cd_active_count=0
		cd_last_active=""
		if [ "$(is_mode_active local)" = "true" ]; then
			cd_active_count=$(expr ${cd_active_count} + 1)
			cd_last_active="local"
		fi
		if [ "$(is_mode_active commit)" = "true" ]; then
			cd_active_count=$(expr ${cd_active_count} + 1)
			cd_last_active="commit"
		fi
		if [ "$(is_mode_active global)" = "true" ]; then
			cd_active_count=$(expr ${cd_active_count} + 1)
			cd_last_active="global"
		fi
		
		if [ ${cd_active_count} -gt 1 ]; then
			# Multiple modes active - prompt user
			printf "Which mode to remove [local/commit/global/all]: "
			read -r cd_mode
		elif [ ${cd_active_count} -eq 1 ]; then
			cd_mode="${cd_last_active}"
		else
			# No modes active, default to all for idempotence
			cd_mode="all"
		fi
	fi
	
	# Validate mode
	case "${cd_mode}" in
		local|commit|global|all)
			;;
		*)
			error "Invalid mode: ${cd_mode}. Must be 'local', 'commit', 'global', or 'all'"
			;;
	esac
	
	# Determine what to remove
	cd_remove_local=false
	cd_remove_commit=false
	cd_remove_global=false
	
	case "${cd_mode}" in
		local)
			# Just set removal flag without validation - allow deinit of non-existent modes
			cd_remove_local=true
			;;
		commit)
			# Just set removal flag without validation - allow deinit of non-existent modes
			cd_remove_commit=true
			;;
		global)
			# Just set removal flag without validation - allow deinit of non-existent modes
			cd_remove_global=true
			;;
		all)
			cd_remove_local=true
			cd_remove_commit=true
			cd_remove_global=true
			;;
	esac
	
	# Build confirmation message
	cd_items_to_remove=""
	if [ "${cd_remove_local}" = "true" ] && [ "$(is_mode_active local)" = "true" ]; then
		cd_items_to_remove="${cd_items_to_remove} ${LOCAL_MANIFEST_FILE} ${TARGET_DIR}/${LOCAL_DIR}"
	fi
	if [ "${cd_remove_commit}" = "true" ] && [ "$(is_mode_active commit)" = "true" ]; then
		cd_items_to_remove="${cd_items_to_remove} ${COMMIT_MANIFEST_FILE} ${TARGET_DIR}/${SHARED_DIR}"
	fi
	if [ "${cd_remove_global}" = "true" ] && [ "$(is_mode_active global)" = "true" ]; then
		cd_items_to_remove="${cd_items_to_remove} ${GLOBAL_MANIFEST_FILE} ${GLOBAL_RULES_DIR} ${GLOBAL_COMMANDS_DIR}"
	fi
	
	# Confirm deletion
	if ! ${cd_force} && [ -n "${cd_items_to_remove}" ]; then
		echo "This will delete:${cd_items_to_remove}"
		printf "Are you sure? [y/N] "
		read -r cd_confirm
		if [ "${cd_confirm}" != "y" ] && [ "${cd_confirm}" != "Y" ]; then
			echo "Canceled"
			return 0
		fi
	fi
	
	# Save target directory for cleanup before clearing it
	cd_target_for_cleanup="${TARGET_DIR}"
	
	# Remove local mode
	if [ "${cd_remove_local}" = "true" ] && [ "$(is_mode_active local)" = "true" ]; then
		# Remove from git excludes (if present)
		remove_local_mode_excludes "${TARGET_DIR}"
		
		# Remove hook (if present)
		remove_pre_commit_hook
		
		# Remove files
		rm -rf "${TARGET_DIR:?}/${LOCAL_DIR}"
		rm -f "${LOCAL_MANIFEST_FILE}"
		
		# Also remove local commands directory
		rm -rf ".cursor/commands/${LOCAL_DIR}"
		
		# Only clear unified variables if commit mode isn't active
		if [ "$(is_mode_active commit)" = "false" ]; then
			SOURCE_REPO=""
			TARGET_DIR=""
		fi
		
		echo "Removed local mode configuration"
	fi
	
	# Remove commit mode
	if [ "${cd_remove_commit}" = "true" ] && [ "$(is_mode_active commit)" = "true" ]; then
		# Remove files (no git exclude changes needed for commit mode)
		rm -rf "${TARGET_DIR:?}/${SHARED_DIR}"
		rm -f "${COMMIT_MANIFEST_FILE}"
		
		# Also remove commit commands directory
		rm -rf ".cursor/commands/${SHARED_DIR}"
		
		# Only clear unified variables if local mode isn't active
		if [ "$(is_mode_active local)" = "false" ]; then
			SOURCE_REPO=""
			TARGET_DIR=""
		fi
		
		echo "Removed commit mode configuration"
	fi
	
	# Remove global mode
	if [ "${cd_remove_global}" = "true" ] && [ "$(is_mode_active global)" = "true" ]; then
		# Remove files
		rm -rf "${GLOBAL_RULES_DIR}"
		rm -rf "${GLOBAL_COMMANDS_DIR}"
		rm -f "${GLOBAL_MANIFEST_FILE}"
		
		echo "Removed global mode configuration"
	fi
	
	# Clean up empty parent directories using saved value
	if [ -n "${cd_target_for_cleanup}" ]; then
		if [ "${cd_remove_local}" = "true" ]; then
			cd_parent_dir=$(dirname "${cd_target_for_cleanup}/${LOCAL_DIR}")
			if [ "${cd_parent_dir}" != "." ] && [ "${cd_parent_dir}" != "/" ]; then
				cleanup_empty_parents "${cd_parent_dir}"
			fi
		fi
		
		if [ "${cd_remove_commit}" = "true" ]; then
			cd_parent_dir=$(dirname "${cd_target_for_cleanup}/${SHARED_DIR}")
			if [ "${cd_parent_dir}" != "." ] && [ "${cd_parent_dir}" != "/" ]; then
				cleanup_empty_parents "${cd_parent_dir}"
			fi
		fi
	fi
	
	return 0
}

# List available rules and rulesets (multi-mode aware)
#
# Shows rules and rulesets with glyphs indicating installation status.
# Handles dual-mode conflict resolution (commit overrides local) & expands
# rulesets to show contents. Syncs repository before listing.
#
# Globals:
#   SOURCE_REPO - Source repository URL
#   REPO_DIR - Repository directory
#   COMMITTED_GLYPH - Glyph for committed items
#   LOCAL_GLYPH - Glyph for local items
#   UNINSTALLED_GLYPH - Glyph for uninstalled items
#
# Arguments:
#   None
#
# Outputs:
#   Stdout: Formatted list of rules and rulesets
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
cmd_list() {
	# Ensure ai-rizz is initialized and validate manifest integrity
	ensure_initialized_and_valid

	# Validate manifest format for all existing manifests
	if [ "$(is_mode_active local)" = "true" ]; then
		validate_manifest_format "${LOCAL_MANIFEST_FILE}" || error "Corrupted local manifest file"
	fi
	if [ "$(is_mode_active commit)" = "true" ]; then
		validate_manifest_format "${COMMIT_MANIFEST_FILE}" || error "Corrupted commit manifest file"
	fi
	if [ "$(is_mode_active global)" = "true" ]; then
		validate_manifest_format "${GLOBAL_MANIFEST_FILE}" || error "Corrupted global manifest file"
	fi
	
	# Use the unified SOURCE_REPO variable
	cl_source_repo="${SOURCE_REPO}"
	
	# Update source repository
	git_sync "${cl_source_repo}"
	
	# Helper function to check if an item is installed in any mode
	is_installed() {
		cl_is_installed_item="${1}"
		cl_is_installed_status="uninstalled"
		
		# Helper to check if item is covered by rulesets in a manifest
		check_rulesets_for_item() {
			cl_check_manifest_file="${1}"
			cl_check_item_basename=$(basename "${cl_is_installed_item}")
			cl_check_item_path="${REPO_DIR}/${cl_is_installed_item}"
			cl_check_entries=""
			
			cl_check_entries=$(read_manifest_entries "${cl_check_manifest_file}" 2>/dev/null) || return 1
			
			# Use a for loop instead of while to avoid subshell issues
			for cl_check_entry in ${cl_check_entries}; do
				if [ -n "${cl_check_entry}" ] && echo "${cl_check_entry}" | grep -q "^${RULESETS_PATH}/"; then
					# Check if this ruleset contains the item (search recursively)
					cl_check_ruleset_dir="${REPO_DIR}/${cl_check_entry}"
					if [ ! -d "${cl_check_ruleset_dir}" ]; then
						continue
					fi
					
					# Search recursively for .mdc files matching the basename
					# Use temporary file to avoid subshell exit code issues (per POSIX style guide)
					cl_check_temp_file=$(mktemp)
					find "${cl_check_ruleset_dir}" -name "${cl_check_item_basename}" \( -type f -o -type l \) > "${cl_check_temp_file}" 2>/dev/null
					
					# Check each match
					while IFS= read -r cl_check_match; do
						if [ -z "${cl_check_match}" ]; then
							continue
						fi
						
						# If it's a symlink, check if it points to the rule file
						if [ -L "${cl_check_match}" ]; then
							# Resolve symlink to absolute path and check if it points to the rule file
							cl_check_target=$(_readlink_f "${cl_check_match}")
							# Compare resolved absolute paths
							if [ -n "${cl_check_target}" ] && [ "${cl_check_target}" = "${cl_check_item_path}" ]; then
								rm -f "${cl_check_temp_file}"
								return 0  # Found in ruleset (symlink points to rule)
							fi
						else
							# Regular file in ruleset - this is a file rule, not a symlink to a rule
							# File rules in rulesets are different from rules in the rules directory
							# Only symlinks to rules should be considered as "installed" rules
							# So we skip regular files (they're file rules, not the rule itself)
							continue
						fi
					done < "${cl_check_temp_file}"
					
					rm -f "${cl_check_temp_file}"
				fi
			done
			return 1  # Not found in any ruleset
		}
		
		# Check global mode first (weakest glyph)
		if [ "$(is_mode_active global)" = "true" ]; then
			# Check if item is directly in manifest
			if read_manifest_entries "${GLOBAL_MANIFEST_FILE}" 2>/dev/null | grep -q "^${cl_is_installed_item}$"; then
				cl_is_installed_status="global"
			elif check_rulesets_for_item "${GLOBAL_MANIFEST_FILE}"; then
				cl_is_installed_status="global"
			fi
		fi
		
		# Check local mode (weaker glyph - overrides global)
		if [ "$(is_mode_active local)" = "true" ]; then
			# Check if item is directly in manifest
			if read_manifest_entries "${LOCAL_MANIFEST_FILE}" 2>/dev/null | grep -q "^${cl_is_installed_item}$"; then
				cl_is_installed_status="local"
			elif check_rulesets_for_item "${LOCAL_MANIFEST_FILE}"; then
				cl_is_installed_status="local"
			fi
		fi
		
		# Check commit mode (strongest glyph - overrides local and global)
		if [ "$(is_mode_active commit)" = "true" ]; then
			# Check if item is directly in manifest
			if read_manifest_entries "${COMMIT_MANIFEST_FILE}" 2>/dev/null | grep -q "^${cl_is_installed_item}$"; then
				cl_is_installed_status="committed"
			elif check_rulesets_for_item "${COMMIT_MANIFEST_FILE}"; then
				cl_is_installed_status="committed"
			fi
		fi
		
		echo "${cl_is_installed_status}"
	}
	
	# Display rules (*.mdc files)
	echo "Available rules:"
	cl_rules=$(find "${REPO_DIR}/${RULES_PATH}" -maxdepth 1 -name "*.mdc" -type f 2>/dev/null | sort)
	if [ -z "${cl_rules}" ]; then
		echo "  No rules found"
	else
		for cl_rule in ${cl_rules}; do
			cl_rule_name=$(basename "${cl_rule}")
			cl_rule_path="${RULES_PATH}/${cl_rule_name}"
			cl_status=$(is_installed "${cl_rule_path}")
			
			case "${cl_status}" in
				committed)
					printf "  %s %s\n" "${COMMITTED_GLYPH}" "${cl_rule_name}"
					;;
				local)
					printf "  %s %s\n" "${LOCAL_GLYPH}" "${cl_rule_name}"
					;;
				global)
					printf "  %s %s\n" "${GLOBAL_GLYPH}" "${cl_rule_name}"
					;;
				*)
					printf "  %s %s\n" "${UNINSTALLED_GLYPH}" "${cl_rule_name}"
					;;
			esac
		done
	fi
	echo ""
	
	# Display commands (*.md files) with / prefix
	echo "Available commands:"
	cl_commands=$(find "${REPO_DIR}/${RULES_PATH}" -maxdepth 1 -name "*.md" ! -name "*.mdc" -type f 2>/dev/null | sort)
	if [ -z "${cl_commands}" ]; then
		echo "  No commands found"
	else
		for cl_command in ${cl_commands}; do
			cl_command_name=$(basename "${cl_command}")
			cl_command_path="${RULES_PATH}/${cl_command_name}"
			cl_status=$(is_installed "${cl_command_path}")
			
			# Strip .md extension for display (matches Cursor invocation)
			cl_command_display=$(echo "${cl_command_name}" | sed 's/\.md$//')
			
			case "${cl_status}" in
				committed)
					printf "  %s /%s\n" "${COMMITTED_GLYPH}" "${cl_command_display}"
					;;
				local)
					printf "  %s /%s\n" "${LOCAL_GLYPH}" "${cl_command_display}"
					;;
				global)
					printf "  %s /%s\n" "${GLOBAL_GLYPH}" "${cl_command_display}"
					;;
				*)
					printf "  %s /%s\n" "${UNINSTALLED_GLYPH}" "${cl_command_display}"
					;;
			esac
		done
	fi
	echo ""
	
	# Display rulesets
	echo "Available rulesets:"
	cl_rulesets=$(find "${REPO_DIR}/${RULESETS_PATH}" -mindepth 1 -maxdepth 1 -type d | sort 2>/dev/null)
	if [ -z "${cl_rulesets}" ]; then
		echo "  No rulesets found"
	else
		for cl_ruleset in ${cl_rulesets}; do
			cl_ruleset_name=$(basename "${cl_ruleset}")
			cl_ruleset_path="${RULESETS_PATH}/${cl_ruleset_name}"
			cl_status=$(is_installed "${cl_ruleset_path}")
			
			# Display ruleset with installation status
			case "${cl_status}" in
				committed)
					printf "  %s %s\n" "${COMMITTED_GLYPH}" "${cl_ruleset_name}"
					;;
				local)
					printf "  %s %s\n" "${LOCAL_GLYPH}" "${cl_ruleset_name}"
					;;
				global)
					printf "  %s %s\n" "${GLOBAL_GLYPH}" "${cl_ruleset_name}"
					;;
				*)
					printf "  %s %s\n" "${UNINSTALLED_GLYPH}" "${cl_ruleset_name}"
					;;
			esac
			
			# Display ruleset contents (simplified: top-level only, commands/ special)
			# List display rules:
			# - All top-level .mdc files are shown
			# - All top-level subdirs are shown (but NO contents)
			# - "commands" subdir gets special treatment (one level shown)
			if [ -d "${cl_ruleset}" ]; then
				# Get top-level items: .mdc files and directories
				cl_items=$(find "${cl_ruleset}" -maxdepth 1 \( -name "*.mdc" -type f \) -o \( -name "*.mdc" -type l \) -o \( -type d ! -name "." ! -path "${cl_ruleset}" \) | sort)
				cl_item_count=$(echo "${cl_items}" | grep -c . || echo "0")
				cl_current=0
				cl_temp_items=$(mktemp)
				echo "${cl_items}" > "${cl_temp_items}"
				while IFS= read -r cl_item; do
					if [ -z "${cl_item}" ]; then
						continue
					fi
					cl_current=$(expr ${cl_current} + 1)
					cl_basename=$(basename "${cl_item}")
					
					# Determine tree character based on position
					if [ "${cl_current}" -eq "${cl_item_count}" ]; then
						cl_tree_char="└──"
					else
						cl_tree_char="├──"
					fi
					
					# Check if this is the commands/ directory (special treatment)
					if [ "${cl_basename}" = "commands" ] && [ -d "${cl_item}" ]; then
						# Show commands/ directory
						printf "    %s %s\n" "${cl_tree_char}" "${cl_basename}"
						
						# Show one level of commands/ contents (files and subdirs, but not subdir contents)
						cl_cmd_items=$(find "${cl_item}" -maxdepth 1 \( -type f -o -type l -o -type d \) ! -path "${cl_item}" | sort)
						cl_cmd_count=$(echo "${cl_cmd_items}" | grep -c . || echo "0")
						cl_cmd_current=0
						cl_temp_cmd_items=$(mktemp)
						echo "${cl_cmd_items}" > "${cl_temp_cmd_items}"
						while IFS= read -r cl_cmd_item; do
							if [ -z "${cl_cmd_item}" ]; then
								continue
							fi
							cl_cmd_current=$(expr ${cl_cmd_current} + 1)
							cl_cmd_basename=$(basename "${cl_cmd_item}")
							
							# Determine tree character for command item
							if [ "${cl_cmd_current}" -eq "${cl_cmd_count}" ]; then
								cl_cmd_tree_char="└──"
							else
								cl_cmd_tree_char="├──"
							fi
							
							# Show command item (file, symlink, or subdir - but not subdir contents)
							printf "    │   %s %s\n" "${cl_cmd_tree_char}" "${cl_cmd_basename}"
						done < "${cl_temp_cmd_items}"
						rm -f "${cl_temp_cmd_items}"
					else
						# Regular item: .mdc file or subdirectory (show name only, no contents)
						printf "    %s %s\n" "${cl_tree_char}" "${cl_basename}"
					fi
				done < "${cl_temp_items}"
				rm -f "${cl_temp_items}"
			fi
		done
	fi
	
	return 0
}

# Check for rule downgrade conflicts
#
# Prevents adding individual rules to local mode when they're part of 
# committed rulesets. This maintains ruleset integrity by ensuring
# complete rulesets stay together.
#
# Globals:
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   REPO_DIR - Repository directory
#
# Arguments:
#   $1 - Rule name (with .mdc extension)
#   $2 - Target mode (local/commit)
#
# Outputs:
#   Stderr: Warning message if conflict detected
#
# Returns:
#   0 if no conflict (rule can be added)
#   1 if conflict detected (rule should be skipped)
#
check_rule_downgrade_conflict() {
	crdc_rule="$1"
	crdc_mode="$2"
	
	# Only check for downgrade conflicts (local mode with commit mode active)
	if [ "$crdc_mode" = "local" ] && [ "$(is_mode_active commit)" = "true" ]; then
		# Check if this rule is part of any committed ruleset
		rule_filename=$(basename "${RULES_PATH}/$crdc_rule")
		commit_entries=$(read_manifest_entries "$COMMIT_MANIFEST_FILE" 2>/dev/null || true)
		
		if [ -n "$commit_entries" ]; then
			# Use a temporary file to avoid subshell issues with pipes
			temp_file=$(mktemp)
			echo "$commit_entries" > "$temp_file"
			
			conflict_found=false
			
			while IFS= read -r entry; do
				if [ -n "$entry" ]; then
					entry_path="$REPO_DIR/$entry"
					if [ -d "$entry_path" ]; then
						# This is a ruleset - check if it contains our rule
						if find "$entry_path" -name "$rule_filename" -type f -o -name "$rule_filename" -type l | grep -q .; then
							warn "Cannot add individual rule '$crdc_rule' to local mode: it's part of committed ruleset '$entry'. Use 'ai-rizz add-ruleset $(basename "$entry") --local' to move the entire ruleset."
							conflict_found=true
							break
						fi
					fi
				fi
			done < "$temp_file"
			
			# Close file handle before removing file
			rm -f "$temp_file"
			
			# Return conflict status after cleanup
			if [ "$conflict_found" = "true" ]; then
				return 1
			fi
		fi
	fi
	
	return 0
}

# Add rule(s) to the repository (progressive mode-aware)
#
# Adds individual rules to specified mode, handling lazy initialization,
# conflict resolution, and downgrade prevention. Prevents adding individual
# rules to local mode when they're part of committed rulesets. Auto-detects
# mode when only one exists, migrates rules between modes on conflicts.
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   SOURCE_REPO - Source repository URL
#   TARGET_DIR - Target directory for rules
#   LOCAL_DIR - Local directory name
#   SHARED_DIR - Shared directory name
#   REPO_DIR - Repository directory
#
# Arguments:
#   <rule>...            - Rule names (.mdc extension optional)
#   [--local|-l]         - Add to local mode (git-ignored)
#   [--commit|-c]        - Add to commit mode (git-tracked)
#
# Outputs:
#   Stdout: Success messages for each added rule
#   Stderr: Warning messages for conflicts or missing rules
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
cmd_add_rule() {
	car_mode=""
	car_rules=""
	
	# Parse arguments
	while [ $# -gt 0 ]; do
		case "$1" in
			--local|-l)
				car_mode="local"
				shift
				;;
			--commit|-c)
				car_mode="commit"
				shift
				;;
			--global|-g)
				car_mode="global"
				shift
				;;
			*)
				if [ -z "${car_rules}" ]; then
					car_rules="$1"
				else
					car_rules="${car_rules} $1"
				fi
				shift
				;;
		esac
	done
	
	# Check if any mode is initialized and validate manifest integrity
	ensure_initialized_and_valid

	# Smart mode selection using helper function
	car_mode=$(select_mode "${car_mode}")

	# Check if lazy initialization is needed and track it using helper function
	car_lazy_init_occurred=$(initialize_mode_if_needed "${car_mode}")

	# Select manifest and target based on mode using helper function
	car_manifest_and_target=$(get_manifest_and_target "${car_mode}")
	car_manifest_file=$(echo "${car_manifest_and_target}" | cut -f1 -d"	") # Using literal tab as delimiter
	car_target_dir=$(echo "${car_manifest_and_target}" | cut -f2 -d"	") # Using literal tab as delimiter

	# Get the correct repo dir for this mode (cache isolation)
	car_repo_dir=$(get_repo_dir_for_mode "${car_mode}")

	# Process each rule
	for car_rule in ${car_rules}; do
		# Handle extension: .mdc for rules, .md for commands
		# If no extension, default to .mdc (rule)
		case "${car_rule}" in
			*".mdc"|*".md") 
				car_item="${car_rule}"
				;;  
			*) 
				car_item="${car_rule}.mdc"
				;;  
		esac
		
		car_rule_path="${RULES_PATH}/${car_item}"
		
		# Check if rule/command exists in the correct source repo for this mode
		if ! check_repository_item "${car_rule_path}" "Rule" "file" "${car_repo_dir}"; then
			continue
		fi
		
		# Check for mode transition and warn if entity is moving between modes
		car_current_mode=$(get_entity_installed_mode "${car_rule_path}")
		warn_mode_transition "${car_item}" "${car_current_mode}" "${car_mode}"
		
		# Check for downgrade conflicts first
		if ! check_rule_downgrade_conflict "${car_item}" "${car_mode}"; then
			continue  # Skip this rule, conflict detected
		fi
		
		# Handle conflict resolution migration using helper function
		migrate_from_opposite_mode "${car_rule_path}" "${car_mode}" "${car_lazy_init_occurred}"

		# Check if target directory is writable before adding to manifest
		if [ ! -w "${car_target_dir}" ]; then
			show_permission_error "${car_target_dir}" "write to"
		fi
		
		# Add to target manifest
		add_manifest_entry_to_file "${car_manifest_file}" "${car_rule_path}"
		
		echo "Added rule: ${car_rule_path}"
	done
	
	# Sync to update file locations
	sync_all_modes
	
	return 0
}

# Add ruleset(s) to the repository (progressive mode-aware)
#
# Adds entire rulesets to specified mode, handling lazy initialization and
# conflict resolution. Auto-detects mode when only one exists, migrates
# rulesets between modes on conflicts. Rulesets deploy all contained .mdc
# files as individual rules in the target directory.
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   SOURCE_REPO - Source repository URL
#   TARGET_DIR - Target directory for rules
#   REPO_DIR - Repository directory
#
# Arguments:
#   <ruleset>...         - Ruleset names (directory names under rulesets/)
#   [--local|-l]         - Add to local mode (git-ignored)
#   [--commit|-c]        - Add to commit mode (git-tracked)
#
# Outputs:
#   Stdout: Success messages for each added ruleset
#   Stderr: Warning messages for missing rulesets
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
cmd_add_ruleset() {
	cars_mode=""
	cars_rulesets=""
	
	# Parse arguments
	while [ $# -gt 0 ]; do
		case "$1" in
			--local|-l)
				cars_mode="local"
				shift
				;;
			--commit|-c)
				cars_mode="commit"
				shift
				;;
			--global|-g)
				cars_mode="global"
				shift
				;;
			*)
				if [ -z "${cars_rulesets}" ]; then
					cars_rulesets="$1"
				else
					cars_rulesets="${cars_rulesets} $1"
				fi
				shift
				;;
		esac
	done
	
	# Track original mode before any overrides
	cars_original_mode="${cars_mode}"
	
	# Check if any mode is initialized and validate manifest integrity
	ensure_initialized_and_valid

	# Smart mode selection using helper function
	cars_mode=$(select_mode "${cars_mode}")

	# Check if lazy initialization is needed and track it using helper function
	cars_lazy_init_occurred=$(initialize_mode_if_needed "${cars_mode}")

	# Select manifest and target based on mode using helper function
	cars_manifest_and_target=$(get_manifest_and_target "${cars_mode}")
	cars_manifest_file=$(echo "${cars_manifest_and_target}" | cut -f1 -d"	") # Using literal tab as delimiter

	# Get the correct repo dir for this mode (cache isolation)
	cars_repo_dir=$(get_repo_dir_for_mode "${cars_mode}")

	# Process each ruleset
	for cars_ruleset in ${cars_rulesets}; do
		cars_ruleset_path="${RULESETS_PATH}/${cars_ruleset}"
		
		# Check if ruleset exists in the correct source repo for this mode
		if ! check_repository_item "${cars_ruleset_path}" "Ruleset" "dir" "${cars_repo_dir}"; then
			continue
		fi
		
		# Check for mode transition and warn if entity is moving between modes
		cars_current_mode=$(get_entity_installed_mode "${cars_ruleset_path}")
		warn_mode_transition "${cars_ruleset}" "${cars_current_mode}" "${cars_mode}"
		
		# Handle conflict resolution migration using helper function
		migrate_from_opposite_mode "${cars_ruleset_path}" "${cars_mode}" "${cars_lazy_init_occurred}"

		# Add to target manifest
		add_manifest_entry_to_file "${cars_manifest_file}" "${cars_ruleset_path}"
		
		echo "Added ruleset: ${cars_ruleset_path}"
	done
	
	# Sync to update file locations
	sync_all_modes
	
	return 0
}

# Remove rule(s) from the repository (mode-aware)
#
# Removes individual rules from whichever mode contains them. Auto-detects
# which mode has each rule and removes from the appropriate manifest.
# Triggers sync to clean up target directories after removal.
# Uses AI_RIZZ_MODE environment variable to determine which mode to check first
# when both modes are active.
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   SOURCE_REPO - Source repository URL
#   TARGET_DIR - Target directory for rules
#
# Arguments:
#   <rule>...            - Rule names (.mdc extension optional)
#
# Outputs:
#   Stdout: Success messages for each removed rule
#   Stderr: Warning messages for rules not found
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
cmd_remove_rule() {
	# Check if any mode is initialized and validate manifest integrity
	ensure_initialized_and_valid

	# If both modes are active, check if we can use environment variable for mode
	if [ "$(is_mode_active commit)" = "true" ] && [ "$(is_mode_active local)" = "true" ] && [ -n "${AI_RIZZ_MODE}" ]; then
		case "${AI_RIZZ_MODE}" in
			local|commit)
				crr_mode="${AI_RIZZ_MODE}"
				;;
			*)
				# Invalid mode in environment variable - ignore it
				crr_mode=""
				;;
		esac
	else
		crr_mode=""
	fi

	# Process each rule
	for rule in "$@"; do
		# Add .mdc extension if not present
		case "${rule}" in
			*".mdc") 
				crr_item="${rule}"
				;;  
			*) 
				crr_item="${rule}.mdc"
				;;  
		esac
		
		removed=false
		rule_path="${RULES_PATH}/${crr_item}"
		
		# If we have a specific mode from environment variable, only remove from that mode
		if [ -n "${crr_mode}" ]; then
			case "${crr_mode}" in
				local)
					if [ "$(is_mode_active local)" = "true" ]; then
						if read_manifest_entries "$LOCAL_MANIFEST_FILE" | grep -q "^$rule_path$"; then
							remove_manifest_entry_from_file "$LOCAL_MANIFEST_FILE" "$rule_path"
							echo "Removed rule: $rule_path"
							removed=true
						else
							warn "Rule not found in local mode: ${crr_item}"
						fi
					fi
					;;
				commit)
					if [ "$(is_mode_active commit)" = "true" ]; then
						if read_manifest_entries "$COMMIT_MANIFEST_FILE" | grep -q "^$rule_path$"; then
							remove_manifest_entry_from_file "$COMMIT_MANIFEST_FILE" "$rule_path"
							echo "Removed rule: $rule_path"
							removed=true
						else
							warn "Rule not found in commit mode: ${crr_item}"
						fi
					fi
					;;
			esac
		else
			# No specific mode - remove from whichever mode contains it
			if [ "$(is_mode_active local)" = "true" ]; then
				if read_manifest_entries "$LOCAL_MANIFEST_FILE" | grep -q "^$rule_path$"; then
					remove_manifest_entry_from_file "$LOCAL_MANIFEST_FILE" "$rule_path"
					echo "Removed rule: $rule_path"
					removed=true
				fi
			fi
			
			if [ "$(is_mode_active commit)" = "true" ] && [ "$removed" = "false" ]; then
				if read_manifest_entries "$COMMIT_MANIFEST_FILE" | grep -q "^$rule_path$"; then
					remove_manifest_entry_from_file "$COMMIT_MANIFEST_FILE" "$rule_path"
					echo "Removed rule: $rule_path"
					removed=true
				fi
			fi
			
			if [ "$removed" = "false" ]; then
				warn "Rule not found in any mode: ${crr_item}"
			fi
		fi
	done
	
	# Sync to ensure proper cleanup
	sync_all_modes
	
	return 0
}

# Remove ruleset(s) from the repository (mode-aware)
#
# Removes entire rulesets from whichever mode contains them. Auto-detects
# which mode has each ruleset and removes from the appropriate manifest.
# Triggers sync to clean up target directories after removal.
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   SOURCE_REPO - Source repository URL
#   TARGET_DIR - Target directory for rules
#
# Arguments:
#   <ruleset>...         - Ruleset names (directory names under rulesets/)
#
# Outputs:
#   Stdout: Success messages for each removed ruleset
#   Stderr: Warning messages for rulesets not found
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
cmd_remove_ruleset() {
	# Check if any mode is initialized and validate manifest integrity
	ensure_initialized_and_valid

	# Process each ruleset
	for ruleset in "$@"; do
		removed=false
		ruleset_path="${RULESETS_PATH}/$ruleset"
		
		# Remove from whichever mode contains it
		if [ "$(is_mode_active local)" = "true" ]; then
			if read_manifest_entries "$LOCAL_MANIFEST_FILE" | grep -q "^$ruleset_path$"; then
				# Remove commands from local mode
				crr_commands_dir=$(get_commands_target_dir "local")
				remove_ruleset_commands "${ruleset_path}" "${crr_commands_dir}"
				
				remove_manifest_entry_from_file "$LOCAL_MANIFEST_FILE" "$ruleset_path"
				echo "Removed ruleset: $ruleset_path"
				removed=true
			fi
		fi
		
		if [ "$(is_mode_active commit)" = "true" ]; then
			if read_manifest_entries "$COMMIT_MANIFEST_FILE" | grep -q "^$ruleset_path$"; then
				# Remove commands from commit mode
				crr_commands_dir=$(get_commands_target_dir "commit")
				remove_ruleset_commands "${ruleset_path}" "${crr_commands_dir}"
				
				remove_manifest_entry_from_file "$COMMIT_MANIFEST_FILE" "$ruleset_path"
				echo "Removed ruleset: $ruleset_path"
				removed=true
			fi
		fi
		
		if [ "$(is_mode_active global)" = "true" ]; then
			if read_manifest_entries "$GLOBAL_MANIFEST_FILE" | grep -q "^$ruleset_path$"; then
				# Remove commands from global mode
				crr_commands_dir=$(get_commands_target_dir "global")
				remove_ruleset_commands "${ruleset_path}" "${crr_commands_dir}"
				
				remove_manifest_entry_from_file "$GLOBAL_MANIFEST_FILE" "$ruleset_path"
				echo "Removed ruleset: $ruleset_path"
				removed=true
			fi
		fi
		
		if [ "$removed" = "false" ]; then
			warn "Ruleset not found in any mode: $ruleset"
		fi
	done
	
	# Sync to ensure proper cleanup
	sync_all_modes
	
	return 0
}

# Sync all available manifests to their target directories
#
# Orchestrates complete sync process: resolves conflicts using "commit wins"
# policy, syncs both modes if initialized, and handles cleanup on failures.
# Core sync function called by cmd_sync and after rule/ruleset modifications.
#
# Globals:
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   TARGET_DIR - Target directory base path
#   SHARED_DIR - Shared directory name
#   LOCAL_DIR - Local directory name
#
# Arguments:
#   None
#
# Outputs:
#   None (delegates to sync_manifest_to_directory)
#
# Returns:
#   0 always (handles failures internally)
#
sync_all_modes() {
	sync_success=true
	
	# Resolve conflicts first (commit mode wins)
	resolve_conflicts
	
	# Sync commit mode if initialized
	if [ "$(is_mode_active commit)" = "true" ]; then
		# Get manifest file and target directory using helper
		commit_manifest_and_target=$(get_manifest_and_target "commit")
		commit_manifest_file=$(echo "${commit_manifest_and_target}" | cut -f1 -d"	")
		commit_target_dir=$(echo "${commit_manifest_and_target}" | cut -f2 -d"	")
		
		sync_manifest_to_directory "${commit_manifest_file}" "${commit_target_dir}" "commit" || sync_success=false
	fi
	
	# Sync local mode if initialized  
	if [ "$(is_mode_active local)" = "true" ]; then
		# Get manifest file and target directory using helper
		local_manifest_and_target=$(get_manifest_and_target "local")
		local_manifest_file=$(echo "${local_manifest_and_target}" | cut -f1 -d"	")
		local_target_dir=$(echo "${local_manifest_and_target}" | cut -f2 -d"	")
		
		sync_manifest_to_directory "${local_manifest_file}" "${local_target_dir}" "local" || sync_success=false
	fi
	
	# Sync global mode if initialized
	if [ "$(is_mode_active global)" = "true" ]; then
		# Get manifest file and target directory using helper
		global_manifest_and_target=$(get_manifest_and_target "global")
		global_manifest_file=$(echo "${global_manifest_and_target}" | cut -f1 -d"	")
		global_target_dir=$(echo "${global_manifest_and_target}" | cut -f2 -d"	")
		
		sync_manifest_to_directory "${global_manifest_file}" "${global_target_dir}" "global" || sync_success=false
	fi
	
	# Handle any cleanup needed
	if [ "$sync_success" = "false" ]; then
		handle_sync_cleanup
	fi
}

# Sync a single manifest to its target directory
#
# Clears target directory of .mdc files and repopulates from manifest entries.
# Uses safety checks to only operate in managed directories. Handles external
# manifest corruption gracefully.
#
# Globals:
#   LOCAL_DIR - Local directory name (for safety check)
#   SHARED_DIR - Shared directory name (for safety check)
#
# Arguments:
#   $1 - Manifest file path
#   $2 - Target directory path
#
# Outputs:
#   Stderr: Warning messages for failures
#
# Returns:
#   0 on success
#   1 on failure (unrecognized directory, read errors)
#
sync_manifest_to_directory() {
	smtd_manifest_file="${1}"
	smtd_target_directory="${2}"
	smtd_mode="${3:-}"  # Optional mode parameter
	
	if [ ! -f "${smtd_manifest_file}" ]; then
		return 0  # No manifest to sync
	fi
	
	# Ensure global paths are current
	init_global_paths
	
	# Create target directory if needed
	mkdir -p "${smtd_target_directory}"
	
	# Determine mode from target directory if not provided
	if [ -z "${smtd_mode}" ]; then
		case "${smtd_target_directory}" in
			*/"${LOCAL_DIR}"|*/"${LOCAL_DIR}/"*)
				smtd_mode="local"
				;;
			*/"${SHARED_DIR}"|*/"${SHARED_DIR}/"*)
				smtd_mode="commit"
				;;
			"${GLOBAL_RULES_DIR}"|"${GLOBAL_RULES_DIR}/"*)
				smtd_mode="global"
				;;
		esac
	fi
	
	# Safety check: Only operate in our managed directories (local, shared, or global)
	case "${smtd_target_directory}" in
		*/"${LOCAL_DIR}"|*/"${SHARED_DIR}"|"${GLOBAL_RULES_DIR}")
			# Clear existing .mdc files to ensure removed rules are deleted
			# Only delete regular .mdc files, never directories or other files
			# Even if symlinks were used in a ruleset, we only EVER get regular files in the rules dir
			find "${smtd_target_directory}" -name "*.mdc" -type f -delete 2>/dev/null || true
			;;
		*)
			warn "Refusing to clear unrecognized target directory: ${smtd_target_directory}"
			return 1
			;;
	esac
	
	# Get entries from manifest (handle external modifications gracefully)
	if ! smtd_entries=$(read_manifest_entries "${smtd_manifest_file}"); then
		warn "Failed to read entries from ${smtd_manifest_file} (possibly corrupted by external changes)"
		return 1
	fi
	
	# Copy each entry (avoid subshell to ensure error propagation)
	if [ -n "${smtd_entries}" ]; then
		# Use a temporary file to avoid subshell issues with pipes
		smtd_temp_file=$(mktemp)
		echo "${smtd_entries}" > "${smtd_temp_file}"
		
		while IFS= read -r smtd_entry; do
			if [ -n "${smtd_entry}" ]; then
				# Continue with other entries even if one fails (resilient to external modifications)
				copy_entry_to_target "${smtd_entry}" "${smtd_target_directory}" "${smtd_mode}" || true
			fi
		done < "${smtd_temp_file}"
		
		rm -f "${smtd_temp_file}"
	fi
}

# Check if a filename would be deployed by commit mode
#
# Used by conflict resolution to implement "commit wins" policy. Checks if
# commit mode would deploy a file with the given name, considering both
# individual rules and files within rulesets.
#
# Globals:
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#
# Arguments:
#   $1 - Filename to check (just basename, not full path)
#
# Outputs:
#   None
#
# Returns:
#   0 if file would be deployed by commit mode
#   1 otherwise
#
file_exists_in_commit_mode() {
	fecm_filename="${1}"
	
	if [ "$(is_mode_active commit)" = "false" ] || [ ! -f "${COMMIT_MANIFEST_FILE}" ]; then
		return 1  # No commit mode, so no conflict
	fi
	
	# Check if commit mode would deploy this filename
	fecm_commit_files=$(get_files_from_manifest "${COMMIT_MANIFEST_FILE}" 2>/dev/null || true)
	if [ -n "${fecm_commit_files}" ]; then
		echo "${fecm_commit_files}" | grep -q "^${fecm_filename}$"
		return $?
	fi
	
	return 1  # Not found in commit mode
}

# Copy command files from ruleset to target commands directory
#
# Copies all files from a ruleset's `commands/` subdirectory to the target
# `.cursor/commands/` directory. Follows symlinks to copy actual source content,
# not the symlink itself. Creates target directory if it doesn't exist.
#
# Globals:
#   REPO_DIR - Repository directory
#
# Arguments:
#   $1 - Ruleset path in source repo (e.g., `rulesets/memory-bank`) (required)
#   $2 - Target commands directory (e.g., `.cursor/commands`) (required)
#
# Outputs:
#   Stderr: Warning messages on failure
#
# Returns:
#   0 on success
#   1 on failure (source doesn't exist, copy failed)
#
copy_ruleset_commands() {
	crc_ruleset_path="${1}"
	crc_target_commands_dir="${2}"
	
	crc_source_commands_dir="${REPO_DIR}/${crc_ruleset_path}/commands"
	
	# Check if source commands directory exists
	if [ ! -d "${crc_source_commands_dir}" ]; then
		return 0  # No commands to copy, not an error
	fi
	
	# Create target directory if it doesn't exist
	mkdir -p "${crc_target_commands_dir}" || {
		warn "Failed to create commands directory: ${crc_target_commands_dir}"
		return 1
	}
	
	# Copy all files from commands directory recursively, following symlinks
	# Use find to get all files (not directories) at any depth and copy them
	# Preserve directory structure when copying
	# Use temporary file to avoid subshell exit code issues (per POSIX style guide)
	crc_temp_file=$(mktemp)
	find "${crc_source_commands_dir}" -mindepth 1 \( -type f -o -type l \) > "${crc_temp_file}" 2>/dev/null
	crc_find_status=$?
	
	if [ ${crc_find_status} -eq 0 ]; then
		while IFS= read -r crc_source_file; do
			if [ -n "${crc_source_file}" ] && ([ -f "${crc_source_file}" ] || [ -L "${crc_source_file}" ]); then
				# Calculate relative path from commands directory to preserve structure
				crc_rel_path="${crc_source_file#${crc_source_commands_dir}/}"
				crc_target_file="${crc_target_commands_dir}/${crc_rel_path}"
				
				# Create target directory structure if needed
				crc_target_dir=$(dirname "${crc_target_file}")
				if [ ! -d "${crc_target_dir}" ]; then
					if ! mkdir -p "${crc_target_dir}"; then
						warn "Failed to create directory for: ${crc_rel_path}"
						continue
					fi
				fi
				
				# Security: Validate symlink targets before copying
				if [ -L "${crc_source_file}" ]; then
					crc_resolved_target=$(_readlink_f "${crc_source_file}")
					if [ -z "${crc_resolved_target}" ]; then
						warn "Failed to resolve symlink: ${crc_rel_path}"
						continue
					fi
					# Check if resolved target is within REPO_DIR
					case "${crc_resolved_target}" in
						"${REPO_DIR}"/*)
							# Symlink points within repository, safe to copy
							;;
						*)
							# Symlink points outside repository, skip for security
							warn "Skipping symlink pointing outside repository: ${crc_rel_path} -> ${crc_resolved_target}"
							continue
							;;
					esac
				fi
				
				# Use cp -L to follow symlinks and copy actual source content
				if ! cp -L "${crc_source_file}" "${crc_target_file}"; then
					warn "Failed to copy command file: ${crc_rel_path}"
					# Continue with other files
				fi
			fi
		done < "${crc_temp_file}"
	fi
	
	rm -f "${crc_temp_file}"
	return 0
}

# Remove commands from a ruleset when the ruleset is removed
#
# Removes all command files that were copied from the specified ruleset's
# commands/ subdirectory. Preserves directory structure when removing nested
# commands. Cleans up empty directories after file removal.
#
# Globals:
#   REPO_DIR - Source repository directory
#
# Arguments:
#   $1 - Ruleset path (e.g., "rulesets/test-ruleset")
#   $2 - Target commands directory (e.g., "/path/to/commands")
#
# Outputs:
#   Stderr: Warning messages for failures
#
# Returns:
#   0 on success
#   1 on failure (source doesn't exist, removal failed)
#
remove_ruleset_commands() {
	rrc_ruleset_path="${1}"
	rrc_target_commands_dir="${2}"
	
	rrc_source_commands_dir="${REPO_DIR}/${rrc_ruleset_path}/commands"
	
	# Check if source commands directory exists
	if [ ! -d "${rrc_source_commands_dir}" ]; then
		return 0  # No commands to remove, not an error
	fi
	
	# Check if target commands directory exists
	if [ ! -d "${rrc_target_commands_dir}" ]; then
		return 0  # No commands directory, nothing to remove
	fi
	
	# Get all command paths from the ruleset's commands directory
	# Use temporary file to avoid subshell exit code issues (per POSIX style guide)
	rrc_temp_file=$(mktemp)
	find "${rrc_source_commands_dir}" -mindepth 1 \( -type f -o -type l \) > "${rrc_temp_file}" 2>/dev/null
	rrc_find_status=$?
	
	if [ ${rrc_find_status} -eq 0 ]; then
		while IFS= read -r rrc_source_file; do
			if [ -n "${rrc_source_file}" ] && ([ -f "${rrc_source_file}" ] || [ -L "${rrc_source_file}" ]); then
				# Calculate relative path from commands directory to match target structure
				rrc_rel_path="${rrc_source_file#${rrc_source_commands_dir}/}"
				rrc_target_file="${rrc_target_commands_dir}/${rrc_rel_path}"
				
				# Remove the target file if it exists
				if [ -f "${rrc_target_file}" ] || [ -L "${rrc_target_file}" ]; then
					if ! rm -f "${rrc_target_file}"; then
						warn "Failed to remove command file: ${rrc_rel_path}"
						# Continue with other files
					fi
					
					# Clean up empty parent directories
					rrc_target_dir=$(dirname "${rrc_target_file}")
					while [ "${rrc_target_dir}" != "${rrc_target_commands_dir}" ] && [ -d "${rrc_target_dir}" ]; do
						# Check if directory is empty (only . and .. entries)
						if [ -z "$(find "${rrc_target_dir}" -mindepth 1 -maxdepth 1 2>/dev/null)" ]; then
							rmdir "${rrc_target_dir}" 2>/dev/null || break
							rrc_target_dir=$(dirname "${rrc_target_dir}")
						else
							break
						fi
					done
				fi
			fi
		done < "${rrc_temp_file}"
	fi
	
	rm -f "${rrc_temp_file}"
	return 0
}

# Copy a single entry (rule or ruleset) to target directory
#
# Handles both individual rules (single file copy) and rulesets (copy all
# .mdc files from directory). Routes commands (*.md) to commands directory.
# Implements conflict resolution by skipping files that would conflict with
# commit mode when syncing to local directory.
# Follows symlinks to copy actual content, not the links themselves.
#
# Globals:
#   REPO_DIR - Repository directory
#   LOCAL_DIR - Local directory name (for conflict detection)
#
# Arguments:
#   $1 - Entry path (relative to repository root)
#   $2 - Target directory path (rules directory)
#   $3 - Mode (optional: "local", "commit", or "global" for command routing)
#
# Outputs:
#   Stderr: Warning messages for missing entries
#
# Returns:
#   0 on success
#   1 if entry not found in repository
#
copy_entry_to_target() {
	cett_entry="${1}"
	cett_target_directory="${2}"
	cett_mode="${3:-}"
	
	cett_source_path="${REPO_DIR}/${cett_entry}"
	
	# Determine mode from target directory if not provided
	if [ -z "${cett_mode}" ]; then
		case "${cett_target_directory}" in
			*/"${LOCAL_DIR}"|*/"${LOCAL_DIR}/"*)
				cett_mode="local"
				;;
			*/"${SHARED_DIR}"|*/"${SHARED_DIR}/"*)
				cett_mode="commit"
				;;
			"${GLOBAL_RULES_DIR}"|"${GLOBAL_RULES_DIR}/"*)
				cett_mode="global"
				;;
		esac
	fi
	
	# Check if we're syncing to local directory and need to avoid commit conflicts
	cett_is_local_sync=false
	case "${cett_target_directory}" in
		*/"${LOCAL_DIR}")
			cett_is_local_sync=true
			;;
	esac
	
	if [ -f "${cett_source_path}" ]; then
		# Single file (rule or command)
		cett_filename=$(basename "${cett_source_path}")
		
		# Skip if file would conflict with commit mode (commit wins)
		if [ "${cett_is_local_sync}" = "true" ] && file_exists_in_commit_mode "${cett_filename}"; then
			return 0  # Skip this file
		fi
		
		# Check if this is a command (*.md) and route to commands directory
		if [ "$(is_command "${cett_filename}")" = "true" ] && [ -n "${cett_mode}" ]; then
			cett_commands_target=$(get_commands_target_dir "${cett_mode}")
			mkdir -p "${cett_commands_target}"
			cp "${cett_source_path}" "${cett_commands_target}/"
		else
			cp "${cett_source_path}" "${cett_target_directory}/"
		fi
	elif [ -d "${cett_source_path}" ]; then
		# Directory (ruleset) - copy individual .mdc files from ruleset to target directory
		# Handle symlinks and files differently:
		# - Symlinks: Copy flat (all instances are the same rule)
		# - Files: Preserve directory structure (URI is ruleset/path/to/rule.mdc)
		# Use temporary file to avoid subshell exit code issues (per POSIX style guide)
		cett_temp_file=$(mktemp)
		find "${cett_source_path}" -name "*.mdc" \( -type f -o -type l \) > "${cett_temp_file}" 2>/dev/null
		cett_find_status=$?
		
		if [ ${cett_find_status} -eq 0 ]; then
			while IFS= read -r cett_rule_file; do
				if [ -n "${cett_rule_file}" ] && ([ -f "${cett_rule_file}" ] || [ -L "${cett_rule_file}" ]); then
					cett_filename=$(basename "${cett_rule_file}")
					
					# Skip if file would conflict with commit mode (commit wins)
					if [ "${cett_is_local_sync}" = "true" ] && file_exists_in_commit_mode "${cett_filename}"; then
						continue
					fi
					
					# Detect if this is a symlink or a file
					if [ -L "${cett_rule_file}" ]; then
						# Security: Validate symlink target before copying
						cett_resolved_target=$(_readlink_f "${cett_rule_file}")
						if [ -z "${cett_resolved_target}" ]; then
							warn "Failed to resolve symlink: ${cett_rule_file}"
							continue
						fi
						# Check if resolved target is within REPO_DIR
						case "${cett_resolved_target}" in
							"${REPO_DIR}"/*)
								# Symlink points within repository, safe to copy
								# Symlink: Copy flat to target root (all instances are the same rule)
								if ! cp -L "${cett_rule_file}" "${cett_target_directory}/"; then
									warn "Failed to copy symlink: ${cett_filename}"
								fi
								;;
							*)
								# Symlink points outside repository, skip for security
								warn "Skipping symlink pointing outside repository: ${cett_filename} -> ${cett_resolved_target}"
								continue
								;;
						esac
					else
						# File: Preserve directory structure (URI is ruleset/path/to/rule.mdc)
						cett_rel_path="${cett_rule_file#${cett_source_path}/}"
						cett_target_file="${cett_target_directory}/${cett_rel_path}"
						
						# Create target directory structure if needed
						cett_target_dir=$(dirname "${cett_target_file}")
						if [ ! -d "${cett_target_dir}" ]; then
							if ! mkdir -p "${cett_target_dir}"; then
								warn "Failed to create directory for: ${cett_rel_path}"
								continue
							fi
						fi
						
						# Copy the file (preserving structure)
						if ! cp "${cett_rule_file}" "${cett_target_file}"; then
							warn "Failed to copy rule file: ${cett_rel_path}"
						fi
					fi
				fi
			done < "${cett_temp_file}"
		fi
		
		rm -f "${cett_temp_file}"
		
		# Copy commands/ subdirectory if exists - works in all modes now
		if [ -n "${cett_mode}" ]; then
			cett_commands_dir=$(get_commands_target_dir "${cett_mode}")
			copy_ruleset_commands "${cett_entry}" "${cett_commands_dir}"
		fi
	else
		warn "Entry not found in repository: ${cett_entry}"
		return 1
	fi
}

# Handle cleanup after sync issues
#
# Performs recovery actions when sync operations fail. Re-caches manifest
# metadata to ensure consistency and validates git exclude state to detect
# manual modifications that might cause issues.
#
# Globals:
#   None (delegates to other functions)
#
# Arguments:
#   None
#
# Outputs:
#   Stderr: Warning messages from validation functions
#
# Returns:
#   0 always
#
handle_sync_cleanup() {
	# Re-cache manifest metadata to ensure consistency
	cache_manifest_metadata
	
	# Validate git exclude state
	hsc_target_dir=$(get_target_directory)
	validate_git_exclude_state "${hsc_target_dir}"
}

# Sync the repository (multi-mode aware)
#
# Updates source repository cache and syncs all manifests to target directories.
# Resolves conflicts using "commit wins" policy, handles network failures
# gracefully, and ensures target directories match manifest contents.
#
# Globals:
#   SOURCE_REPO - Source repository URL
#
# Arguments:
#   None
#
# Outputs:
#   Stdout: Success message
#   Stderr: Warning messages for network failures
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
cmd_sync() {
	# Check if any mode is initialized and validate manifest integrity
	ensure_initialized_and_valid

	# Use unified SOURCE_REPO variable directly
	cs_source_repo="${SOURCE_REPO}"
	
	# Sync repository first
	if [ -n "${cs_source_repo}" ]; then
		if ! git_sync "${cs_source_repo}"; then
			# git_sync already issued a warning, fail the sync operation
			return 1
		fi
	fi
	
	# Sync all initialized modes
	sync_all_modes
	
	echo "Sync complete"
	return 0
}



# Display help information
#
# Shows usage information for all commands and their options.
#
# Globals:
#   None
#
# Arguments:
#   None
#
# Outputs:
#   Stdout: Help text with command usage and options
#
# Returns:
#   0 always
#
cmd_help() {
  cat <<EOF
Usage: ai-rizz <command> [command-specific options]

Available commands:
  init [<source_repo>]     Initialize the repository
  deinit                   Deinitialize the repository
  list                     List available rules and rulesets
  add rule <rule>...       Add rule(s) to the repository
  add ruleset <ruleset>... Add ruleset(s) to the repository
  remove rule <rule>...    Remove rule(s) from the repository
  remove ruleset <ruleset>... Remove ruleset(s) from the repository
  sync                     Sync the rules
  help                     Show this help

General options:
  -f, --manifest <file>  Alias for --skibidi
  -s, --skibidi <file>   Use custom manifest filename

Mode options (available for init, add, remove, deinit):
  -c, --commit           Use commit mode (git-tracked, shared with team)
  -l, --local            Use local mode (git-ignored, personal)
  -g, --global           Use global mode (user-wide, ~/.cursor/)

Command-specific options:
  init options:
    -d <target_dir>        Target directory
    --hook-based-ignore    local mode: use pre-commit hook instead of .git/info/exclude
                           (ensures files visible, leaves "dirty" git status)
    --rule-path <path>     Source repository rules path
    --ruleset-path <path>  Source repository rulesets path

  deinit options:
    -y                     Skip confirmation prompts

Modes:
  commit  Rules are git-tracked and shared with other developers.
  local   Rules are git-ignored and only available to you in this repo.
  global  Rules are stored in ~/.cursor/ and available in all repositories.
          Global mode can be used outside of git repositories.

Glyphs in 'list' output:
  ●  Committed (git-tracked in this repository)
  ◐  Local (git-ignored in this repository)
  ★  Global (user-wide, available everywhere)
  ○  Not installed
EOF
  return 0
}

# Initialization
# ==============

# Initialize ai-rizz state at startup (two-phase to avoid circular dependencies)
#
# Bootstraps ai-rizz state in careful order to avoid circular dependencies.
# Sets up default paths and caches manifest metadata for the current project.
# Called once at script startup.
#
# Globals:
#   RULES_PATH - Set to default rules path
#   RULESETS_PATH - Set to default rulesets path
#   REPO_DIR - Set to the repository directory for current project
#   SOURCE_REPO - Set during cache_manifest_metadata
#   TARGET_DIR - Set during cache_manifest_metadata
#
# Arguments:
#   None
#
# Outputs:
#   None (delegates to detection functions)
#
# Returns:
#   0 always
#
initialize_ai_rizz() {
	# Initialize paths to defaults
	RULES_PATH="${DEFAULT_RULES_PATH}"
	RULESETS_PATH="${DEFAULT_RULESETS_PATH}"
	
	# Full initialization with directory checking  
	cache_manifest_metadata
	
	# Set repository directory for current project
	REPO_DIR=$(get_repo_dir)
}

# Parse manifest filename argument and determine root and local names
#
# Detects if the provided filename is a local manifest name (contains .local)
# and derives the appropriate root and local manifest filenames.
#
# Arguments:
#   $1 - Manifest filename provided by user
#
# Outputs:
#   Stdout: Tab-separated "root_filename<TAB>local_filename"
#
# Returns:
#   0 always
#
parse_manifest_filename_argument() {
	pmfa_input="$1"
	
	# Check if input contains .local. pattern or ends with .local
	case "$pmfa_input" in
		*.local.*)
			# Pattern: foo.local.bar -> root: foo.bar, local: foo.local.bar
			pmfa_root="${pmfa_input%.local.*}.${pmfa_input##*.local.}"
			pmfa_local="$pmfa_input"
			;;
		*.local)
			# Pattern: Gyattfile.local -> root: Gyattfile, local: Gyattfile.local
			pmfa_root="${pmfa_input%.local}"
			pmfa_local="$pmfa_input"
			;;
		*)
			# Not a local manifest - treat as root and derive local filename
			pmfa_root="$pmfa_input"
			# Inline derivation logic: add .local before extension or at end
			case "$pmfa_input" in
				*.*) 
					pmfa_local="${pmfa_input%.*}.local.${pmfa_input##*.}"
					;;
				*)
					pmfa_local="$pmfa_input.local"
					;;
			esac
			;;
	esac
	
	# Use printf to ensure literal tab is used
	printf "%s\t%s\n" "${pmfa_root}" "${pmfa_local}"
}

# Main
# ====

# Only run main code if script is executed, not sourced
if [ "${0##*/}" = "ai-rizz" ]; then
	# Check if no arguments provided
	if [ $# -eq 0 ]; then
		cmd_help
		exit 0
	fi
	
	# Process manifest options first - no subshell to preserve variable updates
	PROCESSED_ARGS=""

	# Check for environment variable fallback for manifest
	if [ -n "${AI_RIZZ_MANIFEST}" ]; then
		manifest_names=$(parse_manifest_filename_argument "${AI_RIZZ_MANIFEST}")
		COMMIT_MANIFEST_FILE=$(echo "$manifest_names" | cut -f1 -d"	")
		LOCAL_MANIFEST_FILE=$(echo "$manifest_names" | cut -f2 -d"	")
	fi
	
	while [ $# -gt 0 ]; do
		case "$1" in
			-s|--skibidi|-f|--manifest)
				if [ $# -lt 2 ]; then
					error "Missing filename for $1 option"
				fi
				# Parse the provided filename to determine root and local names
				manifest_names=$(parse_manifest_filename_argument "$2")
				
				COMMIT_MANIFEST_FILE=$(echo "$manifest_names" | cut -f1 -d"	")
				LOCAL_MANIFEST_FILE=$(echo "$manifest_names" | cut -f2 -d"	")
				shift 2
				;;
			*)
				# Preserve the argument
				if [ -z "$PROCESSED_ARGS" ]; then
					PROCESSED_ARGS="$1"
				else
					PROCESSED_ARGS="$PROCESSED_ARGS $1"
				fi
				shift
				;;
		esac
	done

	# Set the processed arguments back for command processing
	# shellcheck disable=SC2086 # Intentional word splitting to restore original argument structure
	set -- $PROCESSED_ARGS
	
	# Initialize ai-rizz state for production use
	initialize_ai_rizz
	
	# Parse command
	main_command=$1
	shift

	case "${main_command}" in
	init)
		cmd_init "$@"
		;;
	deinit)
		cmd_deinit "$@"
		;;
	list)
		cmd_list "$@"
		;;
	add)
		if [ $# -eq 0 ]; then
			show_command_usage_error "Missing type: 'rule' or 'ruleset'" "ai-rizz add rule example-rule"
		fi
		
		main_type=$1
		shift
		
		case "${main_type}" in
			rule)
				if [ $# -eq 0 ]; then
					show_command_usage_error "Missing rule name" "ai-rizz add rule example-rule [--local|--commit]"
				fi
				cmd_add_rule "$@"
				;;
			ruleset)
				if [ $# -eq 0 ]; then
					show_command_usage_error "Missing ruleset name" "ai-rizz add ruleset example-ruleset [--local|--commit]"
				fi
				cmd_add_ruleset "$@"
				;;
			*)
				show_command_usage_error "Invalid type: ${main_type}. Must be 'rule' or 'ruleset'" "ai-rizz add rule example-rule\nai-rizz add ruleset example-ruleset"
				;;
		esac
		;;
	remove)
		if [ $# -eq 0 ]; then
			show_command_usage_error "Missing type: 'rule' or 'ruleset'" "ai-rizz remove rule example-rule"
		fi
		
		main_type=$1
		shift
		
		case "${main_type}" in
			rule)
				if [ $# -eq 0 ]; then
					 show_command_usage_error "Missing rule name" "ai-rizz remove rule example-rule"
				fi
				cmd_remove_rule "$@"
				;;
			ruleset)
				if [ $# -eq 0 ]; then
					show_command_usage_error "Missing ruleset name" "ai-rizz remove ruleset example-ruleset"
				fi
				cmd_remove_ruleset "$@"
				;;
			*)
				show_command_usage_error "Invalid type: ${main_type}. Must be 'rule' or 'ruleset'" "ai-rizz remove rule example-rule\nai-rizz remove ruleset example-ruleset"
				;;
		esac
		;;
	sync)
		cmd_sync "$@"
		;;
	help|--help|-h)
		cmd_help "$@"
		;;
	*)
		show_command_usage_error "Unknown command: ${main_command}" "ai-rizz init https://github.com/user/rules.git --local"
		;;
	esac
fi
