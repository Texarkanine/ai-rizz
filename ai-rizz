#!/bin/sh
#
# ai-rizz - A CLI tool to manage Cursor rules and rulesets
# Supports progressive initialization with local and commit modes
#
# Usage: ai-rizz <command> [options]
# 
# Copyright 2024 ai-rizz project
# POSIX-compliant shell script for maximum portability
#
# Variable Consolidation:
# This script has completed the transition from mode-specific repository variables
# (LOCAL_SOURCE_REPO/COMMIT_SOURCE_REPO and LOCAL_TARGET_DIR/COMMIT_TARGET_DIR)
# to unified variables (SOURCE_REPO and TARGET_DIR).
#
# The unified variables are set in these functions:
# - parse_manifest_metadata(): Sets SOURCE_REPO and TARGET_DIR from manifest metadata
# - lazy_init_mode(): Sets SOURCE_REPO and TARGET_DIR during lazy initialization
# - cmd_init(): Sets SOURCE_REPO and TARGET_DIR during explicit initialization
#
# This consolidation follows the pattern already established with RULES_PATH
# and RULESETS_PATH, creating a more consistent variable handling strategy.

set -e  # Exit on error

# Configuration constants
COMMIT_MANIFEST_FILE="ai-rizz.skbd"                 # Changed from ai-rizz.inf
LOCAL_MANIFEST_FILE="ai-rizz.local.skbd"            # Changed from ai-rizz.local.inf
SHARED_DIR="shared"
LOCAL_DIR="local" 
CONFIG_DIR="$HOME/.config/ai-rizz"
DEFAULT_TARGET_DIR=".cursor/rules"
DEFAULT_RULES_PATH="rules"                          # Added for default rules path
DEFAULT_RULESETS_PATH="rulesets"                    # Added for default rulesets path

# Source repository information (set during initialization)
SOURCE_REPO=""      # Source repository URL
TARGET_DIR=""       # Target directory for rules

# Repository directory (set during initialization)
REPO_DIR=""

# Source repository paths (set during initialization, identical across modes)
RULES_PATH=""                                       # Rules path from manifest
RULESETS_PATH=""                                    # Rulesets path from manifest

# Display formatting variables  
COMMITTED_GLYPH="●"
LOCAL_GLYPH="◐"
UNINSTALLED_GLYPH="○"

# Utilities
# =========

# Get repository directory for the current project
#
# Globals:
#   CONFIG_DIR - Base configuration directory path
#
# Arguments:
#   None
#
# Outputs:
#   Stdout: Repository directory path for current project
#
# Returns:
#   0 on success
#
get_repo_dir() {
	# Use git root directory name as project name, fallback to current directory
	if grd_git_root=$(git rev-parse --show-toplevel 2>/dev/null); then
		grd_project_name=$(basename "${grd_git_root}")
	else
		grd_project_name=$(basename "$(pwd)")
	fi
	echo "${CONFIG_DIR}/repos/${grd_project_name}/repo"
}

# Print error message to stderr and exit with specified code
#
# Globals:
#   None
#
# Arguments:
#   $1 - Error message to display (required)
#   $2 - Exit code (optional, defaults to 1)
#
# Outputs:
#   Stderr: Error message prefixed with "Error: "
#
# Returns:
#   Never returns (exits with specified code)
#
error() {
  echo "Error: ${1}" >&2
  exit "${2:-1}"
}

# Print warning message to stderr
#
# Globals:
#   None
#
# Arguments:
#   $1 - Warning message to display (required)
#
# Outputs:
#   Stderr: Warning message prefixed with "Warning: "
#
# Returns:
#   0 on success
#
warn() {
  echo "Warning: ${1}" >&2
}

# Show command usage error with example and exit
#
# Displays a user-friendly error message for command usage errors
# with an example of correct usage to guide the user
#
# Globals:
#   None
#
# Arguments:
#   $1 - Error message to display (required)
#   $2 - Command example to show (required)
#   $3 - Exit code (optional, defaults to 1)
#
# Outputs:
#   Stderr: Formatted error message with usage example
#
# Returns:
#   Never returns (exits with specified code)
#
show_command_usage_error() {
  cat >&2 << EOF
Error: ${1}

Example usage:
  ${2}

Run 'ai-rizz help' for full documentation of available commands.
EOF
  exit "${3:-1}"
}

# Show file permission error with potential solutions
#
# Displays a user-friendly error message for file permission issues
# with specific guidance on how to resolve the problem
#
# Globals:
#   None
#
# Arguments:
#   $1 - Path that has permission issues (required)
#   $2 - Operation that failed (e.g., "write to", "read from") (required)
#   $3 - Exit code (optional, defaults to 1)
#
# Outputs:
#   Stderr: Formatted error message with resolution steps
#
# Returns:
#   Never returns (exits with specified code)
#
show_permission_error() {
  cat >&2 << EOF
Error: Cannot ${2} ${1} (permission denied)

Possible solutions:
  1. Check ownership: ls -la ${1}
  2. Fix permissions: chmod u+rw ${1}
  3. Use a different location with sufficient permissions
EOF
  exit "${3:-1}"
}

# Show repository error with troubleshooting steps
#
# Displays a user-friendly error message for repository access issues
# with specific guidance on how to resolve common problems
#
# Globals:
#   None
#
# Arguments:
#   $1 - Repository URL with issue (required)
#   $2 - Exit code (optional, defaults to 1)
#
# Outputs:
#   Stderr: Formatted error message with troubleshooting steps
#
# Returns:
#   Never returns (exits with specified code)
#
show_repository_error() {
  cat >&2 << EOF
Error: Failed to access repository: ${1}

Possible issues:
  1. Network connection problem
  2. Repository URL is incorrect
  3. Repository requires authentication
  4. Repository no longer exists

Troubleshooting:
  • Verify network connection: ping github.com
  • Check URL manually: git ls-remote ${1}
  • Try with explicit protocol: https://github.com/user/repo.git
EOF
  exit "${2:-1}"
}

# Show initialization error with setup instructions
#
# Displays a user-friendly error message when ai-rizz is not initialized
# with specific instructions on how to initialize it
#
# Globals:
#   None
#
# Arguments:
#   $1 - Exit code (optional, defaults to 1)
#
# Outputs:
#   Stderr: Formatted error message with initialization instructions
#
# Returns:
#   Never returns (exits with specified code)
#
show_initialization_error() {
  cat >&2 << EOF
Error: No ai-rizz configuration found. Run 'ai-rizz init' first.

You need to initialize ai-rizz with one of these commands:

  ai-rizz init <repository-url>                     # Interactive initialization
  ai-rizz init <repository-url> --local             # Local mode (git-ignored)
  ai-rizz init <repository-url> --commit            # Commit mode (git-tracked)
  ai-rizz init <repository-url> -d <target-dir>     # Custom target directory

Example:
  ai-rizz init https://github.com/texarkanine/.cursor-rules.git --local
EOF
  exit "${1:-1}"
}

# Show mode selection error with guidance
#
# Displays a user-friendly error message when mode selection is ambiguous
# with clear instructions on how to specify the desired mode
#
# Globals:
#   None
#
# Arguments:
#   $1 - Command being used (e.g., "add rule", "add ruleset") (required)
#   $2 - Exit code (optional, defaults to 1)
#
# Outputs:
#   Stderr: Formatted error message with mode selection instructions
#
# Returns:
#   Never returns (exits with specified code)
#
show_mode_selection_error() {
  cat >&2 << EOF
Error: Both modes available. Please specify which mode to use.

To specify mode:
  ai-rizz ${1} --local     # Use local mode (git-ignored)
  ai-rizz ${1} --commit    # Use commit mode (git-tracked)

For more information on modes, run: ai-rizz help
EOF
  exit "${2:-1}"
}

# Show invalid mode error with guidance
#
# Displays a user-friendly error message when an invalid mode is specified
# with clear instructions on valid mode options
#
# Globals:
#   None
#
# Arguments:
#   $1 - Invalid mode that was provided (required)
#   $2 - Exit code (optional, defaults to 1)
#
# Outputs:
#   Stderr: Formatted error message with valid mode options
#
# Returns:
#   Never returns (exits with specified code)
#
show_invalid_mode_error() {
  cat >&2 << EOF
Error: Invalid mode: '${1}'

Valid modes are:
  --local, -l     Local mode (git-ignored)
  --commit, -c    Commit mode (git-tracked)

Example usage:
  ai-rizz add rule example-rule --local
EOF
  exit "${2:-1}"
}

# Show git repository context error with setup instructions
#
# Displays a user-friendly error message when ai-rizz is not run in a git repository
# with instructions on how to set up a git repository
#
# Globals:
#   None
#
# Arguments:
#   $1 - Exit code (optional, defaults to 1)
#
# Outputs:
#   Stderr: Formatted error message with git setup instructions
#
# Returns:
#   Never returns (exits with specified code)
#
show_git_context_error() {
  cat >&2 << EOF
Error: Not in a git repository.

ai-rizz must be run inside a git repository. To set up a new git repository:

  mkdir myproject
  cd myproject
  git init
  ai-rizz init <repository-url>

Or initialize git in the current directory:

  git init
  ai-rizz init <repository-url>
EOF
  exit "${1:-1}"
}

# Progressive Manifest Utilities  
# ==============================

# Read manifest metadata line from specified file
#
# Globals:
#   None
#
# Arguments:
#   $1 - Path to manifest file (required)
#
# Outputs:
#   Stdout: Tab-separated "source_repo\ttarget_dir" line
#   Stderr: Error message if invalid format
#
# Returns:
#   0 on success
#   1 if file doesn't exist or on error (via error() function)
#
read_manifest_metadata() {
	rmm_manifest_file="${1}"
	
	if [ ! -f "${rmm_manifest_file}" ]; then
		return 1
	fi
	
	# Read first line
	read -r rmm_first_line < "${rmm_manifest_file}"
	
	# Validate format
	if ! echo "${rmm_first_line}" | grep -q "	"; then
		error "Invalid manifest format in ${rmm_manifest_file}: First line must be 'source_repo<tab>target_dir'"
	fi
	
	echo "${rmm_first_line}"
}

# Read manifest entries from specified file
#
# Globals:
#   None
#
# Arguments:
#   $1 - Path to manifest file (required)
#
# Outputs:
#   Stdout: Manifest entries, one per line (excluding metadata line)
#
# Returns:
#   0 on success (including empty manifests)
#   1 if file doesn't exist
#
read_manifest_entries() {
	rme_manifest_file="${1}"
	
	if [ ! -f "${rme_manifest_file}" ]; then
		return 1
	fi
	
	# Skip first line (metadata), return rest (handle empty manifests gracefully)
	tail -n +2 "${rme_manifest_file}" | grep -v '^$' || true
}

# Write manifest file with metadata header and entries from stdin
#
# Globals:
#   None
#
# Arguments:
#   $1 - Path to manifest file to write (required)
#   $2 - Source repository URL (required)
#   $3 - Target directory path (required)
#   $4 - Rules path (optional, defaults to "rules")
#   $5 - Rulesets path (optional, defaults to "rulesets")
#
# Outputs:
#   None (writes to file)
#
# Returns:
#   0 on success
#
write_manifest_with_entries() {
	wmwe_manifest_file="${1}"
	wmwe_source_repo="${2}"
	wmwe_target_dir="${3}"
	wmwe_rules_path="${4:-$DEFAULT_RULES_PATH}"         # Default to DEFAULT_RULES_PATH if not provided
	wmwe_rulesets_path="${5:-$DEFAULT_RULESETS_PATH}"    # Default to DEFAULT_RULESETS_PATH if not provided
	
	# Write header with all fields using printf to ensure literal tabs
	printf "%s\t%s\t%s\t%s\n" "${wmwe_source_repo}" "${wmwe_target_dir}" "${wmwe_rules_path}" "${wmwe_rulesets_path}" > "${wmwe_manifest_file}"
	
	# Read from stdin and append if there's content
	while IFS= read -r wmwe_line; do
		if [ -n "${wmwe_line}" ]; then
			echo "${wmwe_line}" >> "${wmwe_manifest_file}"
		fi
	done
}

# Add entry to specified manifest file
#
# Globals:
#   None
#
# Arguments:
#   $1 - Path to manifest file (required)
#   $2 - Entry to add (required)
#
# Outputs:
#   Stderr: Error message if write fails
#
# Returns:
#   0 on success (including if entry already exists)
#   1 on error (via error() function)
#
add_manifest_entry_to_file() {
	ametf_target_manifest_file="${1}"
	ametf_entry="${2}"
	
	# Check if entry already exists
	if [ -f "${ametf_target_manifest_file}" ]; then
		if read_manifest_entries "${ametf_target_manifest_file}" | grep -q "^${ametf_entry}$"; then
			return 0  # Already exists
		fi
	fi
	
	# Add the entry with error handling
	if ! echo "${ametf_entry}" >> "${ametf_target_manifest_file}" 2>/dev/null; then
		show_permission_error "${ametf_target_manifest_file}" "write to"
	fi
}

# Remove entry from specified manifest file
#
# Globals:
#   None
#
# Arguments:
#   $1 - Path to manifest file (required)
#   $2 - Entry to remove (required)
#
# Outputs:
#   Stderr: Error message if metadata read fails
#
# Returns:
#   0 on success (including if file doesn't exist or entry not found)
#   1 on error (via error() function)
#
remove_manifest_entry_from_file() {
	rmeff_local_manifest_file="${1}"
	rmeff_entry="${2}"
	
	if [ ! -f "${rmeff_local_manifest_file}" ]; then
		return 0  # Nothing to remove
	fi
	
	# Get metadata
	if ! rmeff_metadata=$(read_manifest_metadata "${rmeff_local_manifest_file}"); then
		error "Failed to read manifest metadata from ${rmeff_local_manifest_file}"
	fi
	
	# Get entries excluding the one to remove
	rmeff_entries=$(read_manifest_entries "${rmeff_local_manifest_file}" | grep -v "^${rmeff_entry}$" || true)
	
	# Count tabs to determine format version
	rmeff_tab_count=$(echo "${rmeff_metadata}" | tr -cd '\t' | wc -c)
	
	# Extract fields based on format
	rmeff_source_repo=$(echo "${rmeff_metadata}" | cut -f1 -d"	")
	rmeff_target_dir=$(echo "${rmeff_metadata}" | cut -f2 -d"	")
	
	if [ "${rmeff_tab_count}" -eq 1 ]; then
		# Old format - upgrade to new format with defaults
		rmeff_rules_path="${DEFAULT_RULES_PATH}"
		rmeff_rulesets_path="${DEFAULT_RULESETS_PATH}"
	else
		# New format - extract values
		rmeff_rules_path=$(echo "${rmeff_metadata}" | cut -f3 -d"	")
		rmeff_rulesets_path=$(echo "${rmeff_metadata}" | cut -f4 -d"	")
	fi
	
	# Write header with all fields (new format)
	printf "%s\t%s\t%s\t%s\n" "${rmeff_source_repo}" "${rmeff_target_dir}" "${rmeff_rules_path}" "${rmeff_rulesets_path}" > "${rmeff_local_manifest_file}"
	
	# Append entries if any exist
	if [ -n "${rmeff_entries}" ]; then
		echo "${rmeff_entries}" >> "${rmeff_local_manifest_file}"
	fi
}

# Get metadata from any available manifest file for lazy initialization
#
# Globals:
#   COMMIT_MANIFEST_FILE - Path to commit manifest file
#   LOCAL_MANIFEST_FILE - Path to local manifest file
#
# Arguments:
#   None
#
# Outputs:
#   Stdout: Tab-separated "source_repo\ttarget_dir" line from first available manifest
#
# Returns:
#   0 on success (manifest found and read)
#   1 if no manifests available
#
get_any_manifest_metadata() {
	# Try commit manifest first
	if [ -f "${COMMIT_MANIFEST_FILE}" ]; then
		read_manifest_metadata "${COMMIT_MANIFEST_FILE}"
		return $?
	fi
	
	# Try local manifest
	if [ -f "${LOCAL_MANIFEST_FILE}" ]; then
		read_manifest_metadata "${LOCAL_MANIFEST_FILE}"
		return $?
	fi
	
	# No manifests available
	return 1
}

# Parse manifest metadata and set global variables for custom paths
#
# Globals:
#   SOURCE_REPO - Set from manifest metadata
#   TARGET_DIR - Set from manifest metadata
#   RULES_PATH, RULESETS_PATH - Set from manifest (identical across modes)
#   DEFAULT_RULES_PATH, DEFAULT_RULESETS_PATH - Default values
#
# Arguments:
#   $1 - Path to manifest file (required)
#   $2 - Mode (optional, unused but kept for backward compatibility)
#
# Outputs:
#   None (sets global variables)
#
# Returns:
#   0 on success
#   1 if file doesn't exist
#
parse_manifest_metadata() {
	pmm_manifest_file="${1}"
	
	if [ ! -f "${pmm_manifest_file}" ]; then
		return 1
	fi
	
	# Read metadata line
	pmm_metadata=$(read_manifest_metadata "${pmm_manifest_file}")
	
	# Count tabs to determine format version
	pmm_tab_count=$(echo "${pmm_metadata}" | tr -cd '\t' | wc -c)
	
	# Extract fields based on format
	pmm_source_repo=$(echo "${pmm_metadata}" | cut -f1 -d"	")
	pmm_target_dir=$(echo "${pmm_metadata}" | cut -f2 -d"	")
	
	if [ "${pmm_tab_count}" -eq 1 ]; then
		# Old format - use defaults
		pmm_rules_path="${DEFAULT_RULES_PATH}"
		pmm_rulesets_path="${DEFAULT_RULESETS_PATH}"
	else
		# New format - extract values
		pmm_rules_path=$(echo "${pmm_metadata}" | cut -f3 -d"	")
		pmm_rulesets_path=$(echo "${pmm_metadata}" | cut -f4 -d"	")
	fi
	
	# Set global paths (identical across modes)
	RULES_PATH="${pmm_rules_path}"
	RULESETS_PATH="${pmm_rulesets_path}"
	
	# Set unified variables
	SOURCE_REPO="${pmm_source_repo}"
	TARGET_DIR="${pmm_target_dir}"
	
	return 0
}

# Clone or update the rules repository cache
#
# This is the core sync function - all rule operations depend on having
# an up-to-date local cache of the rules repository. Uses graceful error
# handling so ai-rizz can work offline with cached content.
#
# Suppresses git output to avoid cluttering user interface while preserving
# error detection for proper failure reporting.
#
# Globals:
#   REPO_DIR - Target directory for repository cache
#
# Arguments:
#   $1 - Repository URL to clone/update
#
# Outputs:
#   Stderr: Warning messages on failure
#
# Returns:
#   0 on success
#   1 on failure (network issues, invalid URL, permissions)
#
git_sync() {
  gs_repo_url="${1}"
  
  # Ensure config directory exists
  mkdir -p "$(dirname "${REPO_DIR}")"
  
  # Clone/update project repository
  if [ ! -d "${REPO_DIR}" ]; then
	if ! git clone "${gs_repo_url}" "${REPO_DIR}" >/dev/null; then
	  warn "Failed to clone repository: ${gs_repo_url} (repository unavailable or invalid URL)"
	  return 1
	fi
  else
	if ! (cd "${REPO_DIR}" && git pull >/dev/null); then
	  warn "Failed to update repository: ${gs_repo_url} (repository unavailable or network issue)"
	  return 1
	fi
  fi
  
  return 0
}

# Git Exclude Management  
# ======================

# Update .git/info/exclude for specific paths
#
# Uses exact line matching to avoid partial matches. Idempotent.
#
# Globals:
#   None
#
# Arguments:
#   $1 - Path to add/remove from git excludes
#   $2 - Action: "add" or "remove"
#
# Outputs:
#   Stderr: Error message if invalid action
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
update_git_exclude() {
	uge_path="${1}"
	uge_action="${2}"  # "add" or "remove"
	
	# Create .git/info directory if it doesn't exist
	mkdir -p ".git/info"
	
	# Create exclude file if it doesn't exist  
	touch ".git/info/exclude"
	
	case "${uge_action}" in
		add)
			if ! grep -q "^${uge_path}$" ".git/info/exclude"; then
				echo "${uge_path}" >> ".git/info/exclude"
			fi
			;;
		remove)
			# Create a temporary file
			uge_tmp_file=$(mktemp)
			# Filter out the path
			grep -v "^${uge_path}$" ".git/info/exclude" > "${uge_tmp_file}" || true
			# Replace the original file
			cat "${uge_tmp_file}" > ".git/info/exclude"
			# Remove the temporary file
			rm -f "${uge_tmp_file}"
			;;
		*)
			error "Invalid action: ${uge_action}. Must be 'add' or 'remove'"
			;;
	esac
}

# Setup git excludes for local mode
#
# Adds local manifest and target directory to git excludes.
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename to exclude
#   LOCAL_DIR - Local directory name to exclude
#
# Arguments:
#   $1 - Target directory base path
#
# Outputs:
#   None
#
# Returns:
#   0 on success
#
setup_local_mode_excludes() {
	slme_target_dir="${1}"
	
	update_git_exclude "${LOCAL_MANIFEST_FILE}" "add"
	update_git_exclude "${slme_target_dir}/${LOCAL_DIR}" "add"
}

# Remove all local mode excludes
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename to unexclude
#   LOCAL_DIR - Local directory name to unexclude
#
# Arguments:
#   $1 - Target directory base path
#
# Outputs:
#   None
#
# Returns:
#   0 on success
#
remove_local_mode_excludes() {
	rlme_target_dir="${1}"
	
	update_git_exclude "${LOCAL_MANIFEST_FILE}" "remove"
	update_git_exclude "${rlme_target_dir}/${LOCAL_DIR}" "remove"
}

# Validate git exclude state matches mode configuration
#
# Warns about mismatched git exclude state - helps debug when users
# manually edit .git/info/exclude and break mode separation.
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   LOCAL_DIR - Local directory name
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   SHARED_DIR - Shared directory name
#
# Arguments:
#   $1 - Target directory base path
#
# Outputs:
#   Stderr: Warning messages for mismatched state
#
# Returns:
#   0 always
#
validate_git_exclude_state() {
	vges_target_dir="${1}"
	
	if [ "$(is_mode_active local)" = "true" ]; then
		# Local mode should be excluded
		if [ ! -f ".git/info/exclude" ] || ! grep -q "^${LOCAL_MANIFEST_FILE}$" ".git/info/exclude"; then
			warn "Local manifest file not in git exclude (should be git-ignored)"
		fi
		if [ ! -f ".git/info/exclude" ] || ! grep -q "^${vges_target_dir}/${LOCAL_DIR}$" ".git/info/exclude"; then
			warn "Local directory not in git exclude (should be git-ignored)"
		fi
	fi
	
	if [ "$(is_mode_active commit)" = "true" ]; then
		# Commit mode should NOT be excluded
		if [ -f ".git/info/exclude" ] && grep -q "^${COMMIT_MANIFEST_FILE}$" ".git/info/exclude"; then
			warn "Commit manifest file in git exclude (should be git-tracked)"
		fi
		if [ -f ".git/info/exclude" ] && grep -q "^${vges_target_dir}/${SHARED_DIR}$" ".git/info/exclude"; then
			warn "Shared directory in git exclude (should be git-tracked)"
		fi
	fi
}

# Mode Detection Utilities
# ========================

# Check if a specific mode is currently active
#
# Uses the same logic as detect_initialized_modes but for a single mode.
# Checks both manifest file existence and target directory existence.
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   LOCAL_DIR - Local directory name
#   SHARED_DIR - Shared directory name
#
# Arguments:
#   $1 - Mode to check: "local" or "commit"
#
# Outputs:
#   Stdout: "true" if mode is active, "false" otherwise
#
# Returns:
#   0 always
#
is_mode_active() {
	ima_mode="${1}"
	
	case "${ima_mode}" in
		local)
			if [ -f "${LOCAL_MANIFEST_FILE}" ]; then
				echo "true"
			else
				echo "false"
			fi
			;;
		commit)
			if [ -f "${COMMIT_MANIFEST_FILE}" ]; then
				echo "true"
			else
				echo "false"
			fi
			;;
		*)
			echo "false"
			;;
	esac
	
	return 0
}

# Get target directory from available manifests
#
# Tries commit manifest first, then local, then default. The default
# is only used during initialization when no manifests exist yet.
#
# Globals:
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   DEFAULT_TARGET_DIR - Default target directory
#
# Arguments:
#   None
#
# Outputs:
#   Stdout: Target directory path
#
# Returns:
#   0 always
#
get_target_directory() {
	# Try commit manifest first
	if [ -f "${COMMIT_MANIFEST_FILE}" ]; then
		if ! gtd_metadata=$(read_manifest_metadata "${COMMIT_MANIFEST_FILE}"); then
			error "Failed to read commit manifest metadata"
		fi
		echo "${gtd_metadata}" | cut -f2 -d"	"
		return 0
	fi
	
	# Try local manifest
	if [ -f "${LOCAL_MANIFEST_FILE}" ]; then
		if ! gtd_metadata=$(read_manifest_metadata "${LOCAL_MANIFEST_FILE}"); then
			error "Failed to read local manifest metadata"
		fi
		echo "${gtd_metadata}" | cut -f2 -d"	"
		return 0
	fi
	
	# No manifests available - use default only during initialization
	echo "${DEFAULT_TARGET_DIR}"
}

# Cache manifest metadata in globals for efficiency
#
# Avoids repeatedly parsing manifest files during operations.
#
# Globals:
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   COMMIT_SOURCE_REPO - Set from commit manifest
#   COMMIT_TARGET_DIR - Set from commit manifest
#   COMMIT_RULES_PATH - Set from commit manifest
#   COMMIT_RULESETS_PATH - Set from commit manifest
#   LOCAL_SOURCE_REPO - Set from local manifest
#   LOCAL_TARGET_DIR - Set from local manifest
#   LOCAL_RULES_PATH - Set from local manifest
#   LOCAL_RULESETS_PATH - Set from local manifest
#
# Arguments:
#   None
#
# Outputs:
#   None
#
# Returns:
#   0 always
#
cache_manifest_metadata() {
	# Cache commit manifest metadata
	if [ -f "${COMMIT_MANIFEST_FILE}" ]; then
		parse_manifest_metadata "${COMMIT_MANIFEST_FILE}" "commit"
	fi
	
	# Cache local manifest metadata
	if [ -f "${LOCAL_MANIFEST_FILE}" ]; then
		parse_manifest_metadata "${LOCAL_MANIFEST_FILE}" "local"
	fi
}

# Lazy Initialization Utilities
# =============================

# Initialize a mode that doesn't exist yet, copying metadata from existing mode
#
# Enables progressive mode switching by creating the missing mode with
# matching configuration. Copies source repo and target dir from existing
# mode to maintain consistency.
#
# Globals:
#   LOCAL_DIR - Local directory name
#   SHARED_DIR - Shared directory name
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   SOURCE_REPO - Source repository URL
#   TARGET_DIR - Target directory for rules
#
# Arguments:
#   $1 - Target mode: "local" or "commit"
#
# Outputs:
#   None
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
lazy_init_mode() {
	lim_target_mode="${1}"  # "local" or "commit"
	
	# Get metadata from any existing manifest
	if ! lim_metadata=$(get_any_manifest_metadata); then
		error "No manifest available to copy metadata from for lazy initialization"
	fi
	
	# Count tabs to determine format version
	lim_tab_count=$(echo "${lim_metadata}" | tr -cd '\t' | wc -c)
	
	# Extract fields based on format
	lim_source_repo=$(echo "${lim_metadata}" | cut -f1 -d"	")
	lim_target_dir=$(echo "${lim_metadata}" | cut -f2 -d"	")
	
	if [ "${lim_tab_count}" -eq 1 ]; then
		# Old format - use defaults
		lim_rules_path="${DEFAULT_RULES_PATH}"
		lim_rulesets_path="${DEFAULT_RULESETS_PATH}"
		
		# Debug info
		warn "Using default paths for lazy init: rules=${lim_rules_path}, rulesets=${lim_rulesets_path}"
	else
		# New format - extract values
		lim_rules_path=$(echo "${lim_metadata}" | cut -f3 -d"	")
		lim_rulesets_path=$(echo "${lim_metadata}" | cut -f4 -d"	")
	fi
	
	# Set unified paths (identical across modes)
	RULES_PATH="${lim_rules_path}"
	RULESETS_PATH="${lim_rulesets_path}"
	
	# Set unified variables
	SOURCE_REPO="${lim_source_repo}"
	TARGET_DIR="${lim_target_dir}"
	
	case "${lim_target_mode}" in
		local)
			# Create local mode structure
			mkdir -p "${lim_target_dir}/${LOCAL_DIR}"
			
			# Write empty manifest with metadata (including custom paths)
			echo "" | write_manifest_with_entries "${LOCAL_MANIFEST_FILE}" "${lim_source_repo}" "${lim_target_dir}" "${lim_rules_path}" "${lim_rulesets_path}"
			
			# Update git excludes
			setup_local_mode_excludes "${lim_target_dir}"
			;;
			
		commit)
			# Create commit mode structure  
			mkdir -p "${lim_target_dir}/${SHARED_DIR}"
			
			# Write empty manifest with metadata (including custom paths)
			echo "" | write_manifest_with_entries "${COMMIT_MANIFEST_FILE}" "${lim_source_repo}" "${lim_target_dir}" "${lim_rules_path}" "${lim_rulesets_path}"
			;;
			
		*)
			error "Invalid target mode: ${lim_target_mode}. Must be 'local' or 'commit'"
			;;
	esac
}

# Check if lazy initialization is needed for a mode
#
# Returns success only when one mode exists and the other doesn't.
#
# Globals:
#  None
#
# Arguments:
#   $1 - Target mode: "local" or "commit"
#
# Outputs:
#   None
#
# Returns:
#   0 if lazy initialization needed
#   1 otherwise
#
needs_lazy_init() {
	nli_target_mode="${1}"
	
	case "${nli_target_mode}" in
		local)
			[ "$(is_mode_active local)" = "false" ] && [ "$(is_mode_active commit)" = "true" ]
			;;
		commit)
			[ "$(is_mode_active commit)" = "false" ] && [ "$(is_mode_active local)" = "true" ]
			;;
		*)
			return 1
			;;
	esac
}

# Conflict Resolution Utilities
# =============================

# Get all .mdc files that would be deployed by a manifest
#
# Core function for conflict resolution - determines which individual files
# would be deployed by expanding rulesets into their component files.
# Returns just filenames (not paths) for file-level conflict detection.
#
# Globals:
#   REPO_DIR - Repository directory for resolving entries
#
# Arguments:
#   $1 - Manifest file path
#
# Outputs:
#   Stdout: One filename per line (just filename, not full path)
#
# Returns:
#   0 on success
#   1 if manifest file doesn't exist
#
get_files_from_manifest() {
	gffm_manifest_file="${1}"
	
	if [ ! -f "${gffm_manifest_file}" ]; then
		return 1
	fi
	
	# Use the global repository directory
	gffm_repo_dir="${REPO_DIR}"
	
	# Get all entries from the manifest
	gffm_entries=$(read_manifest_entries "${gffm_manifest_file}" 2>/dev/null || true)
	
	if [ -n "${gffm_entries}" ]; then
		echo "${gffm_entries}" | while IFS= read -r gffm_entry; do
			if [ -n "${gffm_entry}" ]; then
				# Get the source path for this entry
				gffm_source_path="${gffm_repo_dir}/${gffm_entry}"
				
				if [ -f "${gffm_source_path}" ]; then
					# Single file - extract just the filename
					basename "${gffm_source_path}"
				elif [ -d "${gffm_source_path}" ]; then
					# Directory (ruleset) - list all .mdc files in it
					find "${gffm_source_path}" -name "*.mdc" -type f -o -name "*.mdc" -type l | \
					while IFS= read -r gffm_rule_file; do
						basename "${gffm_rule_file}"
					done
				fi
			fi
		done
	fi
}

# Remove local manifest entries that would deploy the given filename
#
# Handles complex conflict resolution logic for partial ruleset conflicts.
# For individual rules, removes the conflicting entry. For rulesets, only
# removes if the exact same ruleset exists in commit mode - otherwise
# preserves the local ruleset and lets sync handle file-level conflicts.
#
# This preserves user intent: if they have a local ruleset with extra rules,
# don't remove the whole thing just because one file conflicts.
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest to modify
#   COMMIT_MANIFEST_FILE - Commit manifest to check for exact matches
#   REPO_DIR - Repository directory for resolving paths
#
# Arguments:
#   $1 - Filename that would conflict
#
# Outputs:
#   None
#
# Returns:
#   0 always
#
remove_local_entries_deploying_file() {
	rledf_filename="${1}"
	
	# Get all local entries
	rledf_local_entries=$(read_manifest_entries "${LOCAL_MANIFEST_FILE}" 2>/dev/null || true)
	
	if [ -n "${rledf_local_entries}" ]; then
		# Use a temporary file to avoid subshell issues
		rledf_temp_entries=$(mktemp)
		echo "${rledf_local_entries}" > "${rledf_temp_entries}"
		
		while IFS= read -r rledf_entry; do
			if [ -n "${rledf_entry}" ]; then
				# Check if this entry would deploy the target filename
				rledf_source_path="${REPO_DIR}/${rledf_entry}"
				
				if [ -f "${rledf_source_path}" ]; then
					# Single file - check if it matches
					if [ "$(basename "${rledf_source_path}")" = "${rledf_filename}" ]; then
						remove_manifest_entry_from_file "${LOCAL_MANIFEST_FILE}" "${rledf_entry}"
					fi
				elif [ -d "${rledf_source_path}" ]; then
					# Directory (ruleset) - check if it contains the file
					if find "${rledf_source_path}" -name "${rledf_filename}" -type f -o -name "${rledf_filename}" -type l | \
						   grep -q .; then
						# For rulesets containing a conflicting file, we have a partial conflict.
						# We should NOT remove the entire local ruleset because it may contain
						# other rules that should remain local. Instead, let the sync process
						# handle the file-level conflict (commit wins for individual files).
						#
						# The only case where we remove the entire local ruleset is if the
						# commit manifest contains the exact same ruleset entry.
						rledf_ruleset_path="${rledf_entry}"
						if [ -f "${COMMIT_MANIFEST_FILE}" ] && read_manifest_entries "${COMMIT_MANIFEST_FILE}" | grep -q "^${rledf_ruleset_path}$"; then
							# Exact same ruleset in both modes - remove from local (commit wins)
							remove_manifest_entry_from_file "${LOCAL_MANIFEST_FILE}" "${rledf_entry}"
						else
							# Partial conflict - keep local ruleset, let sync handle file-level conflicts
							continue
						fi
					fi
				fi
			fi
		done < "${rledf_temp_entries}"
		
		# Clean up temporary file
		rm -f "${rledf_temp_entries}"
	fi
}



# Detect and resolve conflicts between commit and local modes
#
# Implements "commit wins" policy by removing local entries that would deploy
# the same files as commit mode. Works at file level, not just entry level,
# so "rules/rule1.mdc" conflicts with "rulesets/set1" if set1 contains rule1.
#
# Uses temporary files to avoid subshell variable issues in the conflict
# resolution loop.
#
# Globals:
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   LOCAL_MANIFEST_FILE - Local manifest filename
#
# Arguments:
#   None
#
# Outputs:
#   None
#
# Returns:
#   0 always
#
resolve_conflicts() {
	if [ "$(is_mode_active commit)" = "false" ] || [ "$(is_mode_active local)" = "false" ]; then
		return 0  # No conflicts possible with single mode
	fi
	
	if [ ! -f "${COMMIT_MANIFEST_FILE}" ] || [ ! -f "${LOCAL_MANIFEST_FILE}" ]; then
		return 0  # Can't have conflicts if manifests don't exist
	fi
	
	# Get all .mdc files that would be deployed by commit manifest
	rc_commit_files=$(get_files_from_manifest "${COMMIT_MANIFEST_FILE}" 2>/dev/null || true)
	
	if [ -n "${rc_commit_files}" ]; then
		# Use a temporary file to avoid subshell issues
		rc_temp_file=$(mktemp)
		echo "${rc_commit_files}" > "${rc_temp_file}"
		
		# For each file that commit would deploy, remove any local entries that would deploy the same file
		while IFS= read -r rc_filename; do
			if [ -n "${rc_filename}" ]; then
				remove_local_entries_deploying_file "${rc_filename}"
			fi
		done < "${rc_temp_file}"
		
		# Clean up temporary file
		rm -f "${rc_temp_file}"
	fi
}

# Validation Utilities
# ===================

# Validate manifest file format (minimal implementation)
#
# Globals:
#   None
#
# Arguments:
#   $1 - Manifest file path
#
# Outputs:
#   Stderr: Warning messages for invalid format
#
# Returns:
#   0 if valid format
#   1 if invalid or missing
#
validate_manifest_format() {
	vmf_manifest_file="${1}"
	
	if [ ! -f "${vmf_manifest_file}" ]; then
		return 1
	fi
	
	# Check if file is empty
	if [ ! -s "${vmf_manifest_file}" ]; then
		warn "Manifest file ${vmf_manifest_file} is empty"
		return 1
	fi
	
	# Check first line format
	vmf_first_line=$(head -n1 "${vmf_manifest_file}")
	if ! echo "${vmf_first_line}" | grep -q "	"; then
		warn "Invalid manifest format in ${vmf_manifest_file}: First line must be 'source_repo<tab>target_dir'"
		return 1
	fi
	
	return 0
}

# Validate that both manifests use the same source repository (hard error)
#
# Globals:
#   COMMIT_SOURCE_REPO - Commit mode source repository
#   LOCAL_SOURCE_REPO - Local mode source repository
#
# Arguments:
#   None
#
# Outputs:
#   None
#
# Returns:
#   Never returns on error (calls error() function)
#   0 if valid or single mode
#
# Show detailed manifest integrity error with fix options
#
# Displays comprehensive error message for repository mismatches with
# copy-pasteable commands to resolve the issue. Provides three clear
# options for users to sync their manifests.
#
# Globals:
#   LOCAL_SOURCE_REPO - Local mode source repository
#   COMMIT_SOURCE_REPO - Commit mode source repository
#
# Arguments:
#   None
#
# Outputs:
#   Stderr: Detailed error message with fix options
#
# Returns:
#   None (function only outputs error message)
#
show_manifest_integrity_error() {
	# Read the first line of each manifest to show the exact difference
	local_metadata=""
	commit_metadata=""
	
	if [ -f "${LOCAL_MANIFEST_FILE}" ]; then
		local_metadata=$(head -n1 "${LOCAL_MANIFEST_FILE}")
	fi
	
	if [ -f "${COMMIT_MANIFEST_FILE}" ]; then
		commit_metadata=$(head -n1 "${COMMIT_MANIFEST_FILE}")
	fi
	
	cat >&2 << EOF
Error: Manifest integrity error - manifests have different metadata:

  Local manifest:  ${local_metadata}
  Commit manifest: ${commit_metadata}

To fix this, choose which configuration you want to use for both modes:

Option 1: Switch local mode to match commit mode
  ai-rizz deinit --local -y && ai-rizz init ${SOURCE_REPO} -d "${TARGET_DIR}" --local

Option 2: Switch commit mode to match local mode  
  ai-rizz deinit --commit -y && ai-rizz init ${SOURCE_REPO} -d "${TARGET_DIR}" --commit

Option 3: Reset everything and start fresh
  ai-rizz deinit --all -y && ai-rizz init
EOF
}

# Validate that both manifests have matching metadata (hard error)
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#
# Arguments:
#   None
#
# Outputs:
#   None
#
# Returns:
#   Never returns on error (calls error() function)
#   0 if valid or single mode
#
validate_manifest_integrity() {
	if [ "$(is_mode_active commit)" = "true" ] && [ "$(is_mode_active local)" = "true" ]; then
		# Check if manifests exist
		if [ ! -f "${LOCAL_MANIFEST_FILE}" ] || [ ! -f "${COMMIT_MANIFEST_FILE}" ]; then
			return 0
		fi
		
		# Read the first line (metadata) of each manifest
		local_metadata=$(head -n1 "${LOCAL_MANIFEST_FILE}")
		commit_metadata=$(head -n1 "${COMMIT_MANIFEST_FILE}")
		
		# Compare the entire metadata line
		if [ "${local_metadata}" != "${commit_metadata}" ]; then
			show_manifest_integrity_error
			exit 1
		fi
	fi
}

# Consolidated Helper Functions for Command Logic
# ============================================

# Consolidate initialization check and integrity validation
#
# Performs both the basic initialization check and manifest integrity validation
# that commonly appear together throughout command functions.
#
# Globals:
#   None
#
# Arguments:
#   None
#
# Outputs:
#   Stderr: Error messages on failure
#
# Returns:
#   Never returns on error (calls error() function)
#   0 if any mode is initialized and integrity is valid
#
ensure_initialized_and_valid() {
	# Check if any mode is initialized
	if [ "$(is_mode_active commit)" = "false" ] && [ "$(is_mode_active local)" = "false" ]; then
		show_initialization_error
	fi
	
	# Cache manifest metadata to populate target directory globals
	cache_manifest_metadata
	
	# Validate manifest integrity (hard error for mismatched source repos)
	validate_manifest_integrity
}

# Handle smart mode selection
#
# Implements the common pattern of selecting a mode when not explicitly provided
# by choosing the single available mode or prompting for selection when both exist.
#
# Globals:
#   None
#
# Arguments:
#   $1 - Current mode value (may be empty)
#
# Outputs:
#   Stdout: Selected mode ("local" or "commit")
#   Stderr: Error messages on failure
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
select_mode() {
	sm_current_mode="${1}"
	
	# If mode already specified, validate and return
	if [ -n "${sm_current_mode}" ]; then
		case "${sm_current_mode}" in
			local|commit)
				echo "${sm_current_mode}"
				return 0
				;;
			*)
				show_invalid_mode_error "${sm_current_mode}"
				;;
			esac
	fi
	
	# Smart mode selection
	if [ "$(is_mode_active local)" = "true" ] && [ "$(is_mode_active commit)" = "false" ]; then
		echo "local"
	elif [ "$(is_mode_active commit)" = "true" ] && [ "$(is_mode_active local)" = "false" ]; then
		echo "commit"
	else
		show_mode_selection_error "command"
	fi
	
	return 0
}

# Handle lazy initialization with tracking
#
# Implements the pattern of checking if lazy initialization is needed and tracking
# whether it occurred, commonly used in add operations.
#
# Globals:
#   None (calls needs_lazy_init and lazy_init_mode functions)
#
# Arguments:
#   $1 - Mode to potentially initialize
#
# Outputs:
#   Stdout: "true" if lazy initialization occurred, "false" otherwise
#   Stderr: May output from lazy_init_mode function
#
# Returns:
#   0 on success
#
initialize_mode_if_needed() {
	imn_mode="${1}"
	
	# Check if lazy initialization is needed and track it
	if needs_lazy_init "${imn_mode}"; then
		lazy_init_mode "${imn_mode}"
		# Refresh cached metadata after lazy initialization
		cache_manifest_metadata
		echo "true"
	else
		echo "false"
	fi
	
	return 0
}

# Select manifest file and target directory based on mode
#
# Implements the common pattern of selecting the correct manifest file and target
# directory based on the mode
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename (read)
#   COMMIT_MANIFEST_FILE - Commit manifest filename (read)
#   TARGET_DIR - Target directory (read)
#   LOCAL_DIR - Local directory name (read)
#   SHARED_DIR - Shared directory name (read)
#   SOURCE_REPO - Source repository (read)
#
# Arguments:
#   $1 - Mode ("local" or "commit")
#
# Outputs:
#   Stdout: Tab-separated "manifest_file<TAB>target_dir"
#   Stderr: Warning messages from git_sync if repository update fails
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
get_manifest_and_target() {
	gmt_mode="${1}"
	
	# Select manifest and target based on mode (clean output)
	case "${gmt_mode}" in
		local)
			printf "%s\t%s\n" "${LOCAL_MANIFEST_FILE}" "${TARGET_DIR}/${LOCAL_DIR}"
			;;
		commit)
			printf "%s\t%s\n" "${COMMIT_MANIFEST_FILE}" "${TARGET_DIR}/${SHARED_DIR}"
			;;
	esac
	
	return 0
}

# Add .mdc extension to an item if not present
#
# Implements the common pattern of ensuring an item has the .mdc extension.
#
# Globals:
#   None
#
# Arguments:
#   $1 - Item name to normalize
#
# Outputs:
#   Stdout: Item name with .mdc extension
#
# Returns:
#   0 on success
#
ensure_mdc_extension() {
	eme_item="${1}"
	
	# Add .mdc extension if not present
	case "${eme_item}" in
		*".mdc") 
			echo "${eme_item}"
			;;  
		*) 
			echo "${eme_item}.mdc"
			;;  
	esac
	
	return 0
}

# Check if an item exists in the repository
#
# Implements the common pattern of checking if an item exists in the source
# repository and outputting a warning if not found. Handles both files and
# directories.
#
# Globals:
#   REPO_DIR - Repository directory (read)
#
# Arguments:
#   $1 - Item path relative to repository
#   $2 - Item type description (e.g., "rule", "ruleset") for warning message
#   $3 - Type expected: "file" or "dir" (optional, defaults to "file")
#
# Outputs:
#   Stderr: Warning message if item not found
#
# Returns:
#   0 if item exists
#   1 if item not found
#
check_repository_item() {
	cri_item_path="${1}"
	cri_item_type="${2}"
	cri_expected_type="${3:-file}"  # Default to file if not specified
	
	# Check if item exists in source repo based on expected type
	case "${cri_expected_type}" in
		file)
			if [ ! -f "${REPO_DIR}/${cri_item_path}" ]; then
				warn "${cri_item_type} not found: ${cri_item_path}"
				return 1
			fi
			;;
		dir)
			if [ ! -d "${REPO_DIR}/${cri_item_path}" ]; then
				warn "${cri_item_type} not found: ${cri_item_path}"
				return 1
			fi
			;;
		*)
			warn "Invalid type check: ${cri_expected_type}. Must be 'file' or 'dir'"
			return 1
			;;
	esac
	
	return 0
}

# Handle conflict resolution migration logic
#
# Implements the complex pattern of migrating entries between modes to resolve
# conflicts, handling both normal operation and post-lazy-initialization scenarios.
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename (read)
#   COMMIT_MANIFEST_FILE - Commit manifest filename (read)
#
# Arguments:
#   $1 - Item path to migrate
#   $2 - Target mode ("local" or "commit")
#   $3 - Lazy initialization occurred flag ("true" or "false")
#
# Outputs:
#   None (may call remove_manifest_entry_from_file)
#
# Returns:
#   0 on success
#
migrate_from_opposite_mode() {
	mfom_item_path="${1}"
	mfom_target_mode="${2}"
	mfom_lazy_init_occurred="${3}"
	
	# Check if item exists in opposite mode (conflict resolution)
	# Skip migration check if we just lazy-initialized the target mode (it's empty)
	if [ "${mfom_lazy_init_occurred}" = "false" ]; then
		case "${mfom_target_mode}" in
			local)
				if [ "$(is_mode_active commit)" = "true" ]; then
					if read_manifest_entries "${COMMIT_MANIFEST_FILE}" | grep -q "^${mfom_item_path}$"; then
						# Remove from commit mode, add to local mode
						remove_manifest_entry_from_file "${COMMIT_MANIFEST_FILE}" "${mfom_item_path}"
					fi
				fi
				;;
			commit)
				if [ "$(is_mode_active local)" = "true" ]; then
					if read_manifest_entries "${LOCAL_MANIFEST_FILE}" | grep -q "^${mfom_item_path}$"; then
						# Remove from local mode, add to commit mode
						remove_manifest_entry_from_file "${LOCAL_MANIFEST_FILE}" "${mfom_item_path}"
					fi
				fi
				;;
		esac
	else
		# Lazy initialization occurred - need to migrate from opposite mode
		case "${mfom_target_mode}" in
			local)
				# We just created local mode, migrate from commit mode if item exists there
				if [ "$(is_mode_active commit)" = "true" ]; then
					if read_manifest_entries "${COMMIT_MANIFEST_FILE}" | grep -q "^${mfom_item_path}$"; then
						remove_manifest_entry_from_file "${COMMIT_MANIFEST_FILE}" "${mfom_item_path}"
					fi
				fi
				;;
			commit)
				# We just created commit mode, migrate from local mode if item exists there
				if [ "$(is_mode_active local)" = "true" ]; then
					if read_manifest_entries "${LOCAL_MANIFEST_FILE}" | grep -q "^${mfom_item_path}$"; then
						remove_manifest_entry_from_file "${LOCAL_MANIFEST_FILE}" "${mfom_item_path}"
					fi
				fi
				;;
		esac
	fi
	
	return 0
}

# Commands
# ========

# Initialize the repository (progressive initialization)
#
# Creates local or commit mode with manifest file, target directory structure,
# and git excludes (for local mode). 
#
# Prompts for missing parameters, validates mode compatibility, syncs source 
# repository, and handles idempotent re-init. Supports progressive dual-mode 
# by preserving existing mode configuration.
#
# Key behaviors:
# • Prompts for missing source repo, target dir, and mode
# • Validates git repository context and mode compatibility  
# • Creates manifest files and directory structure
# • Sets up git excludes for local mode only
# • Handles idempotent re-initialization
#
# Globals:
#   COMMIT_MANIFEST_FILE - Commit manifest filename (read)
#   LOCAL_MANIFEST_FILE - Local manifest filename (read)
#   CUSTOM_MANIFEST_ROOT - Custom manifest root filename (read)
#   DEFAULT_TARGET_DIR - Default target directory
#   LOCAL_DIR - Local directory name
#   SHARED_DIR - Shared directory name
#
# Arguments:
#   [source_repo]        - Repository URL (prompted if not provided)
#   [-d target_dir]      - Target directory (defaults to .cursor/rules)
#   [--local|-l]         - Initialize local mode (git-ignored)
#   [--commit|-c]        - Initialize commit mode (git-tracked)
#   [-s, --skibidi file]  - Use custom manifest root filename (processed globally)
#   [-f, --manifest file] - Alias for --skibidi (processed globally)
#   [--rule-path]        - Rules path (optional, defaults to "rules")
#   [--ruleset-path]     - Rulesets path (optional, defaults to "rulesets")
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
cmd_init() {
	ci_source_repo=""
	ci_target_dir=""
	ci_mode=""
	ci_rule_path=""
	ci_ruleset_path=""
	
	# Parse arguments
	while [ $# -gt 0 ]; do
		case "$1" in
			-d)
				ci_target_dir="$2"
				shift 2
				;;
			--local|-l)
				ci_mode="local"
				shift
				;;
			--commit|-c)
				ci_mode="commit"
				shift
				;;
			--rule-path)
				ci_rule_path="$2"
				shift 2
				;;
			--ruleset-path)
				ci_ruleset_path="$2"
				shift 2
				;;
			*)
				if [ -z "${ci_source_repo}" ]; then
					ci_source_repo="$1"
					shift
				else
					error "Unknown argument: $1"
				fi
				;;
		esac
	done
	
	# Use defaults if not provided
	if [ -z "${ci_rule_path}" ]; then
		ci_rule_path="${DEFAULT_RULES_PATH}"
	fi
	
	if [ -z "${ci_ruleset_path}" ]; then
		ci_ruleset_path="${DEFAULT_RULESETS_PATH}"
	fi
	
	# Prompt for source repo if not provided
	if [ -z "${ci_source_repo}" ]; then
		printf "Source repository URL: "
		read -r ci_source_repo
		if [ -z "${ci_source_repo}" ]; then
			error "Source repository URL is required"
		fi
	fi
	
	# Use default target directory if not provided
	if [ -z "${ci_target_dir}" ]; then
		ci_target_dir="${DEFAULT_TARGET_DIR}"
	fi
	
	# Prompt for mode if not provided
	if [ -z "${ci_mode}" ]; then
		printf "Mode [local/commit]: "
		read -r ci_mode
		if [ -z "${ci_mode}" ]; then
			ci_mode="local"
		fi
	fi
	
	# Validate mode
	case "${ci_mode}" in
		local|commit)
			;;
		*)
			error "Invalid mode: ${ci_mode}. Must be 'local' or 'commit'"
			;;
	esac

	# If one mode already exists, use its source_repo (no override allowed)
	if [ "$(is_mode_active commit)" = "true" ] || [ "$(is_mode_active local)" = "true" ]; then
		# Use the unified SOURCE_REPO variable
		ci_source_repo="${SOURCE_REPO}"
	fi

	# Check if repository is already initialized in the requested mode
	case "${ci_mode}" in
		local)
			if [ "$(is_mode_active local)" = "true" ]; then
				# Check if parameters match existing configuration using the unified variables
				if [ "${SOURCE_REPO}" = "${ci_source_repo}" ] && [ "${TARGET_DIR}" = "${ci_target_dir}" ]; then
					printf "Initialized ai-rizz with\\n\\tsource: %s\\n\\ttarget: %s\\n\\tmode: %s\\n" "${ci_source_repo}" "${ci_target_dir}" "${ci_mode}"
					return 0  # Idempotent success
				else
					error "Local mode already initialized with different parameters. Use 'ai-rizz deinit --local' first."
				fi
			fi
			;;
		commit)
			if [ "$(is_mode_active commit)" = "true" ]; then
				# Check if parameters match existing configuration using the unified variables
				if [ "${SOURCE_REPO}" = "${ci_source_repo}" ] && [ "${TARGET_DIR}" = "${ci_target_dir}" ]; then
					printf "Initialized ai-rizz with\\n\\tsource: %s\\n\\ttarget: %s\\n\\tmode: %s\\n" "${ci_source_repo}" "${ci_target_dir}" "${ci_mode}"
					return 0  # Idempotent success
				else
					error "Commit mode already initialized with different parameters. Use 'ai-rizz deinit --commit' first."
				fi
			fi
			;;
	esac
	
	# Ensure git repository context
	if [ ! -d ".git" ]; then
		show_git_context_error
	fi
	
	# Clone/sync source repository first
	if ! git_sync "${ci_source_repo}"; then
		show_repository_error "${ci_source_repo}"
	fi
	
	# Initialize the requested mode
	case "${ci_mode}" in
		local)
			# Create local mode structure
			mkdir -p "${ci_target_dir}/${LOCAL_DIR}"
			
			# Write empty manifest with metadata (including custom paths)
			echo "" | write_manifest_with_entries "${LOCAL_MANIFEST_FILE}" "${ci_source_repo}" "${ci_target_dir}" "${ci_rule_path}" "${ci_ruleset_path}"
			
			# Update git excludes
			setup_local_mode_excludes "${ci_target_dir}"
			
			# Update mode state and cache - set unified variables
			SOURCE_REPO="${ci_source_repo}"
			TARGET_DIR="${ci_target_dir}"
			;;
			
		commit)
			# Create commit mode structure  
			mkdir -p "${ci_target_dir}/${SHARED_DIR}"
			
			# Write empty manifest with metadata (including custom paths)
			echo "" | write_manifest_with_entries "${COMMIT_MANIFEST_FILE}" "${ci_source_repo}" "${ci_target_dir}" "${ci_rule_path}" "${ci_ruleset_path}"
			
			# Update mode state and cache - set unified variables
			SOURCE_REPO="${ci_source_repo}"
			TARGET_DIR="${ci_target_dir}"
			;;
	esac
	
	# Set unified paths (identical across modes)
	RULES_PATH="${ci_rule_path}"
	RULESETS_PATH="${ci_ruleset_path}"
	
	printf "Initialized ai-rizz with\\n\\tsource: %s\\n\\ttarget: %s\\n\\tmode: %s\\n" "${ci_source_repo}" "${ci_target_dir}" "${ci_mode}"
	return 0
}

# Recursively remove empty parent directories
#
# Globals:
#   HOME - User home directory (used as stop condition)
#
# Arguments:
#   $1 - Directory to check and potentially remove
#
# Outputs:
#   Stdout: Messages about removed directories
#
# Returns:
#   0 always
#
cleanup_empty_parents() {
  cep_dir="${1}"
  # Check if directory exists and is empty
  if [ -d "${cep_dir}" ] && [ -z "$(ls -A "${cep_dir}")" ]; then
	cep_parent_dir=$(dirname "${cep_dir}")
	echo "Removing empty directory: ${cep_dir}"
	rmdir "${cep_dir}"
	
	# Stop at filesystem root, home directory, or current directory
	if [ "${cep_parent_dir}" != "/" ] && [ "${cep_parent_dir}" != "${HOME}" ] && [ "${cep_parent_dir}" != "." ]; then
	  cleanup_empty_parents "${cep_parent_dir}"
	fi
  fi
}

# Deinitialize the repository (progressive mode-aware)
#
# Removes specified mode(s) including manifest files, target directories,
# and git exclude configurations. Interactive with confirmation prompt unless -y flag
# is used. Performs cleanup of empty parent directories after removal.
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   TARGET_DIR - Target directory base path
#   SOURCE_REPO - Source repository URL
#
# Arguments:
#   [--local|-l]         - Remove local mode only
#   [--commit|-c]        - Remove commit mode only
#   [--all|-a]           - Remove all modes (default if neither --local nor --commit specified)
#   [-y]                 - Skip confirmation prompts
#
# Outputs:
#   Stdout: Confirmation prompts and success messages
#   Stderr: Error messages
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
cmd_deinit() {
	cd_force=false
	cd_mode=""
	
	# Parse arguments
	while [ $# -gt 0 ]; do
		case "$1" in
			-y)
				cd_force=true
				shift
				;;
			--local|-l)
				cd_mode="local"
				shift
				;;
			--commit|-c)
				cd_mode="commit"
				shift
				;;
			--all|-a)
				cd_mode="all"
				shift
				;;
			*)
				error "Unknown argument: $1"
				;;
		esac
	done
	
	# Just cache metadata without validation for deinit
	# This allows deinit to work with invalid or partially initialized states
	cache_manifest_metadata
	
	# Prompt for mode if not provided
	if [ -z "${cd_mode}" ]; then
		if [ "$(is_mode_active local)" = "true" ] && [ "$(is_mode_active commit)" = "true" ]; then
			printf "Which mode to remove [local/commit/all]: "
			read -r cd_mode
			if [ -z "${cd_mode}" ]; then
				cd_mode="all"
			fi
		elif [ "$(is_mode_active local)" = "true" ]; then
			cd_mode="local"
		elif [ "$(is_mode_active commit)" = "true" ]; then
			cd_mode="commit"
		else
			# No modes active, default to all for idempotence
			cd_mode="all"
		fi
	fi
	
	# Validate mode
	case "${cd_mode}" in
		local|commit|all)
			;;
		*)
			error "Invalid mode: ${cd_mode}. Must be 'local', 'commit', or 'all'"
			;;
	esac
	
	# Determine what to remove
	cd_remove_local=false
	cd_remove_commit=false
	
	case "${cd_mode}" in
		local)
			# Just set removal flag without validation - allow deinit of non-existent modes
			cd_remove_local=true
			;;
		commit)
			# Just set removal flag without validation - allow deinit of non-existent modes
			cd_remove_commit=true
			;;
		all)
			cd_remove_local=true
			cd_remove_commit=true
			;;
	esac
	
	# Build confirmation message
	cd_items_to_remove=""
	if [ "${cd_remove_local}" = "true" ] && [ "$(is_mode_active local)" = "true" ]; then
		cd_items_to_remove="${cd_items_to_remove} ${LOCAL_MANIFEST_FILE} ${TARGET_DIR}/${LOCAL_DIR}"
	fi
	if [ "${cd_remove_commit}" = "true" ] && [ "$(is_mode_active commit)" = "true" ]; then
		cd_items_to_remove="${cd_items_to_remove} ${COMMIT_MANIFEST_FILE} ${TARGET_DIR}/${SHARED_DIR}"
	fi
	
	# Confirm deletion
	if ! ${cd_force} && [ -n "${cd_items_to_remove}" ]; then
		echo "This will delete:${cd_items_to_remove}"
		printf "Are you sure? [y/N] "
		read -r cd_confirm
		if [ "${cd_confirm}" != "y" ] && [ "${cd_confirm}" != "Y" ]; then
			echo "Canceled"
			return 0
		fi
	fi
	
	# Save target directory for cleanup before clearing it
	cd_target_for_cleanup="${TARGET_DIR}"
	
	# Remove local mode
	if [ "${cd_remove_local}" = "true" ] && [ "$(is_mode_active local)" = "true" ]; then
		# Remove from git excludes
		remove_local_mode_excludes "${TARGET_DIR}"
		
		# Remove files
		rm -rf "${TARGET_DIR:?}/${LOCAL_DIR}"
		rm -f "${LOCAL_MANIFEST_FILE}"
		
		# Only clear unified variables if commit mode isn't active
		if [ "$(is_mode_active commit)" = "false" ]; then
			SOURCE_REPO=""
			TARGET_DIR=""
		fi
		
		echo "Removed local mode configuration"
	fi
	
	# Remove commit mode
	if [ "${cd_remove_commit}" = "true" ] && [ "$(is_mode_active commit)" = "true" ]; then
		# Remove files (no git exclude changes needed for commit mode)
		rm -rf "${TARGET_DIR:?}/${SHARED_DIR}"
		rm -f "${COMMIT_MANIFEST_FILE}"
		
		# Only clear unified variables if local mode isn't active
		if [ "$(is_mode_active local)" = "false" ]; then
			SOURCE_REPO=""
			TARGET_DIR=""
		fi
		
		echo "Removed commit mode configuration"
	fi
	
	# Clean up empty parent directories using saved value
	if [ -n "${cd_target_for_cleanup}" ]; then
		if [ "${cd_remove_local}" = "true" ]; then
			cd_parent_dir=$(dirname "${cd_target_for_cleanup}/${LOCAL_DIR}")
			if [ "${cd_parent_dir}" != "." ] && [ "${cd_parent_dir}" != "/" ]; then
				cleanup_empty_parents "${cd_parent_dir}"
			fi
		fi
		
		if [ "${cd_remove_commit}" = "true" ]; then
			cd_parent_dir=$(dirname "${cd_target_for_cleanup}/${SHARED_DIR}")
			if [ "${cd_parent_dir}" != "." ] && [ "${cd_parent_dir}" != "/" ]; then
				cleanup_empty_parents "${cd_parent_dir}"
			fi
		fi
	fi
	
	return 0
}

# List available rules and rulesets (multi-mode aware)
#
# Shows rules and rulesets with glyphs indicating installation status.
# Handles dual-mode conflict resolution (commit overrides local), expands
# rulesets to show contents, and uses tree command when available for
# better formatting. Syncs repository before listing.
#
# Globals:
#   SOURCE_REPO - Source repository URL
#   REPO_DIR - Repository directory
#   COMMITTED_GLYPH - Glyph for committed items
#   LOCAL_GLYPH - Glyph for local items
#   UNINSTALLED_GLYPH - Glyph for uninstalled items
#
# Arguments:
#   None
#
# Outputs:
#   Stdout: Formatted list of rules and rulesets
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
cmd_list() {
	# Ensure ai-rizz is initialized and validate manifest integrity
	ensure_initialized_and_valid

	# Validate manifest format for all existing manifests
	if [ "$(is_mode_active local)" = "true" ]; then
		validate_manifest_format "${LOCAL_MANIFEST_FILE}" || error "Corrupted local manifest file"
	fi
	if [ "$(is_mode_active commit)" = "true" ]; then
		validate_manifest_format "${COMMIT_MANIFEST_FILE}" || error "Corrupted commit manifest file"
	fi
	
	# Use the unified SOURCE_REPO variable
	cl_source_repo="${SOURCE_REPO}"
	
	# Update source repository
	git_sync "${cl_source_repo}"
	
	# Helper function to check if an item is installed in any mode
	is_installed() {
		cl_is_installed_item="${1}"
		cl_is_installed_status="uninstalled"
		
		# Helper to check if item is covered by rulesets in a manifest
		check_rulesets_for_item() {
			cl_check_manifest_file="${1}"
			cl_check_item_basename=$(basename "${cl_is_installed_item}")
			cl_check_entries=""
			
			cl_check_entries=$(read_manifest_entries "${cl_check_manifest_file}" 2>/dev/null) || return 1
			
			# Use a for loop instead of while to avoid subshell issues
			for cl_check_entry in ${cl_check_entries}; do
				if [ -n "${cl_check_entry}" ] && echo "${cl_check_entry}" | grep -q "^${RULESETS_PATH}/"; then
					# Check if this ruleset contains the item
					cl_check_ruleset_dir="${REPO_DIR}/${cl_check_entry}"
					if [ -d "${cl_check_ruleset_dir}" ] && [ -f "${cl_check_ruleset_dir}/${cl_check_item_basename}" ]; then
						return 0  # Found in ruleset
					fi
				fi
			done
			return 1  # Not found in any ruleset
		}
		
		# Check local mode first (weaker glyph)
		if [ "$(is_mode_active local)" = "true" ]; then
			# Check if item is directly in manifest
			if read_manifest_entries "${LOCAL_MANIFEST_FILE}" 2>/dev/null | grep -q "^${cl_is_installed_item}$"; then
				cl_is_installed_status="local"
			elif check_rulesets_for_item "${LOCAL_MANIFEST_FILE}"; then
				cl_is_installed_status="local"
			fi
		fi
		
		# Check commit mode (stronger glyph - overrides local)
		if [ "$(is_mode_active commit)" = "true" ]; then
			# Check if item is directly in manifest
			if read_manifest_entries "${COMMIT_MANIFEST_FILE}" 2>/dev/null | grep -q "^${cl_is_installed_item}$"; then
				cl_is_installed_status="committed"
			elif check_rulesets_for_item "${COMMIT_MANIFEST_FILE}"; then
				cl_is_installed_status="committed"
			fi
		fi
		
		echo "${cl_is_installed_status}"
	}
	
	# Display rules
	echo "Available rules:"
	cl_rules=$(find "${REPO_DIR}/${RULES_PATH}" -name "*.mdc" | sort 2>/dev/null)
	if [ -z "${cl_rules}" ]; then
		echo "  No rules found"
	else
		for cl_rule in ${cl_rules}; do
			cl_rule_name=$(basename "${cl_rule}")
			cl_rule_path="${RULES_PATH}/${cl_rule_name}"
			cl_status=$(is_installed "${cl_rule_path}")
			
			case "${cl_status}" in
				committed)
					printf "  %s %s\n" "${COMMITTED_GLYPH}" "${cl_rule_name}"
					;;
				local)
					printf "  %s %s\n" "${LOCAL_GLYPH}" "${cl_rule_name}"
					;;
				*)
					printf "  %s %s\n" "${UNINSTALLED_GLYPH}" "${cl_rule_name}"
					;;
			esac
		done
	fi
	echo ""
	
	# Display rulesets
	echo "Available rulesets:"
	cl_rulesets=$(find "${REPO_DIR}/${RULESETS_PATH}" -mindepth 1 -maxdepth 1 -type d | sort 2>/dev/null)
	if [ -z "${cl_rulesets}" ]; then
		echo "  No rulesets found"
	else
		for cl_ruleset in ${cl_rulesets}; do
			cl_ruleset_name=$(basename "${cl_ruleset}")
			cl_ruleset_path="${RULESETS_PATH}/${cl_ruleset_name}"
			cl_status=$(is_installed "${cl_ruleset_path}")
			
			# Display ruleset with installation status
			case "${cl_status}" in
				committed)
					printf "  %s %s\n" "${COMMITTED_GLYPH}" "${cl_ruleset_name}"
					;;
				local)
					printf "  %s %s\n" "${LOCAL_GLYPH}" "${cl_ruleset_name}"
					;;
				*)
					printf "  %s %s\n" "${UNINSTALLED_GLYPH}" "${cl_ruleset_name}"
					;;
			esac
			
			# Use tree to display ruleset contents (filter to .mdc files only)
			if [ -d "${cl_ruleset}" ]; then
				# Check if tree command exists
				if command -v tree >/dev/null 2>&1; then
					# Use tree with pattern matching to show only .mdc files and symlinks
					(cd "${cl_ruleset}" && tree -P "*.mdc" -L 1 --noreport) | tail -n +2 | sed 's/^/    /' | sed 's/ -> .*$//'
				else
					# Fallback if tree is not available
					find "${cl_ruleset}" -maxdepth 1 \( -name "*.mdc" -type f \) -o \( -name "*.mdc" -type l \) -exec basename {} \; | sort | sed 's/^/    ├── /'
				fi
			fi
		done
	fi
	
	return 0
}

# Check for rule downgrade conflicts
#
# Prevents adding individual rules to local mode when they're part of 
# committed rulesets. This maintains ruleset integrity by ensuring
# complete rulesets stay together.
#
# Globals:
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   REPO_DIR - Repository directory
#
# Arguments:
#   $1 - Rule name (with .mdc extension)
#   $2 - Target mode (local/commit)
#
# Outputs:
#   Stderr: Warning message if conflict detected
#
# Returns:
#   0 if no conflict (rule can be added)
#   1 if conflict detected (rule should be skipped)
#
check_rule_downgrade_conflict() {
	crdc_rule="$1"
	crdc_mode="$2"
	
	# Only check for downgrade conflicts (local mode with commit mode active)
	if [ "$crdc_mode" = "local" ] && [ "$(is_mode_active commit)" = "true" ]; then
		# Check if this rule is part of any committed ruleset
		rule_filename=$(basename "${RULES_PATH}/$crdc_rule")
		commit_entries=$(read_manifest_entries "$COMMIT_MANIFEST_FILE" 2>/dev/null || true)
		
		if [ -n "$commit_entries" ]; then
			# Use a temporary file to avoid subshell issues with pipes
			temp_file=$(mktemp)
			echo "$commit_entries" > "$temp_file"
			
			conflict_found=false
			
			while IFS= read -r entry; do
				if [ -n "$entry" ]; then
					entry_path="$REPO_DIR/$entry"
					if [ -d "$entry_path" ]; then
						# This is a ruleset - check if it contains our rule
						if find "$entry_path" -name "$rule_filename" -type f -o -name "$rule_filename" -type l | grep -q .; then
							warn "Cannot add individual rule '$crdc_rule' to local mode: it's part of committed ruleset '$entry'. Use 'ai-rizz add-ruleset $(basename "$entry") --local' to move the entire ruleset."
							conflict_found=true
							break
						fi
					fi
				fi
			done < "$temp_file"
			
			# Close file handle before removing file
			rm -f "$temp_file"
			
			# Return conflict status after cleanup
			if [ "$conflict_found" = "true" ]; then
				return 1
			fi
		fi
	fi
	
	return 0
}

# Add rule(s) to the repository (progressive mode-aware)
#
# Adds individual rules to specified mode, handling lazy initialization,
# conflict resolution, and downgrade prevention. Prevents adding individual
# rules to local mode when they're part of committed rulesets. Auto-detects
# mode when only one exists, migrates rules between modes on conflicts.
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   SOURCE_REPO - Source repository URL
#   TARGET_DIR - Target directory for rules
#   LOCAL_DIR - Local directory name
#   SHARED_DIR - Shared directory name
#   REPO_DIR - Repository directory
#
# Arguments:
#   <rule>...            - Rule names (.mdc extension optional)
#   [--local|-l]         - Add to local mode (git-ignored)
#   [--commit|-c]        - Add to commit mode (git-tracked)
#
# Outputs:
#   Stdout: Success messages for each added rule
#   Stderr: Warning messages for conflicts or missing rules
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
cmd_add_rule() {
	car_mode=""
	car_rules=""
	
	# Parse arguments
	while [ $# -gt 0 ]; do
		case "$1" in
			--local|-l)
				car_mode="local"
				shift
				;;
			--commit|-c)
				car_mode="commit"
				shift
				;;
			*)
				if [ -z "${car_rules}" ]; then
					car_rules="$1"
				else
					car_rules="${car_rules} $1"
				fi
				shift
				;;
		esac
	done
	
	# Check if any mode is initialized and validate manifest integrity
	ensure_initialized_and_valid

	# Smart mode selection using helper function
	car_mode=$(select_mode "${car_mode}")

	# Check if lazy initialization is needed and track it using helper function
	car_lazy_init_occurred=$(initialize_mode_if_needed "${car_mode}")

	# Select manifest and target based on mode using helper function
	car_manifest_and_target=$(get_manifest_and_target "${car_mode}")
	car_manifest_file=$(echo "${car_manifest_and_target}" | cut -f1 -d"	") # Using literal tab as delimiter
	car_target_dir=$(echo "${car_manifest_and_target}" | cut -f2 -d"	") # Using literal tab as delimiter

	# Process each rule
	for car_rule in ${car_rules}; do
		# Add .mdc extension if not present
		case "${car_rule}" in
			*".mdc") 
				car_item="${car_rule}"
				;;  
			*) 
				car_item="${car_rule}.mdc"
				;;  
		esac
		
		car_rule_path="${RULES_PATH}/${car_item}"
		
		# Check if rule exists in source repo using helper function
		if ! check_repository_item "${car_rule_path}" "Rule"; then
			continue
		fi
		
		# Check for downgrade conflicts first
		if ! check_rule_downgrade_conflict "${car_item}" "${car_mode}"; then
			continue  # Skip this rule, conflict detected
		fi
		
		# Handle conflict resolution migration using helper function
		migrate_from_opposite_mode "${car_rule_path}" "${car_mode}" "${car_lazy_init_occurred}"

		# Check if target directory is writable before adding to manifest
		if [ ! -w "${car_target_dir}" ]; then
			show_permission_error "${car_target_dir}" "write to"
		fi
		
		# Add to target manifest
		add_manifest_entry_to_file "${car_manifest_file}" "${car_rule_path}"
		
		echo "Added rule: ${car_rule_path}"
	done
	
	# Sync to update file locations
	sync_all_modes
	
	return 0
}

# Add ruleset(s) to the repository (progressive mode-aware)
#
# Adds entire rulesets to specified mode, handling lazy initialization and
# conflict resolution. Auto-detects mode when only one exists, migrates
# rulesets between modes on conflicts. Rulesets deploy all contained .mdc
# files as individual rules in the target directory.
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   SOURCE_REPO - Source repository URL
#   TARGET_DIR - Target directory for rules
#   REPO_DIR - Repository directory
#
# Arguments:
#   <ruleset>...         - Ruleset names (directory names under rulesets/)
#   [--local|-l]         - Add to local mode (git-ignored)
#   [--commit|-c]        - Add to commit mode (git-tracked)
#
# Outputs:
#   Stdout: Success messages for each added ruleset
#   Stderr: Warning messages for missing rulesets
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
cmd_add_ruleset() {
	cars_mode=""
	cars_rulesets=""
	
	# Parse arguments
	while [ $# -gt 0 ]; do
		case "$1" in
			--local|-l)
				cars_mode="local"
				shift
				;;
			--commit|-c)
				cars_mode="commit"
				shift
				;;
			*)
				if [ -z "${cars_rulesets}" ]; then
					cars_rulesets="$1"
				else
					cars_rulesets="${cars_rulesets} $1"
				fi
				shift
				;;
		esac
	done
	
	# Check if any mode is initialized and validate manifest integrity
	ensure_initialized_and_valid

	# Smart mode selection using helper function
	cars_mode=$(select_mode "${cars_mode}")

	# Check if lazy initialization is needed and track it using helper function
	cars_lazy_init_occurred=$(initialize_mode_if_needed "${cars_mode}")

	# Select manifest and target based on mode using helper function
	cars_manifest_and_target=$(get_manifest_and_target "${cars_mode}")
	cars_manifest_file=$(echo "${cars_manifest_and_target}" | cut -f1 -d"	") # Using literal tab as delimiter

	# Process each ruleset
	for cars_ruleset in ${cars_rulesets}; do
		cars_ruleset_path="${RULESETS_PATH}/${cars_ruleset}"
		
		# Check if ruleset exists in source repo using helper function
		if ! check_repository_item "${cars_ruleset_path}" "Ruleset" "dir"; then
			continue
		fi
		
		# Handle conflict resolution migration using helper function
		migrate_from_opposite_mode "${cars_ruleset_path}" "${cars_mode}" "${cars_lazy_init_occurred}"

		# Add to target manifest
		add_manifest_entry_to_file "${cars_manifest_file}" "${cars_ruleset_path}"
		
		echo "Added ruleset: ${cars_ruleset_path}"
	done
	
	# Sync to update file locations
	sync_all_modes
	
	return 0
}

# Remove rule(s) from the repository (mode-aware)
#
# Removes individual rules from whichever mode contains them. Auto-detects
# which mode has each rule and removes from the appropriate manifest.
# Triggers sync to clean up target directories after removal.
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   SOURCE_REPO - Source repository URL
#   TARGET_DIR - Target directory for rules
#
# Arguments:
#   <rule>...            - Rule names (.mdc extension optional)
#
# Outputs:
#   Stdout: Success messages for each removed rule
#   Stderr: Warning messages for rules not found
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
cmd_remove_rule() {
	# Check if any mode is initialized and validate manifest integrity
	ensure_initialized_and_valid

	# Process each rule
	for rule in "$@"; do
		# Add .mdc extension if not present
		case "${rule}" in
			*".mdc") 
				crr_item="${rule}"
				;;  
			*) 
				crr_item="${rule}.mdc"
				;;  
		esac
		
		removed=false
		rule_path="${RULES_PATH}/${crr_item}"
		
		# Remove from whichever mode contains it
		if [ "$(is_mode_active local)" = "true" ]; then
			if read_manifest_entries "$LOCAL_MANIFEST_FILE" | grep -q "^$rule_path$"; then
				remove_manifest_entry_from_file "$LOCAL_MANIFEST_FILE" "$rule_path"
				echo "Removed rule: $rule_path"
				removed=true
			fi
		fi
		
		if [ "$(is_mode_active commit)" = "true" ]; then
			if read_manifest_entries "$COMMIT_MANIFEST_FILE" | grep -q "^$rule_path$"; then
				remove_manifest_entry_from_file "$COMMIT_MANIFEST_FILE" "$rule_path"
				echo "Removed rule: $rule_path"
				removed=true
			fi
		fi
		
		if [ "$removed" = "false" ]; then
			warn "Rule not found in any mode: ${crr_item}"
		fi
	done
	
	# Sync to ensure proper cleanup
	sync_all_modes
	
	return 0
}

# Remove ruleset(s) from the repository (mode-aware)
#
# Removes entire rulesets from whichever mode contains them. Auto-detects
# which mode has each ruleset and removes from the appropriate manifest.
# Triggers sync to clean up target directories after removal.
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   SOURCE_REPO - Source repository URL
#   TARGET_DIR - Target directory for rules
#
# Arguments:
#   <ruleset>...         - Ruleset names (directory names under rulesets/)
#
# Outputs:
#   Stdout: Success messages for each removed ruleset
#   Stderr: Warning messages for rulesets not found
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
cmd_remove_ruleset() {
	# Check if any mode is initialized and validate manifest integrity
	ensure_initialized_and_valid

	# Process each ruleset
	for ruleset in "$@"; do
		removed=false
		ruleset_path="${RULESETS_PATH}/$ruleset"
		
		# Remove from whichever mode contains it
		if [ "$(is_mode_active local)" = "true" ]; then
			if read_manifest_entries "$LOCAL_MANIFEST_FILE" | grep -q "^$ruleset_path$"; then
				remove_manifest_entry_from_file "$LOCAL_MANIFEST_FILE" "$ruleset_path"
				echo "Removed ruleset: $ruleset_path"
				removed=true
			fi
		fi
		
		if [ "$(is_mode_active commit)" = "true" ]; then
			if read_manifest_entries "$COMMIT_MANIFEST_FILE" | grep -q "^$ruleset_path$"; then
				remove_manifest_entry_from_file "$COMMIT_MANIFEST_FILE" "$ruleset_path"
				echo "Removed ruleset: $ruleset_path"
				removed=true
			fi
		fi
		
		if [ "$removed" = "false" ]; then
			warn "Ruleset not found in any mode: $ruleset"
		fi
	done
	
	# Sync to ensure proper cleanup
	sync_all_modes
	
	return 0
}

# Sync all available manifests to their target directories
#
# Orchestrates complete sync process: resolves conflicts using "commit wins"
# policy, syncs both modes if initialized, and handles cleanup on failures.
# Core sync function called by cmd_sync and after rule/ruleset modifications.
#
# Globals:
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   TARGET_DIR - Target directory base path
#   SHARED_DIR - Shared directory name
#   LOCAL_DIR - Local directory name
#
# Arguments:
#   None
#
# Outputs:
#   None (delegates to sync_manifest_to_directory)
#
# Returns:
#   0 always (handles failures internally)
#
sync_all_modes() {
	sync_success=true
	
	# Resolve conflicts first (commit mode wins)
	resolve_conflicts
	
	# Sync commit mode if initialized
	if [ "$(is_mode_active commit)" = "true" ]; then
		# Get manifest file and target directory using helper
		commit_manifest_and_target=$(get_manifest_and_target "commit")
		commit_manifest_file=$(echo "${commit_manifest_and_target}" | cut -f1 -d"	")
		commit_target_dir=$(echo "${commit_manifest_and_target}" | cut -f2 -d"	")
		
		sync_manifest_to_directory "${commit_manifest_file}" "${commit_target_dir}" || sync_success=false
	fi
	
	# Sync local mode if initialized  
	if [ "$(is_mode_active local)" = "true" ]; then
		# Get manifest file and target directory using helper
		local_manifest_and_target=$(get_manifest_and_target "local")
		local_manifest_file=$(echo "${local_manifest_and_target}" | cut -f1 -d"	")
		local_target_dir=$(echo "${local_manifest_and_target}" | cut -f2 -d"	")
		
		sync_manifest_to_directory "${local_manifest_file}" "${local_target_dir}" || sync_success=false
	fi
	
	# Handle any cleanup needed
	if [ "$sync_success" = "false" ]; then
		handle_sync_cleanup
	fi
}

# Sync a single manifest to its target directory
#
# Clears target directory of .mdc files and repopulates from manifest entries.
# Uses safety checks to only operate in managed directories. Handles external
# manifest corruption gracefully.
#
# Globals:
#   LOCAL_DIR - Local directory name (for safety check)
#   SHARED_DIR - Shared directory name (for safety check)
#
# Arguments:
#   $1 - Manifest file path
#   $2 - Target directory path
#
# Outputs:
#   Stderr: Warning messages for failures
#
# Returns:
#   0 on success
#   1 on failure (unrecognized directory, read errors)
#
sync_manifest_to_directory() {
	smtd_manifest_file="${1}"
	smtd_target_directory="${2}"
	
	if [ ! -f "${smtd_manifest_file}" ]; then
		return 0  # No manifest to sync
	fi
	
	# Create target directory if needed
	mkdir -p "${smtd_target_directory}"
	
	# Safety check: Only operate in our managed directories (local or shared)
	case "${smtd_target_directory}" in
		*/"${LOCAL_DIR}"|*/"${SHARED_DIR}")
			# Clear existing .mdc files to ensure removed rules are deleted
			# Only delete regular .mdc files, never directories or other files
			find "${smtd_target_directory}" -maxdepth 1 -name "*.mdc" -type f -delete 2>/dev/null || true
			;;
		*)
			warn "Refusing to clear unrecognized target directory: ${smtd_target_directory}"
			return 1
			;;
	esac
	
	# Get entries from manifest (handle external modifications gracefully)
	if ! smtd_entries=$(read_manifest_entries "${smtd_manifest_file}"); then
		warn "Failed to read entries from ${smtd_manifest_file} (possibly corrupted by external changes)"
		return 1
	fi
	
	# Copy each entry (avoid subshell to ensure error propagation)
	if [ -n "${smtd_entries}" ]; then
		# Use a temporary file to avoid subshell issues with pipes
		smtd_temp_file=$(mktemp)
		echo "${smtd_entries}" > "${smtd_temp_file}"
		
		while IFS= read -r smtd_entry; do
			if [ -n "${smtd_entry}" ]; then
				# Continue with other entries even if one fails (resilient to external modifications)
				copy_entry_to_target "${smtd_entry}" "${smtd_target_directory}" || true
			fi
		done < "${smtd_temp_file}"
		
		rm -f "${smtd_temp_file}"
	fi
}

# Check if a filename would be deployed by commit mode
#
# Used by conflict resolution to implement "commit wins" policy. Checks if
# commit mode would deploy a file with the given name, considering both
# individual rules and files within rulesets.
#
# Globals:
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#
# Arguments:
#   $1 - Filename to check (just basename, not full path)
#
# Outputs:
#   None
#
# Returns:
#   0 if file would be deployed by commit mode
#   1 otherwise
#
file_exists_in_commit_mode() {
	fecm_filename="${1}"
	
	if [ "$(is_mode_active commit)" = "false" ] || [ ! -f "${COMMIT_MANIFEST_FILE}" ]; then
		return 1  # No commit mode, so no conflict
	fi
	
	# Check if commit mode would deploy this filename
	fecm_commit_files=$(get_files_from_manifest "${COMMIT_MANIFEST_FILE}" 2>/dev/null || true)
	if [ -n "${fecm_commit_files}" ]; then
		echo "${fecm_commit_files}" | grep -q "^${fecm_filename}$"
		return $?
	fi
	
	return 1  # Not found in commit mode
}

# Copy a single entry (rule or ruleset) to target directory
#
# Handles both individual rules (single file copy) and rulesets (copy all
# .mdc files from directory). Implements conflict resolution by skipping
# files that would conflict with commit mode when syncing to local directory.
# Follows symlinks to copy actual content, not the links themselves.
#
# Globals:
#   REPO_DIR - Repository directory
#   LOCAL_DIR - Local directory name (for conflict detection)
#
# Arguments:
#   $1 - Entry path (relative to repository root)
#   $2 - Target directory path
#
# Outputs:
#   Stderr: Warning messages for missing entries
#
# Returns:
#   0 on success
#   1 if entry not found in repository
#
copy_entry_to_target() {
	cett_entry="${1}"
	cett_target_directory="${2}"
	
	cett_source_path="${REPO_DIR}/${cett_entry}"
	
	# Check if we're syncing to local directory and need to avoid commit conflicts
	cett_is_local_sync=false
	case "${cett_target_directory}" in
		*/"${LOCAL_DIR}")
			cett_is_local_sync=true
			;;
	esac
	
	if [ -f "${cett_source_path}" ]; then
		# Single file (rule)
		cett_filename=$(basename "${cett_source_path}")
		
		# Skip if file would conflict with commit mode (commit wins)
		if [ "${cett_is_local_sync}" = "true" ] && file_exists_in_commit_mode "${cett_filename}"; then
			return 0  # Skip this file
		fi
		
		cp "${cett_source_path}" "${cett_target_directory}/"
	elif [ -d "${cett_source_path}" ]; then
		# Directory (ruleset) - copy individual .mdc files from ruleset to target directory
		# Handle symlinks correctly by following them and copying actual content
		find "${cett_source_path}" -name "*.mdc" -type f -o -name "*.mdc" -type l | \
				while IFS= read -r cett_rule_file; do
			if [ -f "${cett_rule_file}" ] || [ -L "${cett_rule_file}" ]; then
				cett_filename=$(basename "${cett_rule_file}")
				
				# Skip if file would conflict with commit mode (commit wins)
				if [ "${cett_is_local_sync}" = "true" ] && file_exists_in_commit_mode "${cett_filename}"; then
					continue  # Skip this file
				fi
				
				# Copy the file (following symlinks to get actual content)
				cp -L "${cett_rule_file}" "${cett_target_directory}/"
			fi
		done
	else
		warn "Entry not found in repository: ${cett_entry}"
		return 1
	fi
}

# Handle cleanup after sync issues
#
# Performs recovery actions when sync operations fail. Re-caches manifest
# metadata to ensure consistency and validates git exclude state to detect
# manual modifications that might cause issues.
#
# Globals:
#   None (delegates to other functions)
#
# Arguments:
#   None
#
# Outputs:
#   Stderr: Warning messages from validation functions
#
# Returns:
#   0 always
#
handle_sync_cleanup() {
	# Re-cache manifest metadata to ensure consistency
	cache_manifest_metadata
	
	# Validate git exclude state
	hsc_target_dir=$(get_target_directory)
	validate_git_exclude_state "${hsc_target_dir}"
}

# Sync the repository (multi-mode aware)
#
# Updates source repository cache and syncs all manifests to target directories.
# Resolves conflicts using "commit wins" policy, handles network failures
# gracefully, and ensures target directories match manifest contents.
#
# Globals:
#   SOURCE_REPO - Source repository URL
#
# Arguments:
#   None
#
# Outputs:
#   Stdout: Success message
#   Stderr: Warning messages for network failures
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
cmd_sync() {
	# Check if any mode is initialized and validate manifest integrity
	ensure_initialized_and_valid

	# Use unified SOURCE_REPO variable directly
	cs_source_repo="${SOURCE_REPO}"
	
	# Sync repository first
	if [ -n "${cs_source_repo}" ]; then
		if ! git_sync "${cs_source_repo}"; then
			# git_sync already issued a warning, fail the sync operation
			return 1
		fi
	fi
	
	# Sync all initialized modes
	sync_all_modes
	
	echo "Sync complete"
	return 0
}



# Display help information
#
# Shows usage information for all commands and their options.
#
# Globals:
#   None
#
# Arguments:
#   None
#
# Outputs:
#   Stdout: Help text with command usage and options
#
# Returns:
#   0 always
#
cmd_help() {
  cat <<EOF
Usage: ai-rizz <command> [command-specific options]

Available commands:
  init [<source_repo>]     Initialize the repository
  deinit                   Deinitialize the repository
  list                     List available rules and rulesets
  add rule <rule>...       Add rule(s) to the repository (.mdc extension optional)
  add ruleset <ruleset>... Add ruleset(s) to the repository
  remove rule <rule>...    Remove rule(s) from the repository (.mdc extension optional)
  remove ruleset <ruleset>... Remove ruleset(s) from the repository
  sync                     Sync the repository
  help                     Show this help

Command-specific options:
  init options:
	-d <target_dir>        Target directory (default: .cursor/rules)
	--local, -l            Use local mode (ignore files)
	--commit, -c           Use commit mode (commit files)
	-s, --skibidi <file>   Use custom manifest filename
	-f, --manifest <file>  Alias for --skibidi
	--rule-path <path>     Source repository rules path (default: rules)
	--ruleset-path <path>  Source repository rulesets path (default: rulesets)

  deinit options:
	-y                     Skip confirmation prompts
EOF
  return 0
}

# Initialization
# ==============

# Initialize ai-rizz state at startup (two-phase to avoid circular dependencies)
#
# Bootstraps ai-rizz state in careful order to avoid circular dependencies.
# Sets up default paths and caches manifest metadata for the current project.
# Called once at script startup.
#
# Globals:
#   RULES_PATH - Set to default rules path
#   RULESETS_PATH - Set to default rulesets path
#   REPO_DIR - Set to the repository directory for current project
#   SOURCE_REPO - Set during cache_manifest_metadata
#   TARGET_DIR - Set during cache_manifest_metadata
#
# Arguments:
#   None
#
# Outputs:
#   None (delegates to detection functions)
#
# Returns:
#   0 always
#
initialize_ai_rizz() {
	# Initialize paths to defaults
	RULES_PATH="${DEFAULT_RULES_PATH}"
	RULESETS_PATH="${DEFAULT_RULESETS_PATH}"
	
	# Full initialization with directory checking  
	cache_manifest_metadata
	
	# Set repository directory for current project
	REPO_DIR=$(get_repo_dir)
}

# Parse manifest filename argument and determine root and local names
#
# Detects if the provided filename is a local manifest name (contains .local)
# and derives the appropriate root and local manifest filenames.
#
# Arguments:
#   $1 - Manifest filename provided by user
#
# Outputs:
#   Stdout: Tab-separated "root_filename<TAB>local_filename"
#
# Returns:
#   0 always
#
parse_manifest_filename_argument() {
	pmfa_input="$1"
	
	# Check if input contains .local. pattern or ends with .local
	case "$pmfa_input" in
		*.local.*)
			# Pattern: foo.local.bar -> root: foo.bar, local: foo.local.bar
			pmfa_root="${pmfa_input%.local.*}.${pmfa_input##*.local.}"
			pmfa_local="$pmfa_input"
			;;
		*.local)
			# Pattern: Gyattfile.local -> root: Gyattfile, local: Gyattfile.local
			pmfa_root="${pmfa_input%.local}"
			pmfa_local="$pmfa_input"
			;;
		*)
			# Not a local manifest - treat as root and derive local filename
			pmfa_root="$pmfa_input"
			# Inline derivation logic: add .local before extension or at end
			case "$pmfa_input" in
				*.*) 
					pmfa_local="${pmfa_input%.*}.local.${pmfa_input##*.}"
					;;
				*)
					pmfa_local="$pmfa_input.local"
					;;
			esac
			;;
	esac
	
	# Use printf to ensure literal tab is used
	printf "%s\t%s\n" "${pmfa_root}" "${pmfa_local}"
}

# Main
# ====

# Only run main code if script is executed, not sourced
if [ "${0##*/}" = "ai-rizz" ]; then
	# Check if no arguments provided
	if [ $# -eq 0 ]; then
		cmd_help
		exit 0
	fi
	
	# Process manifest options first - no subshell to preserve variable updates
	PROCESSED_ARGS=""
	
	while [ $# -gt 0 ]; do
		case "$1" in
			-s|--skibidi|-f|--manifest)
				if [ $# -lt 2 ]; then
					error "Missing filename for $1 option"
				fi
				# Parse the provided filename to determine root and local names
				manifest_names=$(parse_manifest_filename_argument "$2")
				COMMIT_MANIFEST_FILE=$(echo "$manifest_names" | cut -f1 -d"	")
				LOCAL_MANIFEST_FILE=$(echo "$manifest_names" | cut -f2 -d"	")
				shift 2
				;;
			*)
				# Preserve the argument
				if [ -z "$PROCESSED_ARGS" ]; then
					PROCESSED_ARGS="$1"
				else
					PROCESSED_ARGS="$PROCESSED_ARGS $1"
				fi
				shift
				;;
		esac
	done
	
	# Set the processed arguments back for command processing
	# shellcheck disable=SC2086 # Intentional word splitting to restore original argument structure
	set -- $PROCESSED_ARGS
	
	# Initialize ai-rizz state for production use
	initialize_ai_rizz
	
	# Parse command
	main_command=$1
	shift

	case "${main_command}" in
	init)
		cmd_init "$@"
		;;
	deinit)
		cmd_deinit "$@"
		;;
	list)
		cmd_list "$@"
		;;
	add)
		if [ $# -eq 0 ]; then
			show_command_usage_error "Missing type: 'rule' or 'ruleset'" "ai-rizz add rule example-rule"
		fi
		
		main_type=$1
		shift
		
		case "${main_type}" in
			rule)
				if [ $# -eq 0 ]; then
					show_command_usage_error "Missing rule name" "ai-rizz add rule example-rule [--local|--commit]"
				fi
				cmd_add_rule "$@"
				;;
			ruleset)
				if [ $# -eq 0 ]; then
					show_command_usage_error "Missing ruleset name" "ai-rizz add ruleset example-ruleset [--local|--commit]"
				fi
				cmd_add_ruleset "$@"
				;;
			*)
				show_command_usage_error "Invalid type: ${main_type}. Must be 'rule' or 'ruleset'" "ai-rizz add rule example-rule\nai-rizz add ruleset example-ruleset"
				;;
		esac
		;;
	remove)
		if [ $# -eq 0 ]; then
			show_command_usage_error "Missing type: 'rule' or 'ruleset'" "ai-rizz remove rule example-rule"
		fi
		
		main_type=$1
		shift
		
		case "${main_type}" in
			rule)
				if [ $# -eq 0 ]; then
					 show_command_usage_error "Missing rule name" "ai-rizz remove rule example-rule"
				fi
				cmd_remove_rule "$@"
				;;
			ruleset)
				if [ $# -eq 0 ]; then
					show_command_usage_error "Missing ruleset name" "ai-rizz remove ruleset example-ruleset"
				fi
				cmd_remove_ruleset "$@"
				;;
			*)
				show_command_usage_error "Invalid type: ${main_type}. Must be 'rule' or 'ruleset'" "ai-rizz remove rule example-rule\nai-rizz remove ruleset example-ruleset"
				;;
		esac
		;;
	sync)
		cmd_sync "$@"
		;;
	help)
		cmd_help "$@"
		;;
	*)
		show_command_usage_error "Unknown command: ${main_command}" "ai-rizz init https://github.com/user/rules.git --local"
		;;
	esac
fi
