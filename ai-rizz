#!/bin/sh
# ai-rizz - A CLI tool to manage rules and rulesets  
# POSIX compliant shell script

set -e  # Exit on error

# Configuration constants
COMMIT_MANIFEST_FILE="ai-rizz.inf"
LOCAL_MANIFEST_FILE="ai-rizz.local.inf"
SHARED_DIR="shared"
LOCAL_DIR="local" 
CONFIG_DIR="$HOME/.config/ai-rizz"
REPO_DIR="$CONFIG_DIR/repo"
DEFAULT_TARGET_DIR=".cursor/rules"

# Mode state (set once during initialization, read-only afterward)
HAS_COMMIT_MODE=false
HAS_LOCAL_MODE=false

# Cached manifest metadata (set during initialization for efficiency)
COMMIT_SOURCE_REPO=""
LOCAL_SOURCE_REPO=""
COMMIT_TARGET_DIR=""
LOCAL_TARGET_DIR=""

# Display formatting variables  
COMMITTED_GLYPH="●"
UNINSTALLED_GLYPH="○"
LOCAL_GLYPH="◐"       # For Phase 3 (list command)

# Utilities
# =========

# Print error to stderr and exit
error() {
  echo "Error: $1" >&2
  exit "${2:-1}"
}

# Print warning to stderr
warn() {
  echo "Warning: $1" >&2
}

# Read and validate manifest file
# Sets: SOURCE_REPO, TARGET_DIR, MANIFEST_ENTRIES
read_manifest() {
  if [ ! -f "$MANIFEST_FILE" ]; then
    error "Manifest file '$MANIFEST_FILE' not found"
  fi
  
  # Read first line to get source repo and target dir
  read -r first_line < "$MANIFEST_FILE"
  
  # Check if it has the correct format (tab-separated)
  if ! echo "$first_line" | grep -q "	"; then
    error "Invalid manifest format: First line must be 'source_repo<tab>target_dir'"
  fi
  
  # Extract the source repo and target dir
  SOURCE_REPO=$(echo "$first_line" | cut -f1)
  TARGET_DIR=$(echo "$first_line" | cut -f2)
  
  # Read the rest of the manifest file
  MANIFEST_ENTRIES=""
  while IFS= read -r line; do
    if [ -n "$line" ] && [ "$line" != "$first_line" ]; then
      MANIFEST_ENTRIES="$MANIFEST_ENTRIES
$line"
    fi
  done < "$MANIFEST_FILE"
  
  # Trim leading newline
  MANIFEST_ENTRIES=$(echo "$MANIFEST_ENTRIES" | sed '/./,$!d')
  
  return 0
}

# Write manifest file
write_manifest() {
  if [ -z "$SOURCE_REPO" ] || [ -z "$TARGET_DIR" ]; then
    error "SOURCE_REPO and TARGET_DIR must be set before writing manifest"
  fi
  
  # Write the first line
  echo "$SOURCE_REPO	$TARGET_DIR" > "$MANIFEST_FILE"
  
  # Write the rest of the entries
  if [ -n "$MANIFEST_ENTRIES" ]; then
    echo "$MANIFEST_ENTRIES" >> "$MANIFEST_FILE"
  fi
  
  return 0
}

# Add entry to manifest
add_manifest_entry() {
  entry="$1"
  
  # Check if entry already exists
  if echo "$MANIFEST_ENTRIES" | grep -q "^$entry$"; then
    return 0  # Already exists, nothing to do
  fi
  
  # Add the entry
  if [ -z "$MANIFEST_ENTRIES" ]; then
    MANIFEST_ENTRIES="$entry"
  else
    MANIFEST_ENTRIES="$MANIFEST_ENTRIES
$entry"
  fi
  
  return 0
}

# Remove entry from manifest
remove_manifest_entry() {
  entry="$1"
  
  # Remove the entry
  MANIFEST_ENTRIES=$(echo "$MANIFEST_ENTRIES" | grep -v "^$entry$")
  
  return 0
}

# Progressive Manifest Utilities  
# ==============================

# Read manifest metadata line (returns "source_repo\ttarget_dir" via stdout)
read_manifest_metadata() {
    manifest_file="$1"
    
    if [ ! -f "$manifest_file" ]; then
        return 1
    fi
    
    # Read first line
    read -r first_line < "$manifest_file"
    
    # Validate format
    if ! echo "$first_line" | grep -q "	"; then
        error "Invalid manifest format in $manifest_file: First line must be 'source_repo<tab>target_dir'"
    fi
    
    echo "$first_line"
}

# Read manifest entries (returns entries via stdout, one per line)
read_manifest_entries() {
    manifest_file="$1"
    
    if [ ! -f "$manifest_file" ]; then
        return 1
    fi
    
    # Skip first line (metadata), return rest (handle empty manifests gracefully)
    tail -n +2 "$manifest_file" | grep -v '^$' || true
}

# Write manifest with metadata and entries from stdin
write_manifest_with_entries() {
    manifest_file="$1"
    source_repo="$2"
    target_dir="$3"
    
    # Write header
    echo "$source_repo	$target_dir" > "$manifest_file"
    
    # Append entries from stdin (if any)
    cat >> "$manifest_file"
}

# Add entry to manifest file
add_manifest_entry_to_file() {
    manifest_file="$1"
    entry="$2"
    
    # Check if entry already exists
    if [ -f "$manifest_file" ]; then
        if read_manifest_entries "$manifest_file" | grep -q "^$entry$"; then
            return 0  # Already exists
        fi
    fi
    
    # Add the entry
    echo "$entry" >> "$manifest_file"
}

# Remove entry from manifest file
remove_manifest_entry_from_file() {
    manifest_file="$1"
    entry="$2"
    
    if [ ! -f "$manifest_file" ]; then
        return 0  # Nothing to remove
    fi
    
    # Get metadata
    metadata=$(read_manifest_metadata "$manifest_file") || {
        error "Failed to read manifest metadata from $manifest_file"
    }
    
    # Get entries excluding the one to remove
    entries=$(read_manifest_entries "$manifest_file" | grep -v "^$entry$")
    
    # Rewrite manifest
    source_repo=$(echo "$metadata" | cut -f1)
    target_dir=$(echo "$metadata" | cut -f2)
    
    echo "$entries" | write_manifest_with_entries "$manifest_file" "$source_repo" "$target_dir"
}

# Get any available manifest metadata (for lazy initialization)
get_any_manifest_metadata() {
    # Try commit manifest first
    if [ -f "$COMMIT_MANIFEST_FILE" ]; then
        read_manifest_metadata "$COMMIT_MANIFEST_FILE"
        return $?
    fi
    
    # Try local manifest
    if [ -f "$LOCAL_MANIFEST_FILE" ]; then
        read_manifest_metadata "$LOCAL_MANIFEST_FILE"
        return $?
    fi
    
    # No manifests available
    return 1
}

# Clone or update a git repository
git_sync() {
  repo_url="$1"
  
  # Ensure config directory exists
  mkdir -p "$CONFIG_DIR"
  
  # Clone/update permanent repository
  if [ ! -d "$CONFIG_DIR/repo" ]; then
    git clone "$repo_url" "$CONFIG_DIR/repo" || error "Failed to clone repository: $repo_url"
  else
    (cd "$CONFIG_DIR/repo" && git pull) || error "Failed to update repository: $repo_url"
  fi
  
  return 0
}

# Detect if we're in local mode
is_local_mode() {
  # Check if .git directory exists
  if [ ! -d ".git" ]; then
    error "Not in a git repository"
  fi
  
  # Check if target directory is in .git/info/exclude
  if [ -f ".git/info/exclude" ] && grep -q "$TARGET_DIR" ".git/info/exclude"; then
    return 0  # true, local mode
  fi
  
  return 1  # false, commit mode
}

# Git Exclude Management  
# ======================

# Update .git/info/exclude for specific paths
update_git_exclude() {
    path="$1"
    action="$2"  # "add" or "remove"
    
    # Create .git/info directory if it doesn't exist
    mkdir -p ".git/info"
    
    # Create exclude file if it doesn't exist  
    touch ".git/info/exclude"
    
    case "$action" in
        add)
            if ! grep -q "^$path$" ".git/info/exclude"; then
                echo "$path" >> ".git/info/exclude"
            fi
            ;;
        remove)
            # Create a temporary file
            tmp_file=$(mktemp)
            # Filter out the path
            grep -v "^$path$" ".git/info/exclude" > "$tmp_file"
            # Replace the original file
            cat "$tmp_file" > ".git/info/exclude"
            # Remove the temporary file
            rm -f "$tmp_file"
            ;;
        *)
            error "Invalid action: $action. Must be 'add' or 'remove'"
            ;;
    esac
}

# Setup git excludes for local mode
setup_local_mode_excludes() {
    target_dir="$1"
    
    update_git_exclude "$LOCAL_MANIFEST_FILE" "add"
    update_git_exclude "$target_dir/$LOCAL_DIR" "add"
}

# Remove all local mode excludes
remove_local_mode_excludes() {
    target_dir="$1"
    
    update_git_exclude "$LOCAL_MANIFEST_FILE" "remove"
    update_git_exclude "$target_dir/$LOCAL_DIR" "remove"
}

# Validate git exclude state matches mode configuration
validate_git_exclude_state() {
    target_dir="$1"
    
    if [ "$HAS_LOCAL_MODE" = "true" ]; then
        # Local mode should be excluded
        if [ ! -f ".git/info/exclude" ] || ! grep -q "^$LOCAL_MANIFEST_FILE$" ".git/info/exclude"; then
            warn "Local manifest file not in git exclude (should be git-ignored)"
        fi
        if [ ! -f ".git/info/exclude" ] || ! grep -q "^$target_dir/$LOCAL_DIR$" ".git/info/exclude"; then
            warn "Local directory not in git exclude (should be git-ignored)"
        fi
    fi
    
    if [ "$HAS_COMMIT_MODE" = "true" ]; then
        # Commit mode should NOT be excluded
        if [ -f ".git/info/exclude" ] && grep -q "^$COMMIT_MANIFEST_FILE$" ".git/info/exclude"; then
            warn "Commit manifest file in git exclude (should be git-tracked)"
        fi
        if [ -f ".git/info/exclude" ] && grep -q "^$target_dir/$SHARED_DIR$" ".git/info/exclude"; then
            warn "Shared directory in git exclude (should be git-tracked)"
        fi
    fi
}

# Mode Detection Utilities
# ========================

# Phase 1: Minimal manifest file detection (no directory dependency)
detect_manifest_files_only() {
    # Quick check - just look for files, don't validate directories yet
    if [ -f "$LOCAL_MANIFEST_FILE" ]; then
        HAS_LOCAL_MODE=true
    else
        HAS_LOCAL_MODE=false
    fi
    
    if [ -f "$COMMIT_MANIFEST_FILE" ]; then
        HAS_COMMIT_MODE=true
    else
        HAS_COMMIT_MODE=false
    fi
}

# Phase 2: Full mode detection including directory validation
detect_initialized_modes() {
    HAS_LOCAL_MODE=false
    HAS_COMMIT_MODE=false
    
    # Get target directory or error if none available
    target_base=$(get_target_directory)
    
    # Check for local mode (manifest + directory)
    if [ -f "$LOCAL_MANIFEST_FILE" ] && [ -d "$target_base/$LOCAL_DIR" ]; then
        HAS_LOCAL_MODE=true
    fi
    
    # Check for commit mode (manifest + directory)  
    if [ -f "$COMMIT_MANIFEST_FILE" ] && [ -d "$target_base/$SHARED_DIR" ]; then
        HAS_COMMIT_MODE=true
    fi
}

# Get target directory from available manifests (returns via stdout)
get_target_directory() {
    # Try commit manifest first
    if [ -f "$COMMIT_MANIFEST_FILE" ]; then
        metadata=$(read_manifest_metadata "$COMMIT_MANIFEST_FILE") || {
            error "Failed to read commit manifest metadata"
        }
        echo "$metadata" | cut -f2
        return 0
    fi
    
    # Try local manifest
    if [ -f "$LOCAL_MANIFEST_FILE" ]; then
        metadata=$(read_manifest_metadata "$LOCAL_MANIFEST_FILE") || {
            error "Failed to read local manifest metadata"
        }
        echo "$metadata" | cut -f2
        return 0
    fi
    
    # No manifests available - use default only during initialization
    echo "$DEFAULT_TARGET_DIR"
}

# Cache manifest metadata in globals for efficiency
cache_manifest_metadata() {
    # Cache commit manifest metadata
    if [ -f "$COMMIT_MANIFEST_FILE" ]; then
        metadata=$(read_manifest_metadata "$COMMIT_MANIFEST_FILE") || {
            error "Failed to read commit manifest metadata"
        }
        COMMIT_SOURCE_REPO=$(echo "$metadata" | cut -f1)
        COMMIT_TARGET_DIR=$(echo "$metadata" | cut -f2)
    fi
    
    # Cache local manifest metadata
    if [ -f "$LOCAL_MANIFEST_FILE" ]; then
        metadata=$(read_manifest_metadata "$LOCAL_MANIFEST_FILE") || {
            error "Failed to read local manifest metadata"
        }
        LOCAL_SOURCE_REPO=$(echo "$metadata" | cut -f1)
        LOCAL_TARGET_DIR=$(echo "$metadata" | cut -f2)
    fi
}

# Test helper functions (for backward compatibility with test suite)
has_local_mode() {
    [ "$HAS_LOCAL_MODE" = "true" ]
}

has_commit_mode() {
    [ "$HAS_COMMIT_MODE" = "true" ]
}

# Legacy Migration Utilities
# ==========================

# Detect if repository needs migration from single-mode to progressive format
needs_migration() {
    # Legacy local mode: ai-rizz.inf exists but is in .git/info/exclude
    if [ -f "$COMMIT_MANIFEST_FILE" ] && [ -f ".git/info/exclude" ]; then
        if grep -q "^$COMMIT_MANIFEST_FILE$" ".git/info/exclude"; then
            return 0  # true, needs migration from legacy local
        fi
    fi
    
    return 1  # false, no migration needed
}

# Migrate legacy repository to progressive format  
migrate_legacy_repository_if_needed() {
    if ! needs_migration; then
        return 0  # No migration needed
    fi
    
    # Get target directory from existing manifest
    if [ -f "$COMMIT_MANIFEST_FILE" ]; then
        metadata=$(read_manifest_metadata "$COMMIT_MANIFEST_FILE") || {
            error "Failed to read legacy manifest metadata"
        }
        legacy_target_dir=$(echo "$metadata" | cut -f2)
        
        # Migrate legacy local mode to new format
        migrate_legacy_local_mode "$legacy_target_dir"
    fi
}

# Migrate from legacy local mode (ai-rizz.inf in git exclude) to new format
migrate_legacy_local_mode() {
    legacy_target_dir="$1"
    
    # 1. Rename manifest file
    mv "$COMMIT_MANIFEST_FILE" "$LOCAL_MANIFEST_FILE"
    
    # 2. Create local directory and move rules from shared directory
    mkdir -p "$legacy_target_dir/$LOCAL_DIR"
    
    if [ -d "$legacy_target_dir/$SHARED_DIR" ]; then
        if [ "$(ls -A "$legacy_target_dir/$SHARED_DIR" 2>/dev/null)" ]; then
            mv "$legacy_target_dir/$SHARED_DIR"/* "$legacy_target_dir/$LOCAL_DIR/"
        fi
        rmdir "$legacy_target_dir/$SHARED_DIR"
    fi
    
    # 3. Update .git/info/exclude entries
    update_git_exclude "$COMMIT_MANIFEST_FILE" "remove"
    update_git_exclude "$legacy_target_dir/$SHARED_DIR" "remove"  
    update_git_exclude "$LOCAL_MANIFEST_FILE" "add"
    update_git_exclude "$legacy_target_dir/$LOCAL_DIR" "add"
}

# Lazy Initialization Utilities
# =============================

# Initialize a mode that doesn't exist yet, copying metadata from existing mode
lazy_init_mode() {
    target_mode="$1"  # "local" or "commit"
    
    # Get metadata from any existing manifest
    metadata=$(get_any_manifest_metadata) || {
        error "No manifest available to copy metadata from for lazy initialization"
    }
    
    source_repo=$(echo "$metadata" | cut -f1)
    target_dir=$(echo "$metadata" | cut -f2)
    
    case "$target_mode" in
        local)
            # Create local mode structure
            mkdir -p "$target_dir/$LOCAL_DIR"
            
            # Write empty manifest with metadata
            echo "" | write_manifest_with_entries "$LOCAL_MANIFEST_FILE" "$source_repo" "$target_dir"
            
            # Update git excludes
            setup_local_mode_excludes "$target_dir"
            
            # Update mode state and cache
            HAS_LOCAL_MODE=true
            LOCAL_SOURCE_REPO="$source_repo"
            LOCAL_TARGET_DIR="$target_dir"
            ;;
            
        commit)
            # Create commit mode structure  
            mkdir -p "$target_dir/$SHARED_DIR"
            
            # Write empty manifest with metadata
            echo "" | write_manifest_with_entries "$COMMIT_MANIFEST_FILE" "$source_repo" "$target_dir"
            
            # Update mode state and cache
            HAS_COMMIT_MODE=true
            COMMIT_SOURCE_REPO="$source_repo"
            COMMIT_TARGET_DIR="$target_dir"
            ;;
            
        *)
            error "Invalid target mode: $target_mode. Must be 'local' or 'commit'"
            ;;
    esac
}

# Check if lazy initialization is needed for a mode (returns 0 if needed)
needs_lazy_init() {
    target_mode="$1"
    
    case "$target_mode" in
        local)
            [ "$HAS_LOCAL_MODE" = "false" ] && [ "$HAS_COMMIT_MODE" = "true" ]
            ;;
        commit)
            [ "$HAS_COMMIT_MODE" = "false" ] && [ "$HAS_LOCAL_MODE" = "true" ]
            ;;
        *)
            return 1
            ;;
    esac
}

# Commands
# ========

# Initialize the repository (progressive initialization)
cmd_init() {
    source_repo=""
    target_dir=""
    mode=""
    
    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            -d)
                target_dir="$2"
                shift 2
                ;;
            --local|-l)
                mode="local"
                shift
                ;;
            --commit|-c)
                mode="commit"
                shift
                ;;
            *)
                if [ -z "$source_repo" ]; then
                    source_repo="$1"
                    shift
                else
                    error "Unknown argument: $1"
                fi
                ;;
        esac
    done
    
    # Prompt for source repo if not provided
    if [ -z "$source_repo" ]; then
        printf "Source repository URL: "
        read -r source_repo
        if [ -z "$source_repo" ]; then
            error "Source repository URL is required"
        fi
    fi
    
    # Use default target directory if not provided
    if [ -z "$target_dir" ]; then
        target_dir="$DEFAULT_TARGET_DIR"
    fi
    
    # Prompt for mode if not provided
    if [ -z "$mode" ]; then
        printf "Mode [local/commit]: "
        read -r mode
        if [ -z "$mode" ]; then
            mode="local"
        fi
    fi
    
    # Validate mode
    case "$mode" in
        local|commit)
            ;;
        *)
            error "Invalid mode: $mode. Must be 'local' or 'commit'"
            ;;
    esac
    
    # Check if repository is already initialized in the requested mode
    case "$mode" in
        local)
            if [ "$HAS_LOCAL_MODE" = "true" ]; then
                error "Local mode already initialized. Use 'ai-rizz deinit --local' first."
            fi
            ;;
        commit)
            if [ "$HAS_COMMIT_MODE" = "true" ]; then
                error "Commit mode already initialized. Use 'ai-rizz deinit --commit' first."
            fi
            ;;
    esac
    
    # Ensure git repository context
    if [ ! -d ".git" ]; then
        error "Not in a git repository"
    fi
    
    # Clone/sync source repository first
    git_sync "$source_repo"
    
    # Initialize the requested mode
    case "$mode" in
        local)
            # Create local mode structure
            mkdir -p "$target_dir/$LOCAL_DIR"
            
            # Write empty manifest with metadata
            echo "" | write_manifest_with_entries "$LOCAL_MANIFEST_FILE" "$source_repo" "$target_dir"
            
            # Update git excludes
            setup_local_mode_excludes "$target_dir"
            
            # Update mode state and cache
            HAS_LOCAL_MODE=true
            LOCAL_SOURCE_REPO="$source_repo"
            LOCAL_TARGET_DIR="$target_dir"
            ;;
            
        commit)
            # Create commit mode structure  
            mkdir -p "$target_dir/$SHARED_DIR"
            
            # Write empty manifest with metadata
            echo "" | write_manifest_with_entries "$COMMIT_MANIFEST_FILE" "$source_repo" "$target_dir"
            
            # Update mode state and cache
            HAS_COMMIT_MODE=true
            COMMIT_SOURCE_REPO="$source_repo"
            COMMIT_TARGET_DIR="$target_dir"
            ;;
    esac
    
    echo "Initialized ai-rizz with source: $source_repo, target: $target_dir, mode: $mode"
    return 0
}

# Recursively remove empty parent directories
cleanup_empty_parents() {
  dir="$1"
  # Check if directory exists and is empty
  if [ -d "$dir" ] && [ -z "$(ls -A "$dir")" ]; then
    parent_dir=$(dirname "$dir")
    echo "Removing empty directory: $dir"
    rmdir "$dir"
    
    # Stop at filesystem root, home directory, or current directory
    if [ "$parent_dir" != "/" ] && [ "$parent_dir" != "$HOME" ] && [ "$parent_dir" != "." ]; then
      cleanup_empty_parents "$parent_dir"
    fi
  fi
}

# Deinitialize the repository (progressive mode-aware)
cmd_deinit() {
    force=false
    mode=""
    
    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            -y)
                force=true
                shift
                ;;
            --local|-l)
                mode="local"
                shift
                ;;
            --commit|-c)
                mode="commit"
                shift
                ;;
            --all|-a)
                mode="all"
                shift
                ;;
            *)
                error "Unknown argument: $1"
                ;;
        esac
    done
    
    # Check if any mode is initialized
    if [ "$HAS_COMMIT_MODE" = "false" ] && [ "$HAS_LOCAL_MODE" = "false" ]; then
        error "No ai-rizz configuration found."
    fi
    
    # Prompt for mode if not provided
    if [ -z "$mode" ]; then
        if [ "$HAS_LOCAL_MODE" = "true" ] && [ "$HAS_COMMIT_MODE" = "true" ]; then
            printf "Which mode to remove [local/commit/all]: "
            read -r mode
            if [ -z "$mode" ]; then
                mode="all"
            fi
        elif [ "$HAS_LOCAL_MODE" = "true" ]; then
            mode="local"
        elif [ "$HAS_COMMIT_MODE" = "true" ]; then
            mode="commit"
        fi
    fi
    
    # Validate mode
    case "$mode" in
        local|commit|all)
            ;;
        *)
            error "Invalid mode: $mode. Must be 'local', 'commit', or 'all'"
            ;;
    esac
    
    # Determine what to remove
    remove_local=false
    remove_commit=false
    
    case "$mode" in
        local)
            if [ "$HAS_LOCAL_MODE" = "false" ]; then
                error "Local mode not initialized"
            fi
            remove_local=true
            ;;
        commit)
            if [ "$HAS_COMMIT_MODE" = "false" ]; then
                error "Commit mode not initialized"
            fi
            remove_commit=true
            ;;
        all)
            remove_local=true
            remove_commit=true
            ;;
    esac
    
    # Build confirmation message
    items_to_remove=""
    if [ "$remove_local" = "true" ] && [ "$HAS_LOCAL_MODE" = "true" ]; then
        items_to_remove="$items_to_remove $LOCAL_MANIFEST_FILE $LOCAL_TARGET_DIR/$LOCAL_DIR"
    fi
    if [ "$remove_commit" = "true" ] && [ "$HAS_COMMIT_MODE" = "true" ]; then
        items_to_remove="$items_to_remove $COMMIT_MANIFEST_FILE $COMMIT_TARGET_DIR/$SHARED_DIR"
    fi
    
    # Confirm deletion
    if ! $force && [ -n "$items_to_remove" ]; then
        echo "This will delete:$items_to_remove"
        printf "Are you sure? [y/N] "
        read -r confirm
        if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
            echo "Canceled"
            return 0
        fi
    fi
    
    # Remove local mode
    if [ "$remove_local" = "true" ] && [ "$HAS_LOCAL_MODE" = "true" ]; then
        # Remove from git excludes
        remove_local_mode_excludes "$LOCAL_TARGET_DIR"
        
        # Remove files
        rm -rf "$LOCAL_TARGET_DIR/$LOCAL_DIR"
        rm -f "$LOCAL_MANIFEST_FILE"
        
        echo "Removed local mode configuration"
    fi
    
    # Remove commit mode
    if [ "$remove_commit" = "true" ] && [ "$HAS_COMMIT_MODE" = "true" ]; then
        # Remove files (no git exclude changes needed for commit mode)
        rm -rf "$COMMIT_TARGET_DIR/$SHARED_DIR"
        rm -f "$COMMIT_MANIFEST_FILE"
        
        echo "Removed commit mode configuration"
    fi
    
    # Clean up empty parent directories
    if [ "$remove_local" = "true" ] && [ "$HAS_LOCAL_MODE" = "true" ]; then
        parent_dir=$(dirname "$LOCAL_TARGET_DIR/$LOCAL_DIR")
        if [ "$parent_dir" != "." ] && [ "$parent_dir" != "/" ]; then
            cleanup_empty_parents "$parent_dir"
        fi
    fi
    
    if [ "$remove_commit" = "true" ] && [ "$HAS_COMMIT_MODE" = "true" ]; then
        parent_dir=$(dirname "$COMMIT_TARGET_DIR/$SHARED_DIR")
        if [ "$parent_dir" != "." ] && [ "$parent_dir" != "/" ]; then
            cleanup_empty_parents "$parent_dir"
        fi
    fi
    
    return 0
}

# List available rules and rulesets (multi-mode aware)
cmd_list() {
    # Check if any mode is initialized
    if [ "$HAS_COMMIT_MODE" = "false" ] && [ "$HAS_LOCAL_MODE" = "false" ]; then
        error "No ai-rizz configuration found. Run 'ai-rizz init' first."
    fi
    
    # Get source repo from any available mode
    source_repo=""
    if [ "$HAS_COMMIT_MODE" = "true" ]; then
        source_repo="$COMMIT_SOURCE_REPO"
    elif [ "$HAS_LOCAL_MODE" = "true" ]; then
        source_repo="$LOCAL_SOURCE_REPO"
    fi
    
    # Update source repository
    git_sync "$source_repo"
    
    # Helper function to check if an item is installed in any mode
    is_installed() {
        local item="$1"
        local status="uninstalled"
        
        # Check commit mode
        if [ "$HAS_COMMIT_MODE" = "true" ]; then
            if read_manifest_entries "$COMMIT_MANIFEST_FILE" 2>/dev/null | grep -q "^$item$"; then
                status="committed"
            fi
        fi
        
        # Check local mode (overrides commit status for display)
        if [ "$HAS_LOCAL_MODE" = "true" ]; then
            if read_manifest_entries "$LOCAL_MANIFEST_FILE" 2>/dev/null | grep -q "^$item$"; then
                status="local"
            fi
        fi
        
        echo "$status"
    }
    
    # Display rules
    echo "Available rules:"
    rules=$(find "$REPO_DIR/rules" -name "*.mdc" | sort 2>/dev/null)
    if [ -z "$rules" ]; then
        echo "  No rules found"
    else
        for rule in $rules; do
            rule_name=$(basename "$rule")
            rule_path="rules/$rule_name"
            status=$(is_installed "$rule_path")
            
            case "$status" in
                committed)
                    printf "  %s %s\n" "$COMMITTED_GLYPH" "$rule_name"
                    ;;
                local)
                    printf "  %s %s\n" "$LOCAL_GLYPH" "$rule_name"
                    ;;
                *)
                    printf "  %s %s\n" "$UNINSTALLED_GLYPH" "$rule_name"
                    ;;
            esac
        done
    fi
    echo ""
    
    # Display rulesets
    echo "Available rulesets:"
    rulesets=$(find "$REPO_DIR/rulesets" -mindepth 1 -maxdepth 1 -type d | sort 2>/dev/null)
    if [ -z "$rulesets" ]; then
        echo "  No rulesets found"
    else
        for ruleset in $rulesets; do
            ruleset_name=$(basename "$ruleset")
            ruleset_path="rulesets/$ruleset_name"
            status=$(is_installed "$ruleset_path")
            
            # Display ruleset with installation status
            case "$status" in
                committed)
                    printf "  %s %s\n" "$COMMITTED_GLYPH" "$ruleset_name"
                    ;;
                local)
                    printf "  %s %s\n" "$LOCAL_GLYPH" "$ruleset_name"
                    ;;
                *)
                    printf "  %s %s\n" "$UNINSTALLED_GLYPH" "$ruleset_name"
                    ;;
            esac
            
            # Use tree to display ruleset contents
            if [ -d "$ruleset" ]; then
                # Check if tree command exists
                if command -v tree >/dev/null 2>&1; then
                    (cd "$ruleset" && tree -L 1 --noreport) | tail -n +2 | sed 's/^/    /' | sed 's/ -> .*$//'
                else
                    # Fallback if tree is not available
                    find "$ruleset" -maxdepth 1 -name "*.mdc" -exec basename {} \; | sort | sed 's/^/    ├── /'
                fi
            fi
        done
    fi
    
    return 0
}

# Add rule(s) to the repository (progressive mode-aware)
cmd_add_rule() {
    mode=""
    rules=""
    
    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --local|-l)
                mode="local"
                shift
                ;;
            --commit|-c)
                mode="commit"
                shift
                ;;
            *)
                if [ -z "$rules" ]; then
                    rules="$1"
                else
                    rules="$rules $1"
                fi
                shift
                ;;
        esac
    done
    
    # Check if any mode is initialized
    if [ "$HAS_COMMIT_MODE" = "false" ] && [ "$HAS_LOCAL_MODE" = "false" ]; then
        error "No ai-rizz configuration found. Run 'ai-rizz init' first."
    fi
    
    # Smart mode selection
    if [ -z "$mode" ]; then
        if [ "$HAS_LOCAL_MODE" = "true" ] && [ "$HAS_COMMIT_MODE" = "false" ]; then
            mode="local"
        elif [ "$HAS_COMMIT_MODE" = "true" ] && [ "$HAS_LOCAL_MODE" = "false" ]; then
            mode="commit"
        else
            error "Both modes available. Please specify --local or --commit flag."
        fi
    fi
    
    # Check if lazy initialization is needed
    if needs_lazy_init "$mode"; then
        lazy_init_mode "$mode"
    fi
    
    # Select manifest and target based on mode
    case "$mode" in
        local)
            manifest_file="$LOCAL_MANIFEST_FILE"
            target_dir="$LOCAL_TARGET_DIR/$LOCAL_DIR"
            source_repo="$LOCAL_SOURCE_REPO"
            ;;
        commit)
            manifest_file="$COMMIT_MANIFEST_FILE"
            target_dir="$COMMIT_TARGET_DIR/$SHARED_DIR"
            source_repo="$COMMIT_SOURCE_REPO"
            ;;
        *)
            error "Invalid mode: $mode"
            ;;
    esac
    
    # Update source repository
    git_sync "$source_repo"
    
    # Process each rule
    for rule in $rules; do
        # Add .mdc extension if not present
        case "$rule" in
            *".mdc") ;;  # Already has extension
            *) rule="${rule}.mdc" ;;  # Add extension
        esac
        
        rule_path="rules/$rule"
        
        # Check if rule exists in source repo
        if [ ! -f "$REPO_DIR/$rule_path" ]; then
            warn "Rule not found: $rule_path"
            continue
        fi
        
        # Check if rule exists in opposite mode (conflict resolution)
        case "$mode" in
            local)
                if [ "$HAS_COMMIT_MODE" = "true" ]; then
                    if read_manifest_entries "$COMMIT_MANIFEST_FILE" | grep -q "^$rule_path$"; then
                        # Remove from commit mode, add to local mode
                        remove_manifest_entry_from_file "$COMMIT_MANIFEST_FILE" "$rule_path"
                    fi
                fi
                ;;
            commit)
                if [ "$HAS_LOCAL_MODE" = "true" ]; then
                    if read_manifest_entries "$LOCAL_MANIFEST_FILE" | grep -q "^$rule_path$"; then
                        # Remove from local mode, add to commit mode
                        remove_manifest_entry_from_file "$LOCAL_MANIFEST_FILE" "$rule_path"
                    fi
                fi
                ;;
        esac
        
        # Add to target manifest
        add_manifest_entry_to_file "$manifest_file" "$rule_path"
        
        echo "Added rule: $rule_path"
    done
    
    # Sync to update file locations
    sync_all_modes
    
    return 0
}

# Add ruleset(s) to the repository (progressive mode-aware)
cmd_add_ruleset() {
    mode=""
    rulesets=""
    
    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --local|-l)
                mode="local"
                shift
                ;;
            --commit|-c)
                mode="commit"
                shift
                ;;
            *)
                if [ -z "$rulesets" ]; then
                    rulesets="$1"
                else
                    rulesets="$rulesets $1"
                fi
                shift
                ;;
        esac
    done
    
    # Check if any mode is initialized
    if [ "$HAS_COMMIT_MODE" = "false" ] && [ "$HAS_LOCAL_MODE" = "false" ]; then
        error "No ai-rizz configuration found. Run 'ai-rizz init' first."
    fi
    
    # Smart mode selection
    if [ -z "$mode" ]; then
        if [ "$HAS_LOCAL_MODE" = "true" ] && [ "$HAS_COMMIT_MODE" = "false" ]; then
            mode="local"
        elif [ "$HAS_COMMIT_MODE" = "true" ] && [ "$HAS_LOCAL_MODE" = "false" ]; then
            mode="commit"
        else
            error "Both modes available. Please specify --local or --commit flag."
        fi
    fi
    
    # Check if lazy initialization is needed
    if needs_lazy_init "$mode"; then
        lazy_init_mode "$mode"
    fi
    
    # Select manifest and target based on mode
    case "$mode" in
        local)
            manifest_file="$LOCAL_MANIFEST_FILE"
            source_repo="$LOCAL_SOURCE_REPO"
            ;;
        commit)
            manifest_file="$COMMIT_MANIFEST_FILE"
            source_repo="$COMMIT_SOURCE_REPO"
            ;;
        *)
            error "Invalid mode: $mode"
            ;;
    esac
    
    # Update source repository
    git_sync "$source_repo"
    
    # Process each ruleset
    for ruleset in $rulesets; do
        ruleset_path="rulesets/$ruleset"
        
        # Check if ruleset exists in source repo
        if [ ! -d "$REPO_DIR/$ruleset_path" ]; then
            warn "Ruleset not found: $ruleset_path"
            continue
        fi
        
        # Check if ruleset exists in opposite mode (conflict resolution)
        case "$mode" in
            local)
                if [ "$HAS_COMMIT_MODE" = "true" ]; then
                    if read_manifest_entries "$COMMIT_MANIFEST_FILE" | grep -q "^$ruleset_path$"; then
                        # Remove from commit mode, add to local mode
                        remove_manifest_entry_from_file "$COMMIT_MANIFEST_FILE" "$ruleset_path"
                    fi
                fi
                ;;
            commit)
                if [ "$HAS_LOCAL_MODE" = "true" ]; then
                    if read_manifest_entries "$LOCAL_MANIFEST_FILE" | grep -q "^$ruleset_path$"; then
                        # Remove from local mode, add to commit mode
                        remove_manifest_entry_from_file "$LOCAL_MANIFEST_FILE" "$ruleset_path"
                    fi
                fi
                ;;
        esac
        
        # Add to target manifest
        add_manifest_entry_to_file "$manifest_file" "$ruleset_path"
        
        echo "Added ruleset: $ruleset_path"
    done
    
    # Sync to update file locations
    sync_all_modes
    
    return 0
}

# Remove rule(s) from the repository (mode-aware)
cmd_remove_rule() {
    # Check if any mode is initialized
    if [ "$HAS_COMMIT_MODE" = "false" ] && [ "$HAS_LOCAL_MODE" = "false" ]; then
        error "No ai-rizz configuration found. Run 'ai-rizz init' first."
    fi
    
    # Process each rule
    for rule in "$@"; do
        # Add .mdc extension if not present
        case "$rule" in
            *".mdc") ;;  # Already has extension
            *) rule="${rule}.mdc" ;;  # Add extension
        esac
        
        rule_path="rules/$rule"
        removed=false
        
        # Remove from whichever mode contains it
        if [ "$HAS_LOCAL_MODE" = "true" ]; then
            if read_manifest_entries "$LOCAL_MANIFEST_FILE" | grep -q "^$rule_path$"; then
                remove_manifest_entry_from_file "$LOCAL_MANIFEST_FILE" "$rule_path"
                removed=true
            fi
        fi
        
        if [ "$HAS_COMMIT_MODE" = "true" ]; then
            if read_manifest_entries "$COMMIT_MANIFEST_FILE" | grep -q "^$rule_path$"; then
                remove_manifest_entry_from_file "$COMMIT_MANIFEST_FILE" "$rule_path"
                removed=true
            fi
        fi
        
        if [ "$removed" = "true" ]; then
            echo "Removed rule: $rule_path"
        else
            warn "Rule not found in any mode: $rule_path"
        fi
    done
    
    # Sync to ensure proper cleanup
    sync_all_modes
    
    return 0
}

# Remove ruleset(s) from the repository (mode-aware)
cmd_remove_ruleset() {
    # Check if any mode is initialized
    if [ "$HAS_COMMIT_MODE" = "false" ] && [ "$HAS_LOCAL_MODE" = "false" ]; then
        error "No ai-rizz configuration found. Run 'ai-rizz init' first."
    fi
    
    # Process each ruleset
    for ruleset in "$@"; do
        ruleset_path="rulesets/$ruleset"
        removed=false
        
        # Remove from whichever mode contains it
        if [ "$HAS_LOCAL_MODE" = "true" ]; then
            if read_manifest_entries "$LOCAL_MANIFEST_FILE" | grep -q "^$ruleset_path$"; then
                remove_manifest_entry_from_file "$LOCAL_MANIFEST_FILE" "$ruleset_path"
                removed=true
            fi
        fi
        
        if [ "$HAS_COMMIT_MODE" = "true" ]; then
            if read_manifest_entries "$COMMIT_MANIFEST_FILE" | grep -q "^$ruleset_path$"; then
                remove_manifest_entry_from_file "$COMMIT_MANIFEST_FILE" "$ruleset_path"
                removed=true
            fi
        fi
        
        if [ "$removed" = "true" ]; then
            echo "Removed ruleset: $ruleset_path"
        else
            warn "Ruleset not found in any mode: $ruleset_path"
        fi
    done
    
    # Sync to ensure proper cleanup
    sync_all_modes
    
    return 0
}

# Sync all available manifests to their target directories
sync_all_modes() {
    sync_success=true
    
    # Sync commit mode if initialized
    if [ "$HAS_COMMIT_MODE" = "true" ]; then
        sync_manifest_to_directory "$COMMIT_MANIFEST_FILE" "$COMMIT_TARGET_DIR/$SHARED_DIR" || sync_success=false
    fi
    
    # Sync local mode if initialized  
    if [ "$HAS_LOCAL_MODE" = "true" ]; then
        sync_manifest_to_directory "$LOCAL_MANIFEST_FILE" "$LOCAL_TARGET_DIR/$LOCAL_DIR" || sync_success=false
    fi
    
    # Handle any cleanup needed
    if [ "$sync_success" = "false" ]; then
        handle_sync_cleanup
    fi
}

# Sync a single manifest to its target directory
sync_manifest_to_directory() {
    manifest_file="$1"
    target_directory="$2"
    
    if [ ! -f "$manifest_file" ]; then
        return 0  # No manifest to sync
    fi
    
    # Create target directory if needed
    mkdir -p "$target_directory"
    
    # Get entries from manifest
    entries=$(read_manifest_entries "$manifest_file") || {
        warn "Failed to read entries from $manifest_file"
        return 1
    }
    
    # Copy each entry
    if [ -n "$entries" ]; then
        echo "$entries" | while IFS= read -r entry; do
            if [ -n "$entry" ]; then
                copy_entry_to_target "$entry" "$target_directory" || return 1
            fi
        done
    fi
}

# Copy a single entry (rule or ruleset) to target directory
copy_entry_to_target() {
    entry="$1"
    target_directory="$2"
    
    source_path="$REPO_DIR/$entry"
    
    if [ -f "$source_path" ]; then
        # Single file (rule)
        cp "$source_path" "$target_directory/"
    elif [ -d "$source_path" ]; then
        # Directory (ruleset) - copy recursively
        cp -r "$source_path" "$target_directory/"
    else
        warn "Entry not found in repository: $entry"
        return 1
    fi
}

# Handle cleanup after sync issues
handle_sync_cleanup() {
    # Re-cache manifest metadata to ensure consistency
    cache_manifest_metadata
    
    # Validate git exclude state
    target_dir=$(get_target_directory)
    validate_git_exclude_state "$target_dir"
}

# Sync the repository (multi-mode aware)
cmd_sync() {
    # Check if any mode is initialized
    if [ "$HAS_COMMIT_MODE" = "false" ] && [ "$HAS_LOCAL_MODE" = "false" ]; then
        error "No ai-rizz configuration found. Run 'ai-rizz init' first."
    fi
    
    # Get source repo from any available manifest
    source_repo=""
    if [ -n "$COMMIT_SOURCE_REPO" ]; then
        source_repo="$COMMIT_SOURCE_REPO"
    elif [ -n "$LOCAL_SOURCE_REPO" ]; then
        source_repo="$LOCAL_SOURCE_REPO"
    fi
    
    # Sync repository first
    if [ -n "$source_repo" ]; then
        git_sync "$source_repo"
    fi
    
    # Sync all initialized modes
    sync_all_modes
    
    echo "Sync complete"
    return 0
}



# Help command
cmd_help() {
  cat <<EOF
Usage: ai-rizz <command> [command-specific options]

Available commands:
  init [<source_repo>]     Initialize the repository
  deinit                   Deinitialize the repository
  list                     List available rules and rulesets
  add rule <rule>...       Add rule(s) to the repository (.mdc extension optional)
  add ruleset <ruleset>... Add ruleset(s) to the repository
  remove rule <rule>...    Remove rule(s) from the repository (.mdc extension optional)
  remove ruleset <ruleset>... Remove ruleset(s) from the repository
  sync                     Sync the repository
  help                     Show this help

Command-specific options:
  init options:
    -d <target_dir>        Target directory (default: .cursor/rules)
    --local, -l            Use local mode (ignore files)
    --commit, -c           Use commit mode (commit files)

  deinit options:
    -y                     Skip confirmation prompts
EOF
  return 0
}

# Initialization
# ==============

# Initialize ai-rizz state at startup (two-phase to avoid circular dependencies)
initialize_ai_rizz() {
    # Phase 1: Minimal detection and migration (file-based only)
    detect_manifest_files_only
    migrate_legacy_repository_if_needed
    
    # Phase 2: Full initialization with directory checking  
    detect_initialized_modes
    cache_manifest_metadata
}

# Main
# ====

# Only run main code if script is executed, not sourced
if [ "${0##*/}" = "ai-rizz" ]; then
    # Check if no arguments provided
    if [ $# -eq 0 ]; then
        cmd_help
        exit 0
    fi
    
    # Initialize ai-rizz state for production use
    initialize_ai_rizz
    
    # Parse command
    command=$1
    shift

    case "$command" in
    init)
      cmd_init "$@"
      ;;
    deinit)
      cmd_deinit "$@"
      ;;
    list)
      cmd_list "$@"
      ;;
    add)
      if [ $# -eq 0 ]; then
        error "Missing type: 'rule' or 'ruleset'"
      fi
      
      type=$1
      shift
      
      case "$type" in
        rule)
          if [ $# -eq 0 ]; then
            error "Missing rule name"
          fi
          cmd_add_rule "$@"
          ;;
        ruleset)
          if [ $# -eq 0 ]; then
            error "Missing ruleset name"
          fi
          cmd_add_ruleset "$@"
          ;;
        *)
          error "Invalid type: $type. Must be 'rule' or 'ruleset'"
          ;;
      esac
      ;;
    remove)
      if [ $# -eq 0 ]; then
        error "Missing type: 'rule' or 'ruleset'"
      fi
      
      type=$1
      shift
      
      case "$type" in
        rule)
          if [ $# -eq 0 ]; then
            error "Missing rule name"
          fi
          cmd_remove_rule "$@"
          ;;
        ruleset)
          if [ $# -eq 0 ]; then
            error "Missing ruleset name"
          fi
          cmd_remove_ruleset "$@"
          ;;
        *)
          error "Invalid type: $type. Must be 'rule' or 'ruleset'"
          ;;
      esac
      ;;
    sync)
      cmd_sync "$@"
      ;;
    help)
      cmd_help "$@"
      ;;
    *)
      error "Unknown command: $command. Run 'ai-rizz help' for usage"
      ;;
  esac
fi
