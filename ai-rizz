#!/bin/sh
# ai-rizz - A CLI tool to manage rules and rulesets  
# POSIX compliant shell script

set -e  # Exit on error

# Configuration constants
COMMIT_MANIFEST_FILE="ai-rizz.inf"
LOCAL_MANIFEST_FILE="ai-rizz.local.inf"
SHARED_DIR="shared"
LOCAL_DIR="local" 
CONFIG_DIR="$HOME/.config/ai-rizz"
REPO_DIR="$CONFIG_DIR/repo"
DEFAULT_TARGET_DIR=".cursor/rules"

# Mode state (set once during initialization, read-only afterward)
HAS_COMMIT_MODE=false
HAS_LOCAL_MODE=false

# Cached manifest metadata (set during initialization for efficiency)
COMMIT_SOURCE_REPO=""
LOCAL_SOURCE_REPO=""
COMMIT_TARGET_DIR=""
LOCAL_TARGET_DIR=""

# Display formatting variables  
COMMITTED_GLYPH="●"
UNINSTALLED_GLYPH="○"
LOCAL_GLYPH="◐"       # For Phase 3 (list command)

# Utilities
# =========

# Print error to stderr and exit
error() {
  echo "Error: $1" >&2
  exit "${2:-1}"
}

# Print warning to stderr
warn() {
  echo "Warning: $1" >&2
}

# Read and validate manifest file
# Sets: SOURCE_REPO, TARGET_DIR, MANIFEST_ENTRIES
read_manifest() {
  if [ ! -f "$MANIFEST_FILE" ]; then
    error "Manifest file '$MANIFEST_FILE' not found"
  fi
  
  # Read first line to get source repo and target dir
  read -r first_line < "$MANIFEST_FILE"
  
  # Check if it has the correct format (tab-separated)
  if ! echo "$first_line" | grep -q "	"; then
    error "Invalid manifest format: First line must be 'source_repo<tab>target_dir'"
  fi
  
  # Extract the source repo and target dir
  SOURCE_REPO=$(echo "$first_line" | cut -f1)
  TARGET_DIR=$(echo "$first_line" | cut -f2)
  
  # Read the rest of the manifest file
  MANIFEST_ENTRIES=""
  while IFS= read -r line; do
    if [ -n "$line" ] && [ "$line" != "$first_line" ]; then
      MANIFEST_ENTRIES="$MANIFEST_ENTRIES
$line"
    fi
  done < "$MANIFEST_FILE"
  
  # Trim leading newline
  MANIFEST_ENTRIES=$(echo "$MANIFEST_ENTRIES" | sed '/./,$!d')
  
  return 0
}

# Write manifest file
write_manifest() {
  if [ -z "$SOURCE_REPO" ] || [ -z "$TARGET_DIR" ]; then
    error "SOURCE_REPO and TARGET_DIR must be set before writing manifest"
  fi
  
  # Write the first line
  echo "$SOURCE_REPO	$TARGET_DIR" > "$MANIFEST_FILE"
  
  # Write the rest of the entries
  if [ -n "$MANIFEST_ENTRIES" ]; then
    echo "$MANIFEST_ENTRIES" >> "$MANIFEST_FILE"
  fi
  
  return 0
}

# Add entry to manifest
add_manifest_entry() {
  entry="$1"
  
  # Check if entry already exists
  if echo "$MANIFEST_ENTRIES" | grep -q "^$entry$"; then
    return 0  # Already exists, nothing to do
  fi
  
  # Add the entry
  if [ -z "$MANIFEST_ENTRIES" ]; then
    MANIFEST_ENTRIES="$entry"
  else
    MANIFEST_ENTRIES="$MANIFEST_ENTRIES
$entry"
  fi
  
  return 0
}

# Remove entry from manifest
remove_manifest_entry() {
  entry="$1"
  
  # Remove the entry
  MANIFEST_ENTRIES=$(echo "$MANIFEST_ENTRIES" | grep -v "^$entry$")
  
  return 0
}

# Progressive Manifest Utilities  
# ==============================

# Read manifest metadata line (returns "source_repo\ttarget_dir" via stdout)
read_manifest_metadata() {
    manifest_file="$1"
    
    if [ ! -f "$manifest_file" ]; then
        return 1
    fi
    
    # Read first line
    read -r first_line < "$manifest_file"
    
    # Validate format
    if ! echo "$first_line" | grep -q "	"; then
        error "Invalid manifest format in $manifest_file: First line must be 'source_repo<tab>target_dir'"
    fi
    
    echo "$first_line"
}

# Read manifest entries (returns entries via stdout, one per line)
read_manifest_entries() {
    manifest_file="$1"
    
    if [ ! -f "$manifest_file" ]; then
        return 1
    fi
    
    # Skip first line (metadata), return rest
    tail -n +2 "$manifest_file" | grep -v '^$'
}

# Write manifest with metadata and entries from stdin
write_manifest_with_entries() {
    manifest_file="$1"
    source_repo="$2"
    target_dir="$3"
    
    # Write header
    echo "$source_repo	$target_dir" > "$manifest_file"
    
    # Append entries from stdin (if any)
    cat >> "$manifest_file"
}

# Add entry to manifest file
add_manifest_entry_to_file() {
    manifest_file="$1"
    entry="$2"
    
    # Check if entry already exists
    if [ -f "$manifest_file" ]; then
        if read_manifest_entries "$manifest_file" | grep -q "^$entry$"; then
            return 0  # Already exists
        fi
    fi
    
    # Add the entry
    echo "$entry" >> "$manifest_file"
}

# Remove entry from manifest file
remove_manifest_entry_from_file() {
    manifest_file="$1"
    entry="$2"
    
    if [ ! -f "$manifest_file" ]; then
        return 0  # Nothing to remove
    fi
    
    # Get metadata
    metadata=$(read_manifest_metadata "$manifest_file") || {
        error "Failed to read manifest metadata from $manifest_file"
    }
    
    # Get entries excluding the one to remove
    entries=$(read_manifest_entries "$manifest_file" | grep -v "^$entry$")
    
    # Rewrite manifest
    source_repo=$(echo "$metadata" | cut -f1)
    target_dir=$(echo "$metadata" | cut -f2)
    
    echo "$entries" | write_manifest_with_entries "$manifest_file" "$source_repo" "$target_dir"
}

# Get any available manifest metadata (for lazy initialization)
get_any_manifest_metadata() {
    # Try commit manifest first
    if [ -f "$COMMIT_MANIFEST_FILE" ]; then
        read_manifest_metadata "$COMMIT_MANIFEST_FILE"
        return $?
    fi
    
    # Try local manifest
    if [ -f "$LOCAL_MANIFEST_FILE" ]; then
        read_manifest_metadata "$LOCAL_MANIFEST_FILE"
        return $?
    fi
    
    # No manifests available
    return 1
}

# Clone or update a git repository
git_sync() {
  repo_url="$1"
  
  # Ensure config directory exists
  mkdir -p "$CONFIG_DIR"
  
  # Clone/update permanent repository
  if [ ! -d "$CONFIG_DIR/repo" ]; then
    git clone "$repo_url" "$CONFIG_DIR/repo" || error "Failed to clone repository: $repo_url"
  else
    (cd "$CONFIG_DIR/repo" && git pull) || error "Failed to update repository: $repo_url"
  fi
  
  return 0
}

# Detect if we're in local mode
is_local_mode() {
  # Check if .git directory exists
  if [ ! -d ".git" ]; then
    error "Not in a git repository"
  fi
  
  # Check if target directory is in .git/info/exclude
  if [ -f ".git/info/exclude" ] && grep -q "$TARGET_DIR" ".git/info/exclude"; then
    return 0  # true, local mode
  fi
  
  return 1  # false, commit mode
}

# Git Exclude Management  
# ======================

# Update .git/info/exclude for specific paths
update_git_exclude() {
    path="$1"
    action="$2"  # "add" or "remove"
    
    # Create .git/info directory if it doesn't exist
    mkdir -p ".git/info"
    
    # Create exclude file if it doesn't exist  
    touch ".git/info/exclude"
    
    case "$action" in
        add)
            if ! grep -q "^$path$" ".git/info/exclude"; then
                echo "$path" >> ".git/info/exclude"
            fi
            ;;
        remove)
            # Create a temporary file
            tmp_file=$(mktemp)
            # Filter out the path
            grep -v "^$path$" ".git/info/exclude" > "$tmp_file"
            # Replace the original file
            cat "$tmp_file" > ".git/info/exclude"
            # Remove the temporary file
            rm -f "$tmp_file"
            ;;
        *)
            error "Invalid action: $action. Must be 'add' or 'remove'"
            ;;
    esac
}

# Setup git excludes for local mode
setup_local_mode_excludes() {
    target_dir="$1"
    
    update_git_exclude "$LOCAL_MANIFEST_FILE" "add"
    update_git_exclude "$target_dir/$LOCAL_DIR" "add"
}

# Remove all local mode excludes
remove_local_mode_excludes() {
    target_dir="$1"
    
    update_git_exclude "$LOCAL_MANIFEST_FILE" "remove"
    update_git_exclude "$target_dir/$LOCAL_DIR" "remove"
}

# Validate git exclude state matches mode configuration
validate_git_exclude_state() {
    target_dir="$1"
    
    if [ "$HAS_LOCAL_MODE" = "true" ]; then
        # Local mode should be excluded
        if [ ! -f ".git/info/exclude" ] || ! grep -q "^$LOCAL_MANIFEST_FILE$" ".git/info/exclude"; then
            warn "Local manifest file not in git exclude (should be git-ignored)"
        fi
        if [ ! -f ".git/info/exclude" ] || ! grep -q "^$target_dir/$LOCAL_DIR$" ".git/info/exclude"; then
            warn "Local directory not in git exclude (should be git-ignored)"
        fi
    fi
    
    if [ "$HAS_COMMIT_MODE" = "true" ]; then
        # Commit mode should NOT be excluded
        if [ -f ".git/info/exclude" ] && grep -q "^$COMMIT_MANIFEST_FILE$" ".git/info/exclude"; then
            warn "Commit manifest file in git exclude (should be git-tracked)"
        fi
        if [ -f ".git/info/exclude" ] && grep -q "^$target_dir/$SHARED_DIR$" ".git/info/exclude"; then
            warn "Shared directory in git exclude (should be git-tracked)"
        fi
    fi
}

# Mode Detection Utilities
# ========================

# Phase 1: Minimal manifest file detection (no directory dependency)
detect_manifest_files_only() {
    # Quick check - just look for files, don't validate directories yet
    if [ -f "$LOCAL_MANIFEST_FILE" ]; then
        HAS_LOCAL_MODE=true
    else
        HAS_LOCAL_MODE=false
    fi
    
    if [ -f "$COMMIT_MANIFEST_FILE" ]; then
        HAS_COMMIT_MODE=true
    else
        HAS_COMMIT_MODE=false
    fi
}

# Phase 2: Full mode detection including directory validation
detect_initialized_modes() {
    HAS_LOCAL_MODE=false
    HAS_COMMIT_MODE=false
    
    # Get target directory or error if none available
    target_base=$(get_target_directory)
    
    # Check for local mode (manifest + directory)
    if [ -f "$LOCAL_MANIFEST_FILE" ] && [ -d "$target_base/$LOCAL_DIR" ]; then
        HAS_LOCAL_MODE=true
    fi
    
    # Check for commit mode (manifest + directory)  
    if [ -f "$COMMIT_MANIFEST_FILE" ] && [ -d "$target_base/$SHARED_DIR" ]; then
        HAS_COMMIT_MODE=true
    fi
}

# Get target directory from available manifests (returns via stdout)
get_target_directory() {
    # Try commit manifest first
    if [ -f "$COMMIT_MANIFEST_FILE" ]; then
        metadata=$(read_manifest_metadata "$COMMIT_MANIFEST_FILE") || {
            error "Failed to read commit manifest metadata"
        }
        echo "$metadata" | cut -f2
        return 0
    fi
    
    # Try local manifest
    if [ -f "$LOCAL_MANIFEST_FILE" ]; then
        metadata=$(read_manifest_metadata "$LOCAL_MANIFEST_FILE") || {
            error "Failed to read local manifest metadata"
        }
        echo "$metadata" | cut -f2
        return 0
    fi
    
    # No manifests available - use default only during initialization
    echo "$DEFAULT_TARGET_DIR"
}

# Cache manifest metadata in globals for efficiency
cache_manifest_metadata() {
    # Cache commit manifest metadata
    if [ -f "$COMMIT_MANIFEST_FILE" ]; then
        metadata=$(read_manifest_metadata "$COMMIT_MANIFEST_FILE") || {
            error "Failed to read commit manifest metadata"
        }
        COMMIT_SOURCE_REPO=$(echo "$metadata" | cut -f1)
        COMMIT_TARGET_DIR=$(echo "$metadata" | cut -f2)
    fi
    
    # Cache local manifest metadata
    if [ -f "$LOCAL_MANIFEST_FILE" ]; then
        metadata=$(read_manifest_metadata "$LOCAL_MANIFEST_FILE") || {
            error "Failed to read local manifest metadata"
        }
        LOCAL_SOURCE_REPO=$(echo "$metadata" | cut -f1)
        LOCAL_TARGET_DIR=$(echo "$metadata" | cut -f2)
    fi
}

# Legacy Migration Utilities
# ==========================

# Detect if repository needs migration from single-mode to progressive format
needs_migration() {
    # Legacy local mode: ai-rizz.inf exists but is in .git/info/exclude
    if [ -f "$COMMIT_MANIFEST_FILE" ] && [ -f ".git/info/exclude" ]; then
        if grep -q "^$COMMIT_MANIFEST_FILE$" ".git/info/exclude"; then
            return 0  # true, needs migration from legacy local
        fi
    fi
    
    return 1  # false, no migration needed
}

# Migrate legacy repository to progressive format  
migrate_legacy_repository_if_needed() {
    if ! needs_migration; then
        return 0  # No migration needed
    fi
    
    # Get target directory from existing manifest
    if [ -f "$COMMIT_MANIFEST_FILE" ]; then
        metadata=$(read_manifest_metadata "$COMMIT_MANIFEST_FILE") || {
            error "Failed to read legacy manifest metadata"
        }
        legacy_target_dir=$(echo "$metadata" | cut -f2)
        
        # Migrate legacy local mode to new format
        migrate_legacy_local_mode "$legacy_target_dir"
    fi
}

# Migrate from legacy local mode (ai-rizz.inf in git exclude) to new format
migrate_legacy_local_mode() {
    legacy_target_dir="$1"
    
    # 1. Rename manifest file
    mv "$COMMIT_MANIFEST_FILE" "$LOCAL_MANIFEST_FILE"
    
    # 2. Create local directory and move rules from shared directory
    mkdir -p "$legacy_target_dir/$LOCAL_DIR"
    
    if [ -d "$legacy_target_dir/$SHARED_DIR" ]; then
        if [ "$(ls -A "$legacy_target_dir/$SHARED_DIR" 2>/dev/null)" ]; then
            mv "$legacy_target_dir/$SHARED_DIR"/* "$legacy_target_dir/$LOCAL_DIR/"
        fi
        rmdir "$legacy_target_dir/$SHARED_DIR"
    fi
    
    # 3. Update .git/info/exclude entries
    update_git_exclude "$COMMIT_MANIFEST_FILE" "remove"
    update_git_exclude "$legacy_target_dir/$SHARED_DIR" "remove"  
    update_git_exclude "$LOCAL_MANIFEST_FILE" "add"
    update_git_exclude "$legacy_target_dir/$LOCAL_DIR" "add"
}

# Lazy Initialization Utilities
# =============================

# Initialize a mode that doesn't exist yet, copying metadata from existing mode
lazy_init_mode() {
    target_mode="$1"  # "local" or "commit"
    
    # Get metadata from any existing manifest
    metadata=$(get_any_manifest_metadata) || {
        error "No manifest available to copy metadata from for lazy initialization"
    }
    
    source_repo=$(echo "$metadata" | cut -f1)
    target_dir=$(echo "$metadata" | cut -f2)
    
    case "$target_mode" in
        local)
            # Create local mode structure
            mkdir -p "$target_dir/$LOCAL_DIR"
            
            # Write empty manifest with metadata
            echo "" | write_manifest_with_entries "$LOCAL_MANIFEST_FILE" "$source_repo" "$target_dir"
            
            # Update git excludes
            setup_local_mode_excludes "$target_dir"
            
            # Update mode state and cache
            HAS_LOCAL_MODE=true
            LOCAL_SOURCE_REPO="$source_repo"
            LOCAL_TARGET_DIR="$target_dir"
            ;;
            
        commit)
            # Create commit mode structure  
            mkdir -p "$target_dir/$SHARED_DIR"
            
            # Write empty manifest with metadata
            echo "" | write_manifest_with_entries "$COMMIT_MANIFEST_FILE" "$source_repo" "$target_dir"
            
            # Update mode state and cache
            HAS_COMMIT_MODE=true
            COMMIT_SOURCE_REPO="$source_repo"
            COMMIT_TARGET_DIR="$target_dir"
            ;;
            
        *)
            error "Invalid target mode: $target_mode. Must be 'local' or 'commit'"
            ;;
    esac
}

# Check if lazy initialization is needed for a mode (returns 0 if needed)
needs_lazy_init() {
    target_mode="$1"
    
    case "$target_mode" in
        local)
            [ "$HAS_LOCAL_MODE" = "false" ] && [ "$HAS_COMMIT_MODE" = "true" ]
            ;;
        commit)
            [ "$HAS_COMMIT_MODE" = "false" ] && [ "$HAS_LOCAL_MODE" = "true" ]
            ;;
        *)
            return 1
            ;;
    esac
}

# Commands
# ========

# Initialize the repository
cmd_init() {
  source_repo=""
  target_dir=""
  mode=""
  init_success=false
  
  # Setup cleanup function for error handling
  init_cleanup() {
    if [ "$init_success" = "false" ]; then
      echo "Error during initialization, cleaning up..." >&2
      # Remove target directory if created
      [ -n "$TARGET_DIR" ] && [ -d "$TARGET_DIR" ] && rm -rf "$TARGET_DIR"
      # Remove manifest file if created
      [ -f "$MANIFEST_FILE" ] && rm -f "$MANIFEST_FILE"
      # Remove git exclude entries if added
      if [ "$mode" = "local" ] && [ -n "$TARGET_DIR" ]; then
        update_git_exclude "$TARGET_DIR" "remove" 2>/dev/null || true
        update_git_exclude "$MANIFEST_FILE" "remove" 2>/dev/null || true
      fi
    fi
  }
  
  # Add trap to call cleanup on exit
  trap init_cleanup EXIT
  
  # Parse arguments
  while [ $# -gt 0 ]; do
    case "$1" in
      -d)
        target_dir="$2"
        shift 2
        ;;
      --local|-l)
        mode="local"
        shift
        ;;
      --commit|-c)
        mode="commit"
        shift
        ;;
      *)
        if [ -z "$source_repo" ]; then
          source_repo="$1"
          shift
        else
          error "Unknown argument: $1"
        fi
        ;;
    esac
  done
  
  # Prompt for source repo if not provided
  if [ -z "$source_repo" ]; then
    printf "Source repository URL: "
    read -r source_repo
    if [ -z "$source_repo" ]; then
      error "Source repository URL is required"
    fi
  fi
  
  # Prompt for target directory if not provided
  if [ -z "$target_dir" ]; then
    printf "Target directory [.cursor/rules]: "
    read -r target_dir
    if [ -z "$target_dir" ]; then
      target_dir=".cursor/rules"
    fi
  fi
  
  # Prompt for mode if not provided
  if [ -z "$mode" ]; then
    printf "Mode [local/commit]: "
    read -r mode
    if [ -z "$mode" ]; then
      mode="local"
    fi
  fi
  
  # Validate mode
  case "$mode" in
    local|commit)
      ;;
    *)
      error "Invalid mode: $mode. Must be 'local' or 'commit'"
      ;;
  esac
  
  # Set global variables
  SOURCE_REPO="$source_repo"
  TARGET_DIR="$target_dir"
  MANIFEST_ENTRIES=""
  
  # Create target directory
  mkdir -p "$TARGET_DIR/$SHARED_DIR"
  
  # Set up local mode if needed
  if [ "$mode" = "local" ]; then
    update_git_exclude "$TARGET_DIR" "add"
    update_git_exclude "$MANIFEST_FILE" "add"
  fi
  
  # Write manifest
  write_manifest
  
  # Clone source repository
  if ! git_sync "$SOURCE_REPO"; then
    return 1  # This will trigger the cleanup on exit
  fi
  
  # Initialization completed successfully
  init_success=true
  
  echo "Initialized ai-rizz with source: $SOURCE_REPO, target: $TARGET_DIR, mode: $mode"
  return 0
}

# Recursively remove empty parent directories
cleanup_empty_parents() {
  dir="$1"
  # Check if directory exists and is empty
  if [ -d "$dir" ] && [ -z "$(ls -A "$dir")" ]; then
    parent_dir=$(dirname "$dir")
    echo "Removing empty directory: $dir"
    rmdir "$dir"
    
    # Stop at filesystem root, home directory, or current directory
    if [ "$parent_dir" != "/" ] && [ "$parent_dir" != "$HOME" ] && [ "$parent_dir" != "." ]; then
      cleanup_empty_parents "$parent_dir"
    fi
  fi
}

# Deinitialize the repository
cmd_deinit() {
  force=false
  
  # Parse arguments
  while [ $# -gt 0 ]; do
    case "$1" in
      -y)
        force=true
        shift
        ;;
      *)
        error "Unknown argument: $1"
        ;;
    esac
  done
  
  # Read manifest
  read_manifest
  
  # Store original target directory for cleanup
  ORIGINAL_TARGET_DIR="$TARGET_DIR"
  
  # Confirm deletion
  if ! $force; then
    echo "This will delete: $TARGET_DIR"
    printf "Are you sure? [y/N] "
    read -r confirm
    if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
      echo "Canceled"
      return 0
    fi
  fi
  
  # Remove from .git/info/exclude if in local mode
  if is_local_mode; then
    update_git_exclude "$TARGET_DIR" "remove"
    update_git_exclude "$MANIFEST_FILE" "remove"
  fi
  
  # Remove target directory and manifest file
  rm -rf "$TARGET_DIR"
  rm -f "$MANIFEST_FILE"
  
  # Clean up empty parent directories
  parent_dir=$(dirname "$ORIGINAL_TARGET_DIR")
  if [ "$parent_dir" != "." ] && [ "$parent_dir" != "/" ]; then
    cleanup_empty_parents "$parent_dir"
  fi
  
  echo "Removed ai-rizz configuration"
  return 0
}

# List available rules and rulesets (multi-mode aware)
cmd_list() {
    # Check if any mode is initialized
    if [ "$HAS_COMMIT_MODE" = "false" ] && [ "$HAS_LOCAL_MODE" = "false" ]; then
        error "No ai-rizz configuration found. Run 'ai-rizz init' first."
    fi
    
    # Get source repo from any available mode
    source_repo=""
    if [ "$HAS_COMMIT_MODE" = "true" ]; then
        source_repo="$COMMIT_SOURCE_REPO"
    elif [ "$HAS_LOCAL_MODE" = "true" ]; then
        source_repo="$LOCAL_SOURCE_REPO"
    fi
    
    # Update source repository
    git_sync "$source_repo"
    
    # Helper function to check if an item is installed in any mode
    is_installed() {
        local item="$1"
        local status="uninstalled"
        
        # Check commit mode
        if [ "$HAS_COMMIT_MODE" = "true" ]; then
            if read_manifest_entries "$COMMIT_MANIFEST_FILE" 2>/dev/null | grep -q "^$item$"; then
                status="committed"
            fi
        fi
        
        # Check local mode (overrides commit status for display)
        if [ "$HAS_LOCAL_MODE" = "true" ]; then
            if read_manifest_entries "$LOCAL_MANIFEST_FILE" 2>/dev/null | grep -q "^$item$"; then
                status="local"
            fi
        fi
        
        echo "$status"
    }
    
    # Display rules
    echo "Available rules:"
    rules=$(find "$REPO_DIR/rules" -name "*.mdc" | sort 2>/dev/null)
    if [ -z "$rules" ]; then
        echo "  No rules found"
    else
        for rule in $rules; do
            rule_name=$(basename "$rule")
            rule_path="rules/$rule_name"
            status=$(is_installed "$rule_path")
            
            case "$status" in
                committed)
                    printf "  %s %s\n" "$COMMITTED_GLYPH" "$rule_name"
                    ;;
                local)
                    printf "  %s %s\n" "$LOCAL_GLYPH" "$rule_name"
                    ;;
                *)
                    printf "  %s %s\n" "$UNINSTALLED_GLYPH" "$rule_name"
                    ;;
            esac
        done
    fi
    echo ""
    
    # Display rulesets
    echo "Available rulesets:"
    rulesets=$(find "$REPO_DIR/rulesets" -mindepth 1 -maxdepth 1 -type d | sort 2>/dev/null)
    if [ -z "$rulesets" ]; then
        echo "  No rulesets found"
    else
        for ruleset in $rulesets; do
            ruleset_name=$(basename "$ruleset")
            ruleset_path="rulesets/$ruleset_name"
            status=$(is_installed "$ruleset_path")
            
            # Display ruleset with installation status
            case "$status" in
                committed)
                    printf "  %s %s\n" "$COMMITTED_GLYPH" "$ruleset_name"
                    ;;
                local)
                    printf "  %s %s\n" "$LOCAL_GLYPH" "$ruleset_name"
                    ;;
                *)
                    printf "  %s %s\n" "$UNINSTALLED_GLYPH" "$ruleset_name"
                    ;;
            esac
            
            # Use tree to display ruleset contents
            if [ -d "$ruleset" ]; then
                # Check if tree command exists
                if command -v tree >/dev/null 2>&1; then
                    (cd "$ruleset" && tree -L 1 --noreport) | tail -n +2 | sed 's/^/    /' | sed 's/ -> .*$//'
                else
                    # Fallback if tree is not available
                    find "$ruleset" -maxdepth 1 -name "*.mdc" -exec basename {} \; | sort | sed 's/^/    ├── /'
                fi
            fi
        done
    fi
    
    return 0
}

# Add rule(s) to the repository
cmd_add_rule() {
  # Read manifest
  read_manifest
  
  # Update source repository
  git_sync "$SOURCE_REPO"
  
  # Process each rule
  for rule in "$@"; do
    # Add .mdc extension if not present
    case "$rule" in
      *".mdc") ;;  # Already has extension
      *) rule="${rule}.mdc" ;;  # Add extension
    esac
    
    rule_path="rules/$rule"
    
    # Check if rule exists
    if [ ! -f "$REPO_DIR/$rule_path" ]; then
      warn "Rule not found: $rule_path"
      continue
    fi
    
    # Add to manifest
    add_manifest_entry "$rule_path"
    
    # Copy rule - directly to shared dir
    mkdir -p "$TARGET_DIR/$SHARED_DIR"
    cp -f "$REPO_DIR/$rule_path" "$TARGET_DIR/$SHARED_DIR/$(basename "$rule_path")"
    
    echo "Added rule: $rule_path"
  done
  
  # Write manifest
  write_manifest
  
  return 0
}

# Add ruleset(s) to the repository
cmd_add_ruleset() {
  # Read manifest
  read_manifest
  
  # Update source repository
  git_sync "$SOURCE_REPO"
  
  # Process each ruleset
  for ruleset in "$@"; do
    ruleset_path="rulesets/$ruleset"
    
    # Check if ruleset exists
    if [ ! -d "$REPO_DIR/$ruleset_path" ]; then
      warn "Ruleset not found: $ruleset_path"
      continue
    fi
    
    # Add to manifest
    add_manifest_entry "$ruleset_path"
    
    # Find all rules in the ruleset
    find "$REPO_DIR/$ruleset_path" -name "*.mdc" | while read -r rule_link; do
      # Get rule name and source path
      rule_name=$(basename "$rule_link")
      rule_source="$REPO_DIR/rules/$rule_name"
      
      # Copy rule - directly to shared dir
      mkdir -p "$TARGET_DIR/$SHARED_DIR"
      cp -f "$rule_source" "$TARGET_DIR/$SHARED_DIR/$rule_name"
    done
    
    echo "Added ruleset: $ruleset_path"
  done
  
  # Write manifest
  write_manifest
  
  return 0
}

# Remove rule(s) from the repository
cmd_remove_rule() {
  # Read manifest
  read_manifest
  
  # Process each rule
  for rule in "$@"; do
    # Add .mdc extension if not present
    case "$rule" in
      *".mdc") ;;  # Already has extension
      *) rule="${rule}.mdc" ;;  # Add extension
    esac
    
    rule_path="rules/$rule"
    
    # Remove from manifest
    remove_manifest_entry "$rule_path"
    
    echo "Removed rule: $rule_path"
  done
  
  # Write manifest
  write_manifest
  
  # Sync to ensure proper cleanup
  cmd_sync
  
  return 0
}

# Remove ruleset(s) from the repository
cmd_remove_ruleset() {
  # Read manifest
  read_manifest
  
  # Process each ruleset
  for ruleset in "$@"; do
    ruleset_path="rulesets/$ruleset"
    
    # Remove from manifest
    remove_manifest_entry "$ruleset_path"
    
    echo "Removed ruleset: $ruleset_path"
  done
  
  # Write manifest
  write_manifest
  
  # Sync to ensure proper cleanup
  cmd_sync
  
  return 0
}

# Sync the repository (multi-mode aware)
cmd_sync() {
    # Check if any mode is initialized
    if [ "$HAS_COMMIT_MODE" = "false" ] && [ "$HAS_LOCAL_MODE" = "false" ]; then
        error "No ai-rizz configuration found. Run 'ai-rizz init' first."
    fi
    
    # Sync commit mode if available
    if [ "$HAS_COMMIT_MODE" = "true" ]; then
        echo "Syncing commit mode..."
        sync_mode_rules "$COMMIT_MANIFEST_FILE" "$COMMIT_TARGET_DIR/$SHARED_DIR" "$COMMIT_SOURCE_REPO"
    fi
    
    # Sync local mode if available  
    if [ "$HAS_LOCAL_MODE" = "true" ]; then
        echo "Syncing local mode..."
        sync_mode_rules "$LOCAL_MANIFEST_FILE" "$LOCAL_TARGET_DIR/$LOCAL_DIR" "$LOCAL_SOURCE_REPO"
    fi
    
    echo "Sync complete"
    return 0
}

# Sync rules for a specific mode
sync_mode_rules() {
    manifest_file="$1"
    target_dir="$2"
    source_repo="$3"
    
    # Update source repository
    git_sync "$source_repo"
    
    # Create target directory
    mkdir -p "$target_dir"
    
    # Get manifest entries
    entries=$(read_manifest_entries "$manifest_file" 2>/dev/null || echo "")
    
    # First, scan all rules in the target directory and remove orphaned ones
    for rule_file in "$target_dir"/*.mdc; do
        if [ -f "$rule_file" ]; then
            rule_name=$(basename "$rule_file")
            rule_needed=false
            
            # Check if rule is directly in manifest
            if echo "$entries" | grep -q "^rules/$rule_name$"; then
                rule_needed=true
            else
                # Check if rule is in any of the rulesets in manifest
                for ruleset in $(echo "$entries" | grep "^rulesets/" || true); do
                    if [ -f "$REPO_DIR/$ruleset/$rule_name" ]; then
                        rule_needed=true
                        break
                    fi
                done
            fi
            
            # Remove rule if not needed
            if ! $rule_needed; then
                rm -f "$rule_file"
                echo "Removed orphaned rule: $rule_name"
            fi
        fi
    done
    
    # Clean up invalid entries and rewrite manifest
    valid_entries=""
    for entry in $entries; do
        if [ -e "$REPO_DIR/$entry" ]; then
            if [ -z "$valid_entries" ]; then
                valid_entries="$entry"
            else
                valid_entries="$valid_entries
$entry"
            fi
        else
            warn "Entry not found in source repository: $entry"
        fi
    done
    
    # Update manifest if entries changed
    if [ "$valid_entries" != "$entries" ]; then
        metadata=$(read_manifest_metadata "$manifest_file")
        source_repo_meta=$(echo "$metadata" | cut -f1)
        target_dir_meta=$(echo "$metadata" | cut -f2)
        echo "$valid_entries" | write_manifest_with_entries "$manifest_file" "$source_repo_meta" "$target_dir_meta"
        echo "Manifest updated: $manifest_file"
    fi
    
    # Sync rules
    for entry in $valid_entries; do
        if echo "$entry" | grep -q "^rules/"; then
            # Copy rule directly to target dir
            cp -f "$REPO_DIR/$entry" "$target_dir/$(basename "$entry")"
            echo "Synced rule: $entry"
        elif echo "$entry" | grep -q "^rulesets/"; then
            # Find all rules in the ruleset
            find "$REPO_DIR/$entry" -name "*.mdc" | while read -r rule_link; do
                # Get rule name and source path
                rule_name=$(basename "$rule_link")
                rule_source="$REPO_DIR/rules/$rule_name"
                
                # Copy rule to target dir
                cp -f "$rule_source" "$target_dir/$rule_name"
                echo "Synced rule from ruleset: $entry/$rule_name"
            done
            echo "Synced ruleset: $entry"
        fi
    done
}

# Help command
cmd_help() {
  cat <<EOF
Usage: ai-rizz <command> [command-specific options]

Available commands:
  init [<source_repo>]     Initialize the repository
  deinit                   Deinitialize the repository
  list                     List available rules and rulesets
  add rule <rule>...       Add rule(s) to the repository (.mdc extension optional)
  add ruleset <ruleset>... Add ruleset(s) to the repository
  remove rule <rule>...    Remove rule(s) from the repository (.mdc extension optional)
  remove ruleset <ruleset>... Remove ruleset(s) from the repository
  sync                     Sync the repository
  help                     Show this help

Command-specific options:
  init options:
    -d <target_dir>        Target directory (default: .cursor/rules)
    --local, -l            Use local mode (ignore files)
    --commit, -c           Use commit mode (commit files)

  deinit options:
    -y                     Skip confirmation prompts
EOF
  return 0
}

# Initialization
# ==============

# Initialize ai-rizz state at startup (two-phase to avoid circular dependencies)
initialize_ai_rizz() {
    # Phase 1: Minimal detection and migration (file-based only)
    detect_manifest_files_only
    migrate_legacy_repository_if_needed
    
    # Phase 2: Full initialization with directory checking  
    detect_initialized_modes
    cache_manifest_metadata
}

# Main
# ====

# Only run main code if script is executed, not sourced
if [ "${0##*/}" = "ai-rizz" ]; then
    # Check if no arguments provided
    if [ $# -eq 0 ]; then
        cmd_help
        exit 0
    fi
    
    # Initialize ai-rizz state for production use
    initialize_ai_rizz
    
    # Parse command
    command=$1
    shift

    case "$command" in
    init)
      cmd_init "$@"
      ;;
    deinit)
      cmd_deinit "$@"
      ;;
    list)
      cmd_list "$@"
      ;;
    add)
      if [ $# -eq 0 ]; then
        error "Missing type: 'rule' or 'ruleset'"
      fi
      
      type=$1
      shift
      
      case "$type" in
        rule)
          if [ $# -eq 0 ]; then
            error "Missing rule name"
          fi
          cmd_add_rule "$@"
          ;;
        ruleset)
          if [ $# -eq 0 ]; then
            error "Missing ruleset name"
          fi
          cmd_add_ruleset "$@"
          ;;
        *)
          error "Invalid type: $type. Must be 'rule' or 'ruleset'"
          ;;
      esac
      ;;
    remove)
      if [ $# -eq 0 ]; then
        error "Missing type: 'rule' or 'ruleset'"
      fi
      
      type=$1
      shift
      
      case "$type" in
        rule)
          if [ $# -eq 0 ]; then
            error "Missing rule name"
          fi
          cmd_remove_rule "$@"
          ;;
        ruleset)
          if [ $# -eq 0 ]; then
            error "Missing ruleset name"
          fi
          cmd_remove_ruleset "$@"
          ;;
        *)
          error "Invalid type: $type. Must be 'rule' or 'ruleset'"
          ;;
      esac
      ;;
    sync)
      cmd_sync "$@"
      ;;
    help)
      cmd_help "$@"
      ;;
    *)
      error "Unknown command: $command. Run 'ai-rizz help' for usage"
      ;;
  esac
fi
