#!/bin/sh
#
# ai-rizz - A CLI tool to manage Cursor rules and rulesets
# Supports progressive initialization with local and commit modes
#
# Usage: ai-rizz <command> [options]
# 
# Copyright 2024 ai-rizz project
# POSIX-compliant shell script for maximum portability

set -e  # Exit on error

# Configuration constants
COMMIT_MANIFEST_FILE="ai-rizz.inf"
LOCAL_MANIFEST_FILE="ai-rizz.local.inf"
SHARED_DIR="shared"
LOCAL_DIR="local" 
CONFIG_DIR="$HOME/.config/ai-rizz"
DEFAULT_TARGET_DIR=".cursor/rules"

# Mode state (set once during initialization, read-only afterward)
HAS_COMMIT_MODE=false
HAS_LOCAL_MODE=false

# Cached manifest metadata (set during initialization for efficiency)
COMMIT_SOURCE_REPO=""
LOCAL_SOURCE_REPO=""
COMMIT_TARGET_DIR=""
LOCAL_TARGET_DIR=""

# Repository directory (set during initialization)
REPO_DIR=""

# Display formatting variables  
COMMITTED_GLYPH="●"
LOCAL_GLYPH="◐"
UNINSTALLED_GLYPH="○"

# Utilities
# =========

# Get repository directory for the current project
#
# Globals:
#   CONFIG_DIR - Base configuration directory path
#
# Arguments:
#   None
#
# Outputs:
#   Stdout: Repository directory path for current project
#
# Returns:
#   0 on success
#
get_repo_dir() {
	# Use git root directory name as project name, fallback to current directory
	if grd_git_root=$(git rev-parse --show-toplevel 2>/dev/null); then
	    grd_project_name=$(basename "${grd_git_root}")
	else
	    grd_project_name=$(basename "$(pwd)")
	fi
	echo "${CONFIG_DIR}/repos/${grd_project_name}/repo"
}

# Print error message to stderr and exit with specified code
#
# Globals:
#   None
#
# Arguments:
#   $1 - Error message to display (required)
#   $2 - Exit code (optional, defaults to 1)
#
# Outputs:
#   Stderr: Error message prefixed with "Error: "
#
# Returns:
#   Never returns (exits with specified code)
#
error() {
  echo "Error: ${1}" >&2
  exit "${2:-1}"
}

# Print warning message to stderr
#
# Globals:
#   None
#
# Arguments:
#   $1 - Warning message to display (required)
#
# Outputs:
#   Stderr: Warning message prefixed with "Warning: "
#
# Returns:
#   0 on success
#
warn() {
  echo "Warning: ${1}" >&2
}


# Progressive Manifest Utilities  
# ==============================

# Read manifest metadata line from specified file
#
# Globals:
#   None
#
# Arguments:
#   $1 - Path to manifest file (required)
#
# Outputs:
#   Stdout: Tab-separated "source_repo\ttarget_dir" line
#   Stderr: Error message if invalid format
#
# Returns:
#   0 on success
#   1 if file doesn't exist or on error (via error() function)
#
read_manifest_metadata() {
	rmm_manifest_file="${1}"
	
	if [ ! -f "${rmm_manifest_file}" ]; then
	    return 1
	fi
	
	# Read first line
	read -r rmm_first_line < "${rmm_manifest_file}"
	
	# Validate format
	if ! echo "${rmm_first_line}" | grep -q "	"; then
		error "Invalid manifest format in ${rmm_manifest_file}: First line must be 'source_repo<tab>target_dir'"
	fi
	
	echo "${rmm_first_line}"
}

# Read manifest entries from specified file
#
# Globals:
#   None
#
# Arguments:
#   $1 - Path to manifest file (required)
#
# Outputs:
#   Stdout: Manifest entries, one per line (excluding metadata line)
#
# Returns:
#   0 on success (including empty manifests)
#   1 if file doesn't exist
#
read_manifest_entries() {
	rme_manifest_file="${1}"
	
	if [ ! -f "${rme_manifest_file}" ]; then
	    return 1
	fi
	
	# Skip first line (metadata), return rest (handle empty manifests gracefully)
	tail -n +2 "${rme_manifest_file}" | grep -v '^$' || true
}

# Write manifest file with metadata header and entries from stdin
#
# Globals:
#   None
#
# Arguments:
#   $1 - Path to manifest file to write (required)
#   $2 - Source repository URL (required)
#   $3 - Target directory path (required)
#
# Outputs:
#   None (writes to file)
#
# Returns:
#   0 on success
#
write_manifest_with_entries() {
	wmwe_manifest_file="${1}"
	wmwe_source_repo="${2}"
	wmwe_target_dir="${3}"
	
	# Write header
	echo "${wmwe_source_repo}	${wmwe_target_dir}" > "${wmwe_manifest_file}"
	
	# Read from stdin and append if there's content
	while IFS= read -r wmwe_line; do
	    if [ -n "${wmwe_line}" ]; then
	        echo "${wmwe_line}" >> "${wmwe_manifest_file}"
	    fi
	done
}

# Add entry to specified manifest file
#
# Globals:
#   None
#
# Arguments:
#   $1 - Path to manifest file (required)
#   $2 - Entry to add (required)
#
# Outputs:
#   Stderr: Error message if write fails
#
# Returns:
#   0 on success (including if entry already exists)
#   1 on error (via error() function)
#
add_manifest_entry_to_file() {
	ametf_target_manifest_file="${1}"
	ametf_entry="${2}"
	
	# Check if entry already exists
	if [ -f "${ametf_target_manifest_file}" ]; then
	    if read_manifest_entries "${ametf_target_manifest_file}" | grep -q "^${ametf_entry}$"; then
	        return 0  # Already exists
	    fi
	fi
	
	# Add the entry with error handling
	if ! echo "${ametf_entry}" >> "${ametf_target_manifest_file}" 2>/dev/null; then
	    error "Cannot write to manifest file: ${ametf_target_manifest_file} (permission denied or read-only)"
	fi
}

# Remove entry from specified manifest file
#
# Globals:
#   None
#
# Arguments:
#   $1 - Path to manifest file (required)
#   $2 - Entry to remove (required)
#
# Outputs:
#   Stderr: Error message if metadata read fails
#
# Returns:
#   0 on success (including if file doesn't exist or entry not found)
#   1 on error (via error() function)
#
remove_manifest_entry_from_file() {
	rmeff_local_manifest_file="${1}"
	rmeff_entry="${2}"
	
	if [ ! -f "${rmeff_local_manifest_file}" ]; then
	    return 0  # Nothing to remove
	fi
	
	# Get metadata
	if ! rmeff_metadata=$(read_manifest_metadata "${rmeff_local_manifest_file}"); then
		error "Failed to read manifest metadata from ${rmeff_local_manifest_file}"
	fi
	
	# Get entries excluding the one to remove
	rmeff_entries=$(read_manifest_entries "${rmeff_local_manifest_file}" | grep -v "^${rmeff_entry}$" || true)
	
	# Rewrite manifest
	rmeff_source_repo=$(echo "${rmeff_metadata}" | cut -f1)
	rmeff_target_dir=$(echo "${rmeff_metadata}" | cut -f2)
	
	# Write header first
	echo "${rmeff_source_repo}	${rmeff_target_dir}" > "${rmeff_local_manifest_file}"
	
	# Append entries if any exist (avoid hanging cat with empty input)
	if [ -n "${rmeff_entries}" ]; then
	    echo "${rmeff_entries}" >> "${rmeff_local_manifest_file}"
	fi
}

# Get metadata from any available manifest file for lazy initialization
#
# Globals:
#   COMMIT_MANIFEST_FILE - Path to commit manifest file
#   LOCAL_MANIFEST_FILE - Path to local manifest file
#
# Arguments:
#   None
#
# Outputs:
#   Stdout: Tab-separated "source_repo\ttarget_dir" line from first available manifest
#
# Returns:
#   0 on success (manifest found and read)
#   1 if no manifests available
#
get_any_manifest_metadata() {
	# Try commit manifest first
	if [ -f "${COMMIT_MANIFEST_FILE}" ]; then
	    read_manifest_metadata "${COMMIT_MANIFEST_FILE}"
	    return $?
	fi
	
	# Try local manifest
	if [ -f "${LOCAL_MANIFEST_FILE}" ]; then
	    read_manifest_metadata "${LOCAL_MANIFEST_FILE}"
	    return $?
	fi
	
	# No manifests available
	return 1
}

# Clone or update the rules repository cache
#
# This is the core sync function - all rule operations depend on having
# an up-to-date local cache of the rules repository. Uses graceful error
# handling so ai-rizz can work offline with cached content.
#
# Suppresses git output to avoid cluttering user interface while preserving
# error detection for proper failure reporting.
#
# Globals:
#   REPO_DIR - Target directory for repository cache
#
# Arguments:
#   $1 - Repository URL to clone/update
#
# Outputs:
#   Stderr: Warning messages on failure
#
# Returns:
#   0 on success
#   1 on failure (network issues, invalid URL, permissions)
#
git_sync() {
  gs_repo_url="${1}"
  
  # Ensure config directory exists
  mkdir -p "$(dirname "${REPO_DIR}")"
  
  # Clone/update project repository
  if [ ! -d "${REPO_DIR}" ]; then
	if ! git clone "${gs_repo_url}" "${REPO_DIR}" 2>/dev/null; then
	  warn "Failed to clone repository: ${gs_repo_url} (repository unavailable or invalid URL)"
	  return 1
	fi
  else
	if ! (cd "${REPO_DIR}" && git pull 2>/dev/null); then
	  warn "Failed to update repository: ${gs_repo_url} (repository unavailable or network issue)"
	  return 1
	fi
  fi
  
  return 0
}



# Git Exclude Management  
# ======================

# Update .git/info/exclude for specific paths
#
# Uses exact line matching to avoid partial matches. Idempotent.
#
# Globals:
#   None
#
# Arguments:
#   $1 - Path to add/remove from git excludes
#   $2 - Action: "add" or "remove"
#
# Outputs:
#   Stderr: Error message if invalid action
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
update_git_exclude() {
	uge_path="${1}"
	uge_action="${2}"  # "add" or "remove"
	
	# Create .git/info directory if it doesn't exist
	mkdir -p ".git/info"
	
	# Create exclude file if it doesn't exist  
	touch ".git/info/exclude"
	
	case "${uge_action}" in
	    add)
	        if ! grep -q "^${uge_path}$" ".git/info/exclude"; then
	            echo "${uge_path}" >> ".git/info/exclude"
	        fi
	        ;;
	    remove)
	        # Create a temporary file
	        uge_tmp_file=$(mktemp)
	        # Filter out the path
	        grep -v "^${uge_path}$" ".git/info/exclude" > "${uge_tmp_file}" || true
	        # Replace the original file
	        cat "${uge_tmp_file}" > ".git/info/exclude"
	        # Remove the temporary file
	        rm -f "${uge_tmp_file}"
	        ;;
	    *)
	        error "Invalid action: ${uge_action}. Must be 'add' or 'remove'"
	        ;;
	esac
}

# Setup git excludes for local mode
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename to exclude
#   LOCAL_DIR - Local directory name to exclude
#
# Arguments:
#   $1 - Target directory base path
#
# Outputs:
#   None
#
# Returns:
#   0 on success
#
setup_local_mode_excludes() {
	slme_target_dir="${1}"
	
	update_git_exclude "${LOCAL_MANIFEST_FILE}" "add"
	update_git_exclude "${slme_target_dir}/${LOCAL_DIR}" "add"
}

# Remove all local mode excludes
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename to unexclude
#   LOCAL_DIR - Local directory name to unexclude
#
# Arguments:
#   $1 - Target directory base path
#
# Outputs:
#   None
#
# Returns:
#   0 on success
#
remove_local_mode_excludes() {
	rlme_target_dir="${1}"
	
	update_git_exclude "${LOCAL_MANIFEST_FILE}" "remove"
	update_git_exclude "${rlme_target_dir}/${LOCAL_DIR}" "remove"
}

# Validate git exclude state matches mode configuration
#
# Warns about mismatched git exclude state - helps debug when users
# manually edit .git/info/exclude and break mode separation.
#
# Globals:
#   HAS_LOCAL_MODE - Whether local mode is initialized
#   HAS_COMMIT_MODE - Whether commit mode is initialized
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   LOCAL_DIR - Local directory name
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   SHARED_DIR - Shared directory name
#
# Arguments:
#   $1 - Target directory base path
#
# Outputs:
#   Stderr: Warning messages for mismatched state
#
# Returns:
#   0 always
#
validate_git_exclude_state() {
	vges_target_dir="${1}"
	
	if [ "${HAS_LOCAL_MODE}" = "true" ]; then
	    # Local mode should be excluded
	    if [ ! -f ".git/info/exclude" ] || ! grep -q "^${LOCAL_MANIFEST_FILE}$" ".git/info/exclude"; then
	        warn "Local manifest file not in git exclude (should be git-ignored)"
	    fi
	    if [ ! -f ".git/info/exclude" ] || ! grep -q "^${vges_target_dir}/${LOCAL_DIR}$" ".git/info/exclude"; then
	        warn "Local directory not in git exclude (should be git-ignored)"
	    fi
	fi
	
	if [ "${HAS_COMMIT_MODE}" = "true" ]; then
	    # Commit mode should NOT be excluded
	    if [ -f ".git/info/exclude" ] && grep -q "^${COMMIT_MANIFEST_FILE}$" ".git/info/exclude"; then
	        warn "Commit manifest file in git exclude (should be git-tracked)"
	    fi
	    if [ -f ".git/info/exclude" ] && grep -q "^${vges_target_dir}/${SHARED_DIR}$" ".git/info/exclude"; then
	        warn "Shared directory in git exclude (should be git-tracked)"
	    fi
	fi
}

# Mode Detection Utilities
# ========================

# Phase 1: Minimal manifest file detection (no directory dependency)
#
# Quick file-only check used during initialization before directories
# are validated. Avoids circular dependencies in startup sequence.
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   HAS_LOCAL_MODE - Set to true/false based on file existence
#   HAS_COMMIT_MODE - Set to true/false based on file existence
#
# Arguments:
#   None
#
# Outputs:
#   None
#
# Returns:
#   0 always
#
detect_manifest_files_only() {
	# Quick check - just look for files, don't validate directories yet
	if [ -f "${LOCAL_MANIFEST_FILE}" ]; then
	    HAS_LOCAL_MODE=true
	else
	    HAS_LOCAL_MODE=false
	fi
	
	if [ -f "${COMMIT_MANIFEST_FILE}" ]; then
	    HAS_COMMIT_MODE=true
	else
	    HAS_COMMIT_MODE=false
	fi
}

# Phase 2: Full mode detection including directory validation
#
# Complete mode detection that validates both manifest files and target
# directories exist. Used after migration to get accurate mode state.
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   LOCAL_DIR - Local directory name
#   SHARED_DIR - Shared directory name
#   HAS_LOCAL_MODE - Set based on manifest + directory existence
#   HAS_COMMIT_MODE - Set based on manifest + directory existence
#
# Arguments:
#   None
#
# Outputs:
#   None
#
# Returns:
#   0 always
#
detect_initialized_modes() {
	HAS_LOCAL_MODE=false
	HAS_COMMIT_MODE=false
	
	# Get target directory or error if none available
	dim_target_base=$(get_target_directory)
	
	# Check for local mode (manifest + directory)
	if [ -f "${LOCAL_MANIFEST_FILE}" ] && [ -d "${dim_target_base}/${LOCAL_DIR}" ]; then
	    HAS_LOCAL_MODE=true
	fi
	
	# Check for commit mode (manifest + directory)  
	if [ -f "${COMMIT_MANIFEST_FILE}" ] && [ -d "${dim_target_base}/${SHARED_DIR}" ]; then
	    HAS_COMMIT_MODE=true
	fi
}

# Get target directory from available manifests
#
# Tries commit manifest first, then local, then default. The default
# is only used during initialization when no manifests exist yet.
#
# Globals:
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   DEFAULT_TARGET_DIR - Default target directory
#
# Arguments:
#   None
#
# Outputs:
#   Stdout: Target directory path
#
# Returns:
#   0 always
#
get_target_directory() {
	# Try commit manifest first
	if [ -f "${COMMIT_MANIFEST_FILE}" ]; then
		if ! gtd_metadata=$(read_manifest_metadata "${COMMIT_MANIFEST_FILE}"); then
			error "Failed to read commit manifest metadata"
		fi
		echo "${gtd_metadata}" | cut -f2
		return 0
	fi
	
	# Try local manifest
	if [ -f "${LOCAL_MANIFEST_FILE}" ]; then
		if ! gtd_metadata=$(read_manifest_metadata "${LOCAL_MANIFEST_FILE}"); then
			error "Failed to read local manifest metadata"
		fi
		echo "${gtd_metadata}" | cut -f2
		return 0
	fi
	
	# No manifests available - use default only during initialization
	echo "${DEFAULT_TARGET_DIR}"
}

# Cache manifest metadata in globals for efficiency
#
# Avoids repeatedly parsing manifest files during operations.
#
# Globals:
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   COMMIT_SOURCE_REPO - Set from commit manifest
#   COMMIT_TARGET_DIR - Set from commit manifest
#   LOCAL_SOURCE_REPO - Set from local manifest
#   LOCAL_TARGET_DIR - Set from local manifest
#
# Arguments:
#   None
#
# Outputs:
#   None
#
# Returns:
#   0 always
#
cache_manifest_metadata() {
	# Cache commit manifest metadata
	if [ -f "${COMMIT_MANIFEST_FILE}" ]; then
		if ! cmm_metadata=$(read_manifest_metadata "${COMMIT_MANIFEST_FILE}"); then
			error "Failed to read commit manifest metadata"
		fi
		COMMIT_SOURCE_REPO=$(echo "${cmm_metadata}" | cut -f1)
		COMMIT_TARGET_DIR=$(echo "${cmm_metadata}" | cut -f2)
	fi
	
	# Cache local manifest metadata
	if [ -f "${LOCAL_MANIFEST_FILE}" ]; then
		if ! cmm_metadata=$(read_manifest_metadata "${LOCAL_MANIFEST_FILE}"); then
			error "Failed to read local manifest metadata"
		fi
		LOCAL_SOURCE_REPO=$(echo "${cmm_metadata}" | cut -f1)
		LOCAL_TARGET_DIR=$(echo "${cmm_metadata}" | cut -f2)
	fi
}


# Legacy Migration Utilities
# ==========================

# Detect if repository needs migration from single-mode to progressive format
#
# Detects legacy local mode by checking if commit manifest is git-excluded.
#
# Globals:
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#
# Arguments:
#   None
#
# Outputs:
#   None
#
# Returns:
#   0 if migration needed
#   1 if no migration needed
#
needs_migration() {
	# Legacy local mode: ai-rizz.inf exists but is in .git/info/exclude
	if [ -f "${COMMIT_MANIFEST_FILE}" ] && [ -f ".git/info/exclude" ]; then
	    if grep -q "^${COMMIT_MANIFEST_FILE}$" ".git/info/exclude"; then
	        return 0  # true, needs migration from legacy local
	    fi
	fi
	
	return 1  # false, no migration needed
}

# Migrate legacy repository to progressive format
#
# Globals:
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#
# Arguments:
#   None
#
# Outputs:
#   None
#
# Returns:
#   0 always
#
migrate_legacy_repository_if_needed() {
	if ! needs_migration; then
	    return 0  # No migration needed
	fi
	
	# Get target directory from existing manifest
	if [ -f "${COMMIT_MANIFEST_FILE}" ]; then
		if ! mlrin_metadata=$(read_manifest_metadata "${COMMIT_MANIFEST_FILE}"); then
			error "Failed to read legacy manifest metadata"
		fi
		mlrin_legacy_target_dir=$(echo "${mlrin_metadata}" | cut -f2)
		
		# Migrate legacy local mode to new format
		migrate_legacy_local_mode "${mlrin_legacy_target_dir}"
	fi
}

# Migrate from legacy local mode (ai-rizz.inf in git exclude) to new format
#
# Converts single-mode local setup to progressive format by renaming files,
# moving directories, and updating git excludes. Preserves all existing rules.
#
# Globals:
#   COMMIT_MANIFEST_FILE - Legacy manifest filename
#   LOCAL_MANIFEST_FILE - New local manifest filename
#   LOCAL_DIR - Local directory name
#   SHARED_DIR - Shared directory name
#
# Arguments:
#   $1 - Legacy target directory path
#
# Outputs:
#   None
#
# Returns:
#   0 always
#
migrate_legacy_local_mode() {
	mllm_legacy_target_dir="${1}"
	
	# 1. Rename manifest file
	mv "${COMMIT_MANIFEST_FILE}" "${LOCAL_MANIFEST_FILE}"
	
	# 2. Create local directory and move rules from shared directory
	mkdir -p "${mllm_legacy_target_dir}/${LOCAL_DIR}"
	
	if [ -d "${mllm_legacy_target_dir}/${SHARED_DIR}" ]; then
	    if [ "$(ls -A "${mllm_legacy_target_dir}/${SHARED_DIR}" 2>/dev/null)" ]; then
	        mv "${mllm_legacy_target_dir}/${SHARED_DIR}"/* "${mllm_legacy_target_dir}/${LOCAL_DIR}/"
	    fi
	    rmdir "${mllm_legacy_target_dir}/${SHARED_DIR}"
	fi
	
	# 3. Update .git/info/exclude entries
	update_git_exclude "${COMMIT_MANIFEST_FILE}" "remove"
	update_git_exclude "${mllm_legacy_target_dir}/${SHARED_DIR}" "remove"  
	update_git_exclude "${LOCAL_MANIFEST_FILE}" "add"
	update_git_exclude "${mllm_legacy_target_dir}/${LOCAL_DIR}" "add"
}

# Lazy Initialization Utilities
# =============================

# Initialize a mode that doesn't exist yet, copying metadata from existing mode
#
# Enables progressive mode switching by creating the missing mode with
# matching configuration. Copies source repo and target dir from existing
# mode to maintain consistency.
#
# Globals:
#   LOCAL_DIR - Local directory name
#   SHARED_DIR - Shared directory name
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   HAS_LOCAL_MODE - Updated based on target mode
#   HAS_COMMIT_MODE - Updated based on target mode
#   LOCAL_SOURCE_REPO - Set if creating local mode
#   LOCAL_TARGET_DIR - Set if creating local mode
#   COMMIT_SOURCE_REPO - Set if creating commit mode
#   COMMIT_TARGET_DIR - Set if creating commit mode
#
# Arguments:
#   $1 - Target mode: "local" or "commit"
#
# Outputs:
#   None
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
lazy_init_mode() {
	lim_target_mode="${1}"  # "local" or "commit"
	
	# Get metadata from any existing manifest
	if ! lim_metadata=$(get_any_manifest_metadata); then
		error "No manifest available to copy metadata from for lazy initialization"
	fi
	
	lim_source_repo=$(echo "${lim_metadata}" | cut -f1)
	lim_target_dir=$(echo "${lim_metadata}" | cut -f2)
	
	case "${lim_target_mode}" in
	    local)
	        # Create local mode structure
	        mkdir -p "${lim_target_dir}/${LOCAL_DIR}"
	        
	        # Write empty manifest with metadata
	        echo "" | write_manifest_with_entries "${LOCAL_MANIFEST_FILE}" "${lim_source_repo}" "${lim_target_dir}"
	        
	        # Update git excludes
	        setup_local_mode_excludes "${lim_target_dir}"
	        
	        # Update mode state and cache
	        HAS_LOCAL_MODE=true
	        LOCAL_SOURCE_REPO="${lim_source_repo}"
	        LOCAL_TARGET_DIR="${lim_target_dir}"
	        ;;
	        
	    commit)
	        # Create commit mode structure  
	        mkdir -p "${lim_target_dir}/${SHARED_DIR}"
	        
	        # Write empty manifest with metadata
	                echo "" | write_manifest_with_entries "${COMMIT_MANIFEST_FILE}" "${lim_source_repo}" "${lim_target_dir}"
        
        # Update mode state and cache
        HAS_COMMIT_MODE=true
        COMMIT_SOURCE_REPO="${lim_source_repo}"
        COMMIT_TARGET_DIR="${lim_target_dir}"
        ;;
        
    *)
        error "Invalid target mode: ${lim_target_mode}. Must be 'local' or 'commit'"
        ;;
esac
}

# Check if lazy initialization is needed for a mode
#
# Returns success only when one mode exists and the other doesn't.
#
# Globals:
#   HAS_LOCAL_MODE - Local mode state
#   HAS_COMMIT_MODE - Commit mode state
#
# Arguments:
#   $1 - Target mode: "local" or "commit"
#
# Outputs:
#   None
#
# Returns:
#   0 if lazy initialization needed
#   1 otherwise
#
needs_lazy_init() {
	nli_target_mode="${1}"
	
	case "${nli_target_mode}" in
	    local)
	        [ "${HAS_LOCAL_MODE}" = "false" ] && [ "${HAS_COMMIT_MODE}" = "true" ]
	        ;;
	    commit)
	        [ "${HAS_COMMIT_MODE}" = "false" ] && [ "${HAS_LOCAL_MODE}" = "true" ]
	        ;;
	    *)
	        return 1
	        ;;
	esac
}

# Conflict Resolution Utilities
# =============================

# Get all .mdc files that would be deployed by a manifest
#
# Core function for conflict resolution - determines which individual files
# would be deployed by expanding rulesets into their component files.
# Returns just filenames (not paths) for file-level conflict detection.
#
# Globals:
#   REPO_DIR - Repository directory for resolving entries
#
# Arguments:
#   $1 - Manifest file path
#
# Outputs:
#   Stdout: One filename per line (just filename, not full path)
#
# Returns:
#   0 on success
#   1 if manifest file doesn't exist
#
get_files_from_manifest() {
	gffm_manifest_file="${1}"
	
	if [ ! -f "${gffm_manifest_file}" ]; then
	    return 1
	fi
	
	# Use the global repository directory
	gffm_repo_dir="${REPO_DIR}"
	
	# Get all entries from the manifest
	gffm_entries=$(read_manifest_entries "${gffm_manifest_file}" 2>/dev/null || true)
	
	if [ -n "${gffm_entries}" ]; then
	    echo "${gffm_entries}" | while IFS= read -r gffm_entry; do
	        if [ -n "${gffm_entry}" ]; then
	            # Get the source path for this entry
	            gffm_source_path="${gffm_repo_dir}/${gffm_entry}"
	            
	            if [ -f "${gffm_source_path}" ]; then
	                # Single file - extract just the filename
	                basename "${gffm_source_path}"
	            elif [ -d "${gffm_source_path}" ]; then
	                # Directory (ruleset) - list all .mdc files in it
	                find "${gffm_source_path}" -name "*.mdc" -type f -o -name "*.mdc" -type l | \
	                while IFS= read -r gffm_rule_file; do
	                    basename "${gffm_rule_file}"
	                done
	            fi
	        fi
	    done
	fi
}

# Remove local manifest entries that would deploy the given filename
#
# Handles complex conflict resolution logic for partial ruleset conflicts.
# For individual rules, removes the conflicting entry. For rulesets, only
# removes if the exact same ruleset exists in commit mode - otherwise
# preserves the local ruleset and lets sync handle file-level conflicts.
#
# This preserves user intent: if they have a local ruleset with extra rules,
# don't remove the whole thing just because one file conflicts.
#
# Globals:
#   LOCAL_MANIFEST_FILE - Local manifest to modify
#   COMMIT_MANIFEST_FILE - Commit manifest to check for exact matches
#   REPO_DIR - Repository directory for resolving paths
#
# Arguments:
#   $1 - Filename that would conflict
#
# Outputs:
#   None
#
# Returns:
#   0 always
#
remove_local_entries_deploying_file() {
	rledf_filename="${1}"
	
	# Get all local entries
	rledf_local_entries=$(read_manifest_entries "${LOCAL_MANIFEST_FILE}" 2>/dev/null || true)
	
	if [ -n "${rledf_local_entries}" ]; then
	    # Use a temporary file to avoid subshell issues
	    rledf_temp_entries=$(mktemp)
	    echo "${rledf_local_entries}" > "${rledf_temp_entries}"
	    
	    while IFS= read -r rledf_entry; do
	        if [ -n "${rledf_entry}" ]; then
	            # Check if this entry would deploy the target filename
	            rledf_source_path="${REPO_DIR}/${rledf_entry}"
	            
	            if [ -f "${rledf_source_path}" ]; then
	                # Single file - check if it matches
	                if [ "$(basename "${rledf_source_path}")" = "${rledf_filename}" ]; then
	                    remove_manifest_entry_from_file "${LOCAL_MANIFEST_FILE}" "${rledf_entry}"
	                fi
	            elif [ -d "${rledf_source_path}" ]; then
	                # Directory (ruleset) - check if it contains the file
	                if find "${rledf_source_path}" -name "${rledf_filename}" -type f -o -name "${rledf_filename}" -type l | \
	                       grep -q .; then
	                    # For rulesets containing a conflicting file, we have a partial conflict.
	                    # We should NOT remove the entire local ruleset because it may contain
	                    # other rules that should remain local. Instead, let the sync process
	                    # handle the file-level conflict (commit wins for individual files).
	                    #
	                    # The only case where we remove the entire local ruleset is if the
	                    # commit manifest contains the exact same ruleset entry.
	                    rledf_ruleset_path="${rledf_entry}"
	                    if [ -f "${COMMIT_MANIFEST_FILE}" ] && read_manifest_entries "${COMMIT_MANIFEST_FILE}" | grep -q "^${rledf_ruleset_path}$"; then
	                        # Exact same ruleset in both modes - remove from local (commit wins)
	                        remove_manifest_entry_from_file "${LOCAL_MANIFEST_FILE}" "${rledf_entry}"
	                    else
	                        # Partial conflict - keep local ruleset, let sync handle file-level conflicts
	                        continue
	                    fi
	                fi
	            fi
	        fi
	    done < "${rledf_temp_entries}"
	    
	    # Clean up temporary file
	    rm -f "${rledf_temp_entries}"
	fi
}



# Detect and resolve conflicts between commit and local modes
#
# Implements "commit wins" policy by removing local entries that would deploy
# the same files as commit mode. Works at file level, not just entry level,
# so "rules/rule1.mdc" conflicts with "rulesets/set1" if set1 contains rule1.
#
# Uses temporary files to avoid subshell variable issues in the conflict
# resolution loop.
#
# Globals:
#   HAS_COMMIT_MODE - Commit mode state
#   HAS_LOCAL_MODE - Local mode state
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   LOCAL_MANIFEST_FILE - Local manifest filename
#
# Arguments:
#   None
#
# Outputs:
#   None
#
# Returns:
#   0 always
#
resolve_conflicts() {
	if [ "${HAS_COMMIT_MODE}" = "false" ] || [ "${HAS_LOCAL_MODE}" = "false" ]; then
	    return 0  # No conflicts possible with single mode
	fi
	
	if [ ! -f "${COMMIT_MANIFEST_FILE}" ] || [ ! -f "${LOCAL_MANIFEST_FILE}" ]; then
	    return 0  # Can't have conflicts if manifests don't exist
	fi
	
	# Get all .mdc files that would be deployed by commit manifest
	rc_commit_files=$(get_files_from_manifest "${COMMIT_MANIFEST_FILE}" 2>/dev/null || true)
	
	if [ -n "${rc_commit_files}" ]; then
	    # Use a temporary file to avoid subshell issues
	    rc_temp_file=$(mktemp)
	    echo "${rc_commit_files}" > "${rc_temp_file}"
	    
	    # For each file that commit would deploy, remove any local entries that would deploy the same file
	    while IFS= read -r rc_filename; do
	        if [ -n "${rc_filename}" ]; then
	            remove_local_entries_deploying_file "${rc_filename}"
	        fi
	    done < "${rc_temp_file}"
	    
	    # Clean up temporary file
	    rm -f "${rc_temp_file}"
	fi
}

# Validation Utilities
# ===================

# Validate manifest file format (minimal implementation)
#
# Globals:
#   None
#
# Arguments:
#   $1 - Manifest file path
#
# Outputs:
#   Stderr: Warning messages for invalid format
#
# Returns:
#   0 if valid format
#   1 if invalid or missing
#
validate_manifest_format() {
	vmf_manifest_file="${1}"
	
	if [ ! -f "${vmf_manifest_file}" ]; then
	    return 1
	fi
	
	# Check if file is empty
	if [ ! -s "${vmf_manifest_file}" ]; then
	    warn "Manifest file ${vmf_manifest_file} is empty"
	    return 1
	fi
	
	# Check first line format
	vmf_first_line=$(head -n1 "${vmf_manifest_file}")
	if ! echo "${vmf_first_line}" | grep -q "	"; then
	    warn "Invalid manifest format in ${vmf_manifest_file}: First line must be 'source_repo<tab>target_dir'"
	    return 1
	fi
	
	return 0
}

# Validate that both manifests use the same source repository (hard error)
#
# Globals:
#   HAS_COMMIT_MODE - Commit mode state
#   HAS_LOCAL_MODE - Local mode state
#   COMMIT_SOURCE_REPO - Commit mode source repository
#   LOCAL_SOURCE_REPO - Local mode source repository
#
# Arguments:
#   None
#
# Outputs:
#   None
#
# Returns:
#   Never returns on error (calls error() function)
#   0 if valid or single mode
#
# Show detailed manifest integrity error with fix options
#
# Displays comprehensive error message for repository mismatches with
# copy-pasteable commands to resolve the issue. Provides three clear
# options for users to sync their manifests.
#
# Globals:
#   LOCAL_SOURCE_REPO - Local mode source repository
#   COMMIT_SOURCE_REPO - Commit mode source repository
#
# Arguments:
#   None
#
# Outputs:
#   Stderr: Detailed error message with fix options
#
# Returns:
#   None (function only outputs error message)
#
show_manifest_integrity_error() {
	cat >&2 << EOF
Error: Manifest integrity error - different source repositories detected:

  Local mode:  ${LOCAL_SOURCE_REPO}
  Commit mode: ${COMMIT_SOURCE_REPO}

To fix this, choose which repository you want to use for both modes:

Option 1: Switch local mode to match commit mode
  ai-rizz deinit --local -y && ai-rizz init ${COMMIT_SOURCE_REPO} --local

Option 2: Switch commit mode to match local mode  
  ai-rizz deinit --commit -y && ai-rizz init ${LOCAL_SOURCE_REPO} --commit

Option 3: Reset everything and start fresh
  ai-rizz deinit --all -y && ai-rizz init
EOF
}

validate_manifest_integrity() {
	if [ "${HAS_COMMIT_MODE}" = "true" ] && [ "${HAS_LOCAL_MODE}" = "true" ]; then
	    if [ "${COMMIT_SOURCE_REPO}" != "${LOCAL_SOURCE_REPO}" ]; then
	        show_manifest_integrity_error
	        exit 1
	    fi
	fi
}

# Commands
# ========

# Initialize the repository (progressive initialization)
#
# Creates local or commit mode with manifest file, target directory structure,
# and git excludes (for local mode). Prompts for missing parameters, validates
# mode compatibility, syncs source repository, and handles idempotent re-init.
# Supports progressive dual-mode by preserving existing mode configuration.
#
# Globals:
#   DEFAULT_TARGET_DIR - Default target directory
#   HAS_COMMIT_MODE - Commit mode state (read/modified)
#   HAS_LOCAL_MODE - Local mode state (read/modified)
#   COMMIT_SOURCE_REPO - Set if creating commit mode
#   LOCAL_SOURCE_REPO - Set if creating local mode
#   COMMIT_TARGET_DIR - Set if creating commit mode
#   LOCAL_TARGET_DIR - Set if creating local mode
#
# Arguments:
#   [source_repo]        - Repository URL (prompted if not provided)
#   [-d target_dir]      - Target directory (defaults to .cursor/rules)
#   [--local|-l]         - Initialize local mode (git-ignored)
#   [--commit|-c]        - Initialize commit mode (git-tracked)
#
# Outputs:
#   Stdout: Success message
#   Stderr: Error messages and prompts
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
cmd_init() {
	ci_source_repo=""
	ci_target_dir=""
	ci_mode=""
	
	# Parse arguments
	while [ $# -gt 0 ]; do
	    case "$1" in
	        -d)
	            ci_target_dir="$2"
	            shift 2
	            ;;
	        --local|-l)
	            ci_mode="local"
	            shift
	            ;;
	        --commit|-c)
	            ci_mode="commit"
	            shift
	            ;;
	        *)
	            if [ -z "${ci_source_repo}" ]; then
	                ci_source_repo="$1"
	                shift
	            else
	                error "Unknown argument: $1"
	            fi
	            ;;
	    esac
	done
	
	# Prompt for source repo if not provided
	if [ -z "${ci_source_repo}" ]; then
	    printf "Source repository URL: "
	    read -r ci_source_repo
	    if [ -z "${ci_source_repo}" ]; then
	        error "Source repository URL is required"
	    fi
	fi
	
	# Use default target directory if not provided
	if [ -z "${ci_target_dir}" ]; then
	    ci_target_dir="${DEFAULT_TARGET_DIR}"
	fi
	
	# Prompt for mode if not provided
	if [ -z "${ci_mode}" ]; then
	    printf "Mode [local/commit]: "
	    read -r ci_mode
	    if [ -z "${ci_mode}" ]; then
	        ci_mode="local"
	    fi
	fi
	
	    	# Validate mode
	case "${ci_mode}" in
	    local|commit)
	        ;;
	    *)
	        error "Invalid mode: ${ci_mode}. Must be 'local' or 'commit'"
	        ;;
	esac

	# If one mode already exists, use its source_repo (no override allowed)
	if [ "${HAS_COMMIT_MODE}" = "true" ] || [ "${HAS_LOCAL_MODE}" = "true" ]; then
	    existing_source_repo=""
	    if [ "${HAS_COMMIT_MODE}" = "true" ]; then
	        existing_source_repo="${COMMIT_SOURCE_REPO}"
	    else
	        existing_source_repo="${LOCAL_SOURCE_REPO}"
	    fi
	    
	    # Override user input silently
	    ci_source_repo="${existing_source_repo}"
	fi

	# Check if repository is already initialized in the requested mode
	case "${ci_mode}" in
	    local)
	        if [ "${HAS_LOCAL_MODE}" = "true" ]; then
	            # Check if parameters match existing configuration
	            if [ "${LOCAL_SOURCE_REPO}" = "${ci_source_repo}" ] && [ "${LOCAL_TARGET_DIR}" = "${ci_target_dir}" ]; then
	                echo "Initialized ai-rizz with source: ${ci_source_repo}, target: ${ci_target_dir}, mode: ${ci_mode}"
	                return 0  # Idempotent success
	            else
	                error "Local mode already initialized with different parameters. Use 'ai-rizz deinit --local' first."
	            fi
	        fi
	        ;;
	    commit)
	        if [ "${HAS_COMMIT_MODE}" = "true" ]; then
	            # Check if parameters match existing configuration
	            if [ "${COMMIT_SOURCE_REPO}" = "${ci_source_repo}" ] && [ "${COMMIT_TARGET_DIR}" = "${ci_target_dir}" ]; then
	                echo "Initialized ai-rizz with source: ${ci_source_repo}, target: ${ci_target_dir}, mode: ${ci_mode}"
	                return 0  # Idempotent success
	            else
	                error "Commit mode already initialized with different parameters. Use 'ai-rizz deinit --commit' first."
	            fi
	        fi
	        ;;
	esac
	
	# Ensure git repository context
	if [ ! -d ".git" ]; then
	    error "Not in a git repository"
	fi
	
	# Clone/sync source repository first
	if ! git_sync "${ci_source_repo}"; then
	    error "Failed to initialize: repository unavailable"
	fi
	
	# Initialize the requested mode
	case "${ci_mode}" in
	    local)
	        # Create local mode structure
	        mkdir -p "${ci_target_dir}/${LOCAL_DIR}"
	        
	        # Write empty manifest with metadata
	        echo "" | write_manifest_with_entries "${LOCAL_MANIFEST_FILE}" "${ci_source_repo}" "${ci_target_dir}"
	        
	        # Update git excludes
	        setup_local_mode_excludes "${ci_target_dir}"
	        
	        # Update mode state and cache
	        HAS_LOCAL_MODE=true
	        LOCAL_SOURCE_REPO="${ci_source_repo}"
	        LOCAL_TARGET_DIR="${ci_target_dir}"
	        ;;
	        
	    commit)
	        # Create commit mode structure  
	        mkdir -p "${ci_target_dir}/${SHARED_DIR}"
	        
	        # Write empty manifest with metadata
	        echo "" | write_manifest_with_entries "${COMMIT_MANIFEST_FILE}" "${ci_source_repo}" "${ci_target_dir}"
	        
	        # Update mode state and cache
	        HAS_COMMIT_MODE=true
	        COMMIT_SOURCE_REPO="${ci_source_repo}"
	        COMMIT_TARGET_DIR="${ci_target_dir}"
	        ;;
	esac
	
	echo "Initialized ai-rizz with source: ${ci_source_repo}, target: ${ci_target_dir}, mode: ${ci_mode}"
	return 0
}

# Recursively remove empty parent directories
#
# Globals:
#   HOME - User home directory (used as stop condition)
#
# Arguments:
#   $1 - Directory to check and potentially remove
#
# Outputs:
#   Stdout: Messages about removed directories
#
# Returns:
#   0 always
#
cleanup_empty_parents() {
  cep_dir="${1}"
  # Check if directory exists and is empty
  if [ -d "${cep_dir}" ] && [ -z "$(ls -A "${cep_dir}")" ]; then
	cep_parent_dir=$(dirname "${cep_dir}")
	echo "Removing empty directory: ${cep_dir}"
	rmdir "${cep_dir}"
	
	# Stop at filesystem root, home directory, or current directory
	if [ "${cep_parent_dir}" != "/" ] && [ "${cep_parent_dir}" != "${HOME}" ] && [ "${cep_parent_dir}" != "." ]; then
	  cleanup_empty_parents "${cep_parent_dir}"
	fi
  fi
}

# Deinitialize the repository (progressive mode-aware)
#
# Removes specified mode(s) including manifest files, target directories,
# and git excludes. Prompts for confirmation unless -y flag used. Supports
# selective removal (--local, --commit) or complete removal (--all).
# Cleans up empty parent directories after removal.
#
# Globals:
#   HAS_COMMIT_MODE - Commit mode state (read/modified)
#   HAS_LOCAL_MODE - Local mode state (read/modified)
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   LOCAL_TARGET_DIR - Local target directory
#   COMMIT_TARGET_DIR - Commit target directory
#   LOCAL_DIR - Local directory name
#   SHARED_DIR - Shared directory name
#
# Arguments:
#   [-y]                 - Skip confirmation prompts
#   [--local|-l]         - Remove local mode only
#   [--commit|-c]        - Remove commit mode only
#   [--all|-a]           - Remove all modes (default if both exist)
#
# Outputs:
#   Stdout: Confirmation prompts and success messages
#   Stderr: Error messages
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
cmd_deinit() {
	cd_force=false
	cd_mode=""
	
	# Parse arguments
	while [ $# -gt 0 ]; do
	    case "$1" in
	        -y)
	            cd_force=true
	            shift
	            ;;
	        --local|-l)
	            cd_mode="local"
	            shift
	            ;;
	        --commit|-c)
	            cd_mode="commit"
	            shift
	            ;;
	        --all|-a)
	            cd_mode="all"
	            shift
	            ;;
	        *)
	            error "Unknown argument: $1"
	            ;;
	    esac
	done
	
	# Check if any mode is initialized
	if [ "${HAS_COMMIT_MODE}" = "false" ] && [ "${HAS_LOCAL_MODE}" = "false" ]; then
	    error "No ai-rizz configuration found."
	fi
	
	# Prompt for mode if not provided
	if [ -z "${cd_mode}" ]; then
	    if [ "${HAS_LOCAL_MODE}" = "true" ] && [ "${HAS_COMMIT_MODE}" = "true" ]; then
	        printf "Which mode to remove [local/commit/all]: "
	        read -r cd_mode
	        if [ -z "${cd_mode}" ]; then
	            cd_mode="all"
	        fi
	    elif [ "${HAS_LOCAL_MODE}" = "true" ]; then
	        cd_mode="local"
	    elif [ "${HAS_COMMIT_MODE}" = "true" ]; then
	        cd_mode="commit"
	    fi
	fi
	
	# Validate mode
	case "${cd_mode}" in
	    local|commit|all)
	        ;;
	    *)
	        error "Invalid mode: ${cd_mode}. Must be 'local', 'commit', or 'all'"
	        ;;
	esac
	
	# Determine what to remove
	cd_remove_local=false
	cd_remove_commit=false
	
	case "${cd_mode}" in
	    local)
	        if [ "${HAS_LOCAL_MODE}" = "false" ]; then
	            error "Local mode not initialized"
	        fi
	        cd_remove_local=true
	        ;;
	    commit)
	        if [ "${HAS_COMMIT_MODE}" = "false" ]; then
	            error "Commit mode not initialized"
	        fi
	        cd_remove_commit=true
	        ;;
	    all)
	        cd_remove_local=true
	        cd_remove_commit=true
	        ;;
	esac
	
	# Build confirmation message
	cd_items_to_remove=""
	if [ "${cd_remove_local}" = "true" ] && [ "${HAS_LOCAL_MODE}" = "true" ]; then
	    cd_items_to_remove="${cd_items_to_remove} ${LOCAL_MANIFEST_FILE} ${LOCAL_TARGET_DIR}/${LOCAL_DIR}"
	fi
	if [ "${cd_remove_commit}" = "true" ] && [ "${HAS_COMMIT_MODE}" = "true" ]; then
	    cd_items_to_remove="${cd_items_to_remove} ${COMMIT_MANIFEST_FILE} ${COMMIT_TARGET_DIR}/${SHARED_DIR}"
	fi
	
	# Confirm deletion
	if ! ${cd_force} && [ -n "${cd_items_to_remove}" ]; then
	    echo "This will delete:${cd_items_to_remove}"
	    printf "Are you sure? [y/N] "
	    read -r cd_confirm
	    if [ "${cd_confirm}" != "y" ] && [ "${cd_confirm}" != "Y" ]; then
	        echo "Canceled"
	        return 0
	    fi
	fi
	
	# Save target directories for cleanup before clearing them
	cd_local_target_for_cleanup="${LOCAL_TARGET_DIR}"
	cd_commit_target_for_cleanup="${COMMIT_TARGET_DIR}"
	
	# Remove local mode
	if [ "${cd_remove_local}" = "true" ] && [ "${HAS_LOCAL_MODE}" = "true" ]; then
	    # Remove from git excludes
	    remove_local_mode_excludes "${LOCAL_TARGET_DIR}"
	    
	    # Remove files
	    rm -rf "${LOCAL_TARGET_DIR:?}/${LOCAL_DIR}"
	    rm -f "${LOCAL_MANIFEST_FILE}"
	    
	    # Update mode state
	    HAS_LOCAL_MODE=false
	    LOCAL_SOURCE_REPO=""
	    LOCAL_TARGET_DIR=""
	    
	    echo "Removed local mode configuration"
	fi
	
	# Remove commit mode
	if [ "${cd_remove_commit}" = "true" ] && [ "${HAS_COMMIT_MODE}" = "true" ]; then
	    # Remove files (no git exclude changes needed for commit mode)
	    rm -rf "${COMMIT_TARGET_DIR:?}/${SHARED_DIR}"
	    rm -f "${COMMIT_MANIFEST_FILE}"
	    
	    # Update mode state
	    HAS_COMMIT_MODE=false
	    COMMIT_SOURCE_REPO=""
	    COMMIT_TARGET_DIR=""
	    
	    echo "Removed commit mode configuration"
	fi
	
	# Clean up empty parent directories using saved values
	if [ "${cd_remove_local}" = "true" ] && [ -n "${cd_local_target_for_cleanup}" ]; then
	    cd_parent_dir=$(dirname "${cd_local_target_for_cleanup}/${LOCAL_DIR}")
	    if [ "${cd_parent_dir}" != "." ] && [ "${cd_parent_dir}" != "/" ]; then
	        cleanup_empty_parents "${cd_parent_dir}"
	    fi
	fi
	
	if [ "${cd_remove_commit}" = "true" ] && [ -n "${cd_commit_target_for_cleanup}" ]; then
	    cd_parent_dir=$(dirname "${cd_commit_target_for_cleanup}/${SHARED_DIR}")
	    if [ "${cd_parent_dir}" != "." ] && [ "${cd_parent_dir}" != "/" ]; then
	        cleanup_empty_parents "${cd_parent_dir}"
	    fi
	fi
	
	return 0
}

# List available rules and rulesets (multi-mode aware)
#
# Shows rules and rulesets with glyphs indicating installation status.
# Handles dual-mode conflict resolution (commit overrides local), expands
# rulesets to show contents, and uses tree command when available for
# better formatting. Syncs repository before listing.
#
# Globals:
#   HAS_COMMIT_MODE - Commit mode state
#   HAS_LOCAL_MODE - Local mode state
#   COMMIT_SOURCE_REPO - Commit mode source repository
#   LOCAL_SOURCE_REPO - Local mode source repository
#   REPO_DIR - Repository directory
#   COMMITTED_GLYPH - Glyph for committed items
#   LOCAL_GLYPH - Glyph for local items
#   UNINSTALLED_GLYPH - Glyph for uninstalled items
#
# Arguments:
#   None
#
# Outputs:
#   Stdout: Formatted list of rules and rulesets
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
cmd_list() {
	# Check if any mode is initialized
	if [ "${HAS_COMMIT_MODE}" = "false" ] && [ "${HAS_LOCAL_MODE}" = "false" ]; then
	    error "No ai-rizz configuration found. Run 'ai-rizz init' first."
	fi
	
	# Validate manifest integrity (hard error for mismatched source repos)
	validate_manifest_integrity
	
	# Validate manifest format for all existing manifests
	if [ "${HAS_LOCAL_MODE}" = "true" ]; then
	    validate_manifest_format "${LOCAL_MANIFEST_FILE}" || error "Corrupted local manifest file"
	fi
	if [ "${HAS_COMMIT_MODE}" = "true" ]; then
	    validate_manifest_format "${COMMIT_MANIFEST_FILE}" || error "Corrupted commit manifest file"
	fi
	
	# Get source repo from any available mode
	cl_source_repo=""
	if [ "${HAS_COMMIT_MODE}" = "true" ]; then
	    cl_source_repo="${COMMIT_SOURCE_REPO}"
	elif [ "${HAS_LOCAL_MODE}" = "true" ]; then
	    cl_source_repo="${LOCAL_SOURCE_REPO}"
	fi
	
	# Update source repository
	git_sync "${cl_source_repo}"
	
	# Helper function to check if an item is installed in any mode
	is_installed() {
	    cl_is_installed_item="${1}"
	    cl_is_installed_status="uninstalled"
	    
	    # Helper to check if item is covered by rulesets in a manifest
	    check_rulesets_for_item() {
	        cl_check_manifest_file="${1}"
	        cl_check_item_basename=$(basename "${cl_is_installed_item}")
	        cl_check_entries=""
	        
	        cl_check_entries=$(read_manifest_entries "${cl_check_manifest_file}" 2>/dev/null) || return 1
	        
	        # Use a for loop instead of while to avoid subshell issues
	        for cl_check_entry in ${cl_check_entries}; do
	            if [ -n "${cl_check_entry}" ] && echo "${cl_check_entry}" | grep -q "^rulesets/"; then
	                # Check if this ruleset contains the item
	                cl_check_ruleset_dir="${REPO_DIR}/${cl_check_entry}"
	                if [ -d "${cl_check_ruleset_dir}" ] && [ -f "${cl_check_ruleset_dir}/${cl_check_item_basename}" ]; then
	                    return 0  # Found in ruleset
	                fi
	            fi
	        done
	        return 1  # Not found in any ruleset
	    }
	    
	    # Check local mode first (weaker glyph)
	    if [ "${HAS_LOCAL_MODE}" = "true" ]; then
	        # Check if item is directly in manifest
	        if read_manifest_entries "${LOCAL_MANIFEST_FILE}" 2>/dev/null | grep -q "^${cl_is_installed_item}$"; then
	            cl_is_installed_status="local"
	        elif check_rulesets_for_item "${LOCAL_MANIFEST_FILE}"; then
	            cl_is_installed_status="local"
	        fi
	    fi
	    
	    # Check commit mode (stronger glyph - overrides local)
	    if [ "${HAS_COMMIT_MODE}" = "true" ]; then
	        # Check if item is directly in manifest
	        if read_manifest_entries "${COMMIT_MANIFEST_FILE}" 2>/dev/null | grep -q "^${cl_is_installed_item}$"; then
	            cl_is_installed_status="committed"
	        elif check_rulesets_for_item "${COMMIT_MANIFEST_FILE}"; then
	            cl_is_installed_status="committed"
	        fi
	    fi
	    
	    echo "${cl_is_installed_status}"
	}
	
	# Display rules
	echo "Available rules:"
	cl_rules=$(find "${REPO_DIR}/rules" -name "*.mdc" | sort 2>/dev/null)
	if [ -z "${cl_rules}" ]; then
	    echo "  No rules found"
	else
	    for cl_rule in ${cl_rules}; do
	        cl_rule_name=$(basename "${cl_rule}")
	        cl_rule_path="rules/${cl_rule_name}"
	        cl_status=$(is_installed "${cl_rule_path}")
	        
	        case "${cl_status}" in
	            committed)
	                printf "  %s %s\n" "${COMMITTED_GLYPH}" "${cl_rule_name}"
	                ;;
	            local)
	                printf "  %s %s\n" "${LOCAL_GLYPH}" "${cl_rule_name}"
	                ;;
	            *)
	                printf "  %s %s\n" "${UNINSTALLED_GLYPH}" "${cl_rule_name}"
	                ;;
	        esac
	    done
	fi
	echo ""
	
	# Display rulesets
	echo "Available rulesets:"
	cl_rulesets=$(find "${REPO_DIR}/rulesets" -mindepth 1 -maxdepth 1 -type d | sort 2>/dev/null)
	if [ -z "${cl_rulesets}" ]; then
	    echo "  No rulesets found"
	else
	    for cl_ruleset in ${cl_rulesets}; do
	        cl_ruleset_name=$(basename "${cl_ruleset}")
	        cl_ruleset_path="rulesets/${cl_ruleset_name}"
	        cl_status=$(is_installed "${cl_ruleset_path}")
	        
	        # Display ruleset with installation status
	        case "${cl_status}" in
	            committed)
	                printf "  %s %s\n" "${COMMITTED_GLYPH}" "${cl_ruleset_name}"
	                ;;
	            local)
	                printf "  %s %s\n" "${LOCAL_GLYPH}" "${cl_ruleset_name}"
	                ;;
	            *)
	                printf "  %s %s\n" "${UNINSTALLED_GLYPH}" "${cl_ruleset_name}"
	                ;;
	        esac
	        
	                # Use tree to display ruleset contents (filter to .mdc files only)
        if [ -d "${cl_ruleset}" ]; then
            # Check if tree command exists
            if command -v tree >/dev/null 2>&1; then
                # Use tree with pattern matching to show only .mdc files and symlinks
                (cd "${cl_ruleset}" && tree -P "*.mdc" -L 1 --noreport) | tail -n +2 | sed 's/^/    /' | sed 's/ -> .*$//'
            else
                # Fallback if tree is not available
                find "${cl_ruleset}" -maxdepth 1 \( -name "*.mdc" -type f \) -o \( -name "*.mdc" -type l \) -exec basename {} \; | sort | sed 's/^/    ├── /'
            fi
        fi
	    done
	fi
	
	return 0
}

# Check for rule downgrade conflicts
#
# Prevents adding individual rules to local mode when they're part of 
# committed rulesets. This maintains ruleset integrity by ensuring
# complete rulesets stay together.
#
# Globals:
#   HAS_COMMIT_MODE - Commit mode state
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   REPO_DIR - Repository directory
#
# Arguments:
#   $1 - Rule name (with .mdc extension)
#   $2 - Target mode (local/commit)
#
# Outputs:
#   Stderr: Warning message if conflict detected
#
# Returns:
#   0 if no conflict (rule can be added)
#   1 if conflict detected (rule should be skipped)
#
check_rule_downgrade_conflict() {
	crdc_rule="$1"
	crdc_mode="$2"
	
	# Only check for downgrade conflicts (local mode with commit mode active)
	if [ "$crdc_mode" = "local" ] && [ "$HAS_COMMIT_MODE" = "true" ]; then
		# Check if this rule is part of any committed ruleset
		rule_filename=$(basename "rules/$crdc_rule")
		commit_entries=$(read_manifest_entries "$COMMIT_MANIFEST_FILE" 2>/dev/null || true)
		
		if [ -n "$commit_entries" ]; then
			# Use a temporary file to avoid subshell issues with pipes
			temp_file=$(mktemp)
			echo "$commit_entries" > "$temp_file"
			
			while IFS= read -r entry; do
				if [ -n "$entry" ]; then
					entry_path="$REPO_DIR/$entry"
					if [ -d "$entry_path" ]; then
						# This is a ruleset - check if it contains our rule
						if find "$entry_path" -name "$rule_filename" -type f -o -name "$rule_filename" -type l | grep -q .; then
							warn "Cannot add individual rule '$crdc_rule' to local mode: it's part of committed ruleset '$entry'. Use 'ai-rizz add-ruleset $(basename "$entry") --local' to move the entire ruleset."
							rm -f "$temp_file"
							return 1
						fi
					fi
				fi
			done < "$temp_file"
			
			rm -f "$temp_file"
		fi
	fi
	
	return 0
}

# Add rule(s) to the repository (progressive mode-aware)
#
# Adds individual rules to specified mode, handling lazy initialization,
# conflict resolution, and downgrade prevention. Prevents adding individual
# rules to local mode when they're part of committed rulesets. Auto-detects
# mode when only one exists, migrates rules between modes on conflicts.
#
# Globals:
#   HAS_COMMIT_MODE - Commit mode state
#   HAS_LOCAL_MODE - Local mode state
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   LOCAL_TARGET_DIR - Local target directory
#   COMMIT_TARGET_DIR - Commit target directory
#   LOCAL_DIR - Local directory name
#   SHARED_DIR - Shared directory name
#   LOCAL_SOURCE_REPO - Local mode source repository
#   COMMIT_SOURCE_REPO - Commit mode source repository
#   REPO_DIR - Repository directory
#
# Arguments:
#   <rule>...            - Rule names (.mdc extension optional)
#   [--local|-l]         - Add to local mode (git-ignored)
#   [--commit|-c]        - Add to commit mode (git-tracked)
#
# Outputs:
#   Stdout: Success messages for each added rule
#   Stderr: Warning messages for conflicts or missing rules
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
cmd_add_rule() {
	car_mode=""
	car_rules=""
	
	# Parse arguments
	while [ $# -gt 0 ]; do
	    case "$1" in
	        --local|-l)
	            car_mode="local"
	            shift
	            ;;
	        --commit|-c)
	            car_mode="commit"
	            shift
	            ;;
	        *)
	            if [ -z "${car_rules}" ]; then
	                car_rules="$1"
	            else
	                car_rules="${car_rules} $1"
	            fi
	            shift
	            ;;
	    esac
	done
	
	# Check if any mode is initialized
	if [ "${HAS_COMMIT_MODE}" = "false" ] && [ "${HAS_LOCAL_MODE}" = "false" ]; then
	    error "No ai-rizz configuration found. Run 'ai-rizz init' first."
	fi
	
	# Validate manifest integrity (hard error for mismatched source repos)
	validate_manifest_integrity
	
	# Smart mode selection
	if [ -z "${car_mode}" ]; then
	    if [ "${HAS_LOCAL_MODE}" = "true" ] && [ "${HAS_COMMIT_MODE}" = "false" ]; then
	        car_mode="local"
	    elif [ "${HAS_COMMIT_MODE}" = "true" ] && [ "${HAS_LOCAL_MODE}" = "false" ]; then
	        car_mode="commit"
	    else
	        error "Both modes available. Please specify --local or --commit flag."
	    fi
	fi
	
	# Check if lazy initialization is needed and track it
	car_lazy_init_occurred=false
	if needs_lazy_init "${car_mode}"; then
	    lazy_init_mode "${car_mode}"
	    car_lazy_init_occurred=true
	fi
	
	# Select manifest and target based on mode
	case "${car_mode}" in
	    local)
	        car_manifest_file="${LOCAL_MANIFEST_FILE}"
	        car_target_dir="${LOCAL_TARGET_DIR}/${LOCAL_DIR}"
	        # Update source repository
	        git_sync "${LOCAL_SOURCE_REPO}"
	        ;;
	    commit)
	        car_manifest_file="${COMMIT_MANIFEST_FILE}"
	        car_target_dir="${COMMIT_TARGET_DIR}/${SHARED_DIR}"
	        # Update source repository
	        git_sync "${COMMIT_SOURCE_REPO}"
	        ;;
	    *)
	        error "Invalid mode: ${car_mode}"
	        ;;
	esac
	
	# Process each rule
	for car_rule in ${car_rules}; do
	    # Add .mdc extension if not present
	    case "${car_rule}" in
	        *".mdc") ;;  # Already has extension
	        *) car_rule="${car_rule}.mdc" ;;  # Add extension
	    esac
	    
	    car_rule_path="rules/${car_rule}"
	    
	    # Check if rule exists in source repo
	    if [ ! -f "${REPO_DIR}/${car_rule_path}" ]; then
	        warn "Rule not found: ${car_rule_path}"
	        continue
	    fi
	    
	    # Check for downgrade conflicts first
	    if ! check_rule_downgrade_conflict "${car_rule}" "${car_mode}"; then
	        continue  # Skip this rule, conflict detected
	    fi
	    
	    # Check if rule exists in opposite mode (conflict resolution)
	    # Skip migration check if we just lazy-initialized the target mode (it's empty)
	    if [ "${car_lazy_init_occurred}" = "false" ]; then
	        case "${car_mode}" in
	            local)
	                if [ "${HAS_COMMIT_MODE}" = "true" ]; then
	                    if read_manifest_entries "${COMMIT_MANIFEST_FILE}" | grep -q "^${car_rule_path}$"; then
	                        # Remove from commit mode, add to local mode
	                        remove_manifest_entry_from_file "${COMMIT_MANIFEST_FILE}" "${car_rule_path}"
	                    fi
	                fi
	                ;;
	            commit)
	                if [ "${HAS_LOCAL_MODE}" = "true" ]; then
	                    if read_manifest_entries "${LOCAL_MANIFEST_FILE}" | grep -q "^${car_rule_path}$"; then
	                        # Remove from local mode, add to commit mode
	                        remove_manifest_entry_from_file "${LOCAL_MANIFEST_FILE}" "${car_rule_path}"
	                    fi
	                fi
	                ;;
	        esac
	    else
	        # Lazy initialization occurred - need to migrate from opposite mode
	        case "${car_mode}" in
	            local)
	                # We just created local mode, migrate from commit mode if rule exists there
	                if [ "${HAS_COMMIT_MODE}" = "true" ]; then
	                    if read_manifest_entries "${COMMIT_MANIFEST_FILE}" | grep -q "^${car_rule_path}$"; then
	                        remove_manifest_entry_from_file "${COMMIT_MANIFEST_FILE}" "${car_rule_path}"
	                    fi
	                fi
	                ;;
	            commit)
	                # We just created commit mode, migrate from local mode if rule exists there
	                if [ "${HAS_LOCAL_MODE}" = "true" ]; then
	                    if read_manifest_entries "${LOCAL_MANIFEST_FILE}" | grep -q "^${car_rule_path}$"; then
	                        remove_manifest_entry_from_file "${LOCAL_MANIFEST_FILE}" "${car_rule_path}"
	                    fi
	                fi
	                ;;
	        esac
	    fi
	    
	    # Check if target directory is writable before adding to manifest
	    if [ ! -w "${car_target_dir}" ]; then
	        error "Cannot write to target directory: ${car_target_dir} (permission denied)"
	    fi
	    
	    # Add to target manifest
	    add_manifest_entry_to_file "${car_manifest_file}" "${car_rule_path}"
	    
	    echo "Added rule: ${car_rule_path}"
	done
	
	# Sync to update file locations
	sync_all_modes
	
	return 0
}

# Add ruleset(s) to the repository (progressive mode-aware)
#
# Adds entire rulesets to specified mode, handling lazy initialization and
# conflict resolution. Auto-detects mode when only one exists, migrates
# rulesets between modes on conflicts. Rulesets deploy all contained .mdc
# files as individual rules in the target directory.
#
# Globals:
#   HAS_COMMIT_MODE - Commit mode state
#   HAS_LOCAL_MODE - Local mode state
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   LOCAL_SOURCE_REPO - Local mode source repository
#   COMMIT_SOURCE_REPO - Commit mode source repository
#   REPO_DIR - Repository directory
#
# Arguments:
#   <ruleset>...         - Ruleset names (directory names under rulesets/)
#   [--local|-l]         - Add to local mode (git-ignored)
#   [--commit|-c]        - Add to commit mode (git-tracked)
#
# Outputs:
#   Stdout: Success messages for each added ruleset
#   Stderr: Warning messages for missing rulesets
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
cmd_add_ruleset() {
	cars_mode=""
	cars_rulesets=""
	
	# Parse arguments
	while [ $# -gt 0 ]; do
	    case "$1" in
	        --local|-l)
	            cars_mode="local"
	            shift
	            ;;
	        --commit|-c)
	            cars_mode="commit"
	            shift
	            ;;
	        *)
	            if [ -z "${cars_rulesets}" ]; then
	                cars_rulesets="$1"
	            else
	                cars_rulesets="${cars_rulesets} $1"
	            fi
	            shift
	            ;;
	    esac
	done
	
	# Check if any mode is initialized
	if [ "${HAS_COMMIT_MODE}" = "false" ] && [ "${HAS_LOCAL_MODE}" = "false" ]; then
	    error "No ai-rizz configuration found. Run 'ai-rizz init' first."
	fi
	
	# Validate manifest integrity (hard error for mismatched source repos)
	validate_manifest_integrity
	
	# Smart mode selection
	if [ -z "${cars_mode}" ]; then
	    if [ "${HAS_LOCAL_MODE}" = "true" ] && [ "${HAS_COMMIT_MODE}" = "false" ]; then
	        cars_mode="local"
	    elif [ "${HAS_COMMIT_MODE}" = "true" ] && [ "${HAS_LOCAL_MODE}" = "false" ]; then
	        cars_mode="commit"
	    else
	        error "Both modes available. Please specify --local or --commit flag."
	    fi
	fi
	
	# Check if lazy initialization is needed and track it
	cars_lazy_init_occurred=false
	if needs_lazy_init "${cars_mode}"; then
	    lazy_init_mode "${cars_mode}"
	    cars_lazy_init_occurred=true
	fi
	
	# Select manifest and target based on mode
	case "${cars_mode}" in
	    local)
	        cars_manifest_file="${LOCAL_MANIFEST_FILE}"
	        # Update source repository
	        git_sync "${LOCAL_SOURCE_REPO}"
	        ;;
	    commit)
	        cars_manifest_file="${COMMIT_MANIFEST_FILE}"
	        # Update source repository
	        git_sync "${COMMIT_SOURCE_REPO}"
	        ;;
	    *)
	        error "Invalid mode: ${cars_mode}"
	        ;;
	esac
	
	# Process each ruleset
	for cars_ruleset in ${cars_rulesets}; do
	    cars_ruleset_path="rulesets/${cars_ruleset}"
	    
	    # Check if ruleset exists in source repo
	    if [ ! -d "${REPO_DIR}/${cars_ruleset_path}" ]; then
	        warn "Ruleset not found: ${cars_ruleset_path}"
	        continue
	    fi
	    
	    # Check if ruleset exists in opposite mode (conflict resolution)
	    # Skip migration check if we just lazy-initialized the target mode (it's empty)
	    if [ "${cars_lazy_init_occurred}" = "false" ]; then
	        case "${cars_mode}" in
	            local)
	                if [ "${HAS_COMMIT_MODE}" = "true" ]; then
	                    if read_manifest_entries "${COMMIT_MANIFEST_FILE}" | grep -q "^${cars_ruleset_path}$"; then
	                        # Remove from commit mode, add to local mode
	                        remove_manifest_entry_from_file "${COMMIT_MANIFEST_FILE}" "${cars_ruleset_path}"
	                    fi
	                fi
	                ;;
	            commit)
	                if [ "${HAS_LOCAL_MODE}" = "true" ]; then
	                    if read_manifest_entries "${LOCAL_MANIFEST_FILE}" | grep -q "^${cars_ruleset_path}$"; then
	                        # Remove from local mode, add to commit mode
	                        remove_manifest_entry_from_file "${LOCAL_MANIFEST_FILE}" "${cars_ruleset_path}"
	                    fi
	                fi
	                ;;
	        esac
	    else
	        # Lazy initialization occurred - need to migrate from opposite mode
	        case "${cars_mode}" in
	            local)
	                # We just created local mode, migrate from commit mode if ruleset exists there
	                if [ "${HAS_COMMIT_MODE}" = "true" ]; then
	                    if read_manifest_entries "${COMMIT_MANIFEST_FILE}" | grep -q "^${cars_ruleset_path}$"; then
	                        remove_manifest_entry_from_file "${COMMIT_MANIFEST_FILE}" "${cars_ruleset_path}"
	                    fi
	                fi
	                ;;
	            commit)
	                # We just created commit mode, migrate from local mode if ruleset exists there
	                if [ "${HAS_LOCAL_MODE}" = "true" ]; then
	                    if read_manifest_entries "${LOCAL_MANIFEST_FILE}" | grep -q "^${cars_ruleset_path}$"; then
	                        remove_manifest_entry_from_file "${LOCAL_MANIFEST_FILE}" "${cars_ruleset_path}"
	                    fi
	                fi
	                ;;
	        esac
	    fi
	    
	    # Add to target manifest
	    add_manifest_entry_to_file "${cars_manifest_file}" "${cars_ruleset_path}"
	    
	    echo "Added ruleset: ${cars_ruleset_path}"
	done
	
	# Sync to update file locations
	sync_all_modes
	
	return 0
}

# Remove rule(s) from the repository (mode-aware)
#
# Removes individual rules from whichever mode contains them. Auto-detects
# which mode has each rule and removes from the appropriate manifest.
# Triggers sync to clean up target directories after removal.
#
# Globals:
#   HAS_COMMIT_MODE - Commit mode state
#   HAS_LOCAL_MODE - Local mode state
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#
# Arguments:
#   <rule>...            - Rule names (.mdc extension optional)
#
# Outputs:
#   Stdout: Success messages for each removed rule
#   Stderr: Warning messages for rules not found
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
cmd_remove_rule() {
	# Check if any mode is initialized
	if [ "${HAS_COMMIT_MODE}" = "false" ] && [ "${HAS_LOCAL_MODE}" = "false" ]; then
	    error "No ai-rizz configuration found. Run 'ai-rizz init' first."
	fi
	
	# Validate manifest integrity (hard error for mismatched source repos)
	validate_manifest_integrity
	
	# Process each rule
	for rule in "$@"; do
	    # Add .mdc extension if not present
	    case "$rule" in
	        *".mdc") ;;  # Already has extension
	        *) rule="${rule}.mdc" ;;  # Add extension
	    esac
	    
	    rule_path="rules/$rule"
	    removed=false
	    
	    # Remove from whichever mode contains it
	    if [ "${HAS_LOCAL_MODE}" = "true" ]; then
	        if read_manifest_entries "$LOCAL_MANIFEST_FILE" | grep -q "^$rule_path$"; then
	            remove_manifest_entry_from_file "$LOCAL_MANIFEST_FILE" "$rule_path"
	            removed=true
	        fi
	    fi
	    
	    if [ "${HAS_COMMIT_MODE}" = "true" ]; then
	        if read_manifest_entries "$COMMIT_MANIFEST_FILE" | grep -q "^$rule_path$"; then
	            remove_manifest_entry_from_file "$COMMIT_MANIFEST_FILE" "$rule_path"
	            removed=true
	        fi
	    fi
	    
	    if [ "$removed" = "true" ]; then
	        echo "Removed rule: $rule_path"
	    else
	        warn "Rule not found in any mode: $rule_path"
	    fi
	done
	
	# Sync to ensure proper cleanup
	sync_all_modes
	
	return 0
}

# Remove ruleset(s) from the repository (mode-aware)
#
# Removes entire rulesets from whichever mode contains them. Auto-detects
# which mode has each ruleset and removes from the appropriate manifest.
# Triggers sync to clean up target directories after removal.
#
# Globals:
#   HAS_COMMIT_MODE - Commit mode state
#   HAS_LOCAL_MODE - Local mode state
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#
# Arguments:
#   <ruleset>...         - Ruleset names (directory names under rulesets/)
#
# Outputs:
#   Stdout: Success messages for each removed ruleset
#   Stderr: Warning messages for rulesets not found
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
cmd_remove_ruleset() {
	# Check if any mode is initialized
	if [ "${HAS_COMMIT_MODE}" = "false" ] && [ "${HAS_LOCAL_MODE}" = "false" ]; then
	    error "No ai-rizz configuration found. Run 'ai-rizz init' first."
	fi
	
	# Validate manifest integrity (hard error for mismatched source repos)
	validate_manifest_integrity
	
	# Process each ruleset
	for ruleset in "$@"; do
	    ruleset_path="rulesets/$ruleset"
	    removed=false
	    
	    # Remove from whichever mode contains it
	    if [ "${HAS_LOCAL_MODE}" = "true" ]; then
	        if read_manifest_entries "$LOCAL_MANIFEST_FILE" | grep -q "^$ruleset_path$"; then
	            remove_manifest_entry_from_file "$LOCAL_MANIFEST_FILE" "$ruleset_path"
	            removed=true
	        fi
	    fi
	    
	    if [ "${HAS_COMMIT_MODE}" = "true" ]; then
	        if read_manifest_entries "$COMMIT_MANIFEST_FILE" | grep -q "^$ruleset_path$"; then
	            remove_manifest_entry_from_file "$COMMIT_MANIFEST_FILE" "$ruleset_path"
	            removed=true
	        fi
	    fi
	    
	    if [ "$removed" = "true" ]; then
	        echo "Removed ruleset: $ruleset_path"
	    else
	        warn "Ruleset not found in any mode: $ruleset_path"
	    fi
	done
	
	# Sync to ensure proper cleanup
	sync_all_modes
	
	return 0
}

# Sync all available manifests to their target directories
#
# Orchestrates complete sync process: resolves conflicts using "commit wins"
# policy, syncs both modes if initialized, and handles cleanup on failures.
# Core sync function called by cmd_sync and after rule/ruleset modifications.
#
# Globals:
#   HAS_COMMIT_MODE - Commit mode state
#   HAS_LOCAL_MODE - Local mode state
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#   LOCAL_MANIFEST_FILE - Local manifest filename
#   COMMIT_TARGET_DIR - Commit target directory
#   LOCAL_TARGET_DIR - Local target directory
#   SHARED_DIR - Shared directory name
#   LOCAL_DIR - Local directory name
#
# Arguments:
#   None
#
# Outputs:
#   None (delegates to sync_manifest_to_directory)
#
# Returns:
#   0 always (handles failures internally)
#
sync_all_modes() {
	sync_success=true
	
	# Resolve conflicts first (commit mode wins)
	resolve_conflicts
	
	# Sync commit mode if initialized
	if [ "${HAS_COMMIT_MODE}" = "true" ]; then
	    sync_manifest_to_directory "$COMMIT_MANIFEST_FILE" "$COMMIT_TARGET_DIR/$SHARED_DIR" || sync_success=false
	fi
	
	# Sync local mode if initialized  
	if [ "${HAS_LOCAL_MODE}" = "true" ]; then
	    sync_manifest_to_directory "$LOCAL_MANIFEST_FILE" "$LOCAL_TARGET_DIR/$LOCAL_DIR" || sync_success=false
	fi
	
	# Handle any cleanup needed
	if [ "$sync_success" = "false" ]; then
	    handle_sync_cleanup
	fi
}

# Sync a single manifest to its target directory
#
# Clears target directory of .mdc files and repopulates from manifest entries.
# Uses safety checks to only operate in managed directories. Handles external
# manifest corruption gracefully.
#
# Globals:
#   LOCAL_DIR - Local directory name (for safety check)
#   SHARED_DIR - Shared directory name (for safety check)
#
# Arguments:
#   $1 - Manifest file path
#   $2 - Target directory path
#
# Outputs:
#   Stderr: Warning messages for failures
#
# Returns:
#   0 on success
#   1 on failure (unrecognized directory, read errors)
#
sync_manifest_to_directory() {
	smtd_manifest_file="${1}"
	smtd_target_directory="${2}"
	
	if [ ! -f "${smtd_manifest_file}" ]; then
	    return 0  # No manifest to sync
	fi
	
	# Create target directory if needed
	mkdir -p "${smtd_target_directory}"
	
	# Safety check: Only operate in our managed directories (local or shared)
	case "${smtd_target_directory}" in
	    */"${LOCAL_DIR}"|*/"${SHARED_DIR}")
	        # Clear existing .mdc files to ensure removed rules are deleted
	        # Only delete regular .mdc files, never directories or other files
	        find "${smtd_target_directory}" -maxdepth 1 -name "*.mdc" -type f -delete 2>/dev/null || true
	        ;;
	    *)
	        warn "Refusing to clear unrecognized target directory: ${smtd_target_directory}"
	        return 1
	        ;;
	esac
	
	# Get entries from manifest (handle external modifications gracefully)
	if ! smtd_entries=$(read_manifest_entries "${smtd_manifest_file}"); then
		warn "Failed to read entries from ${smtd_manifest_file} (possibly corrupted by external changes)"
		return 1
	fi
	
	# Copy each entry (avoid subshell to ensure error propagation)
	if [ -n "${smtd_entries}" ]; then
	    # Use a temporary file to avoid subshell issues with pipes
	    smtd_temp_file=$(mktemp)
	    echo "${smtd_entries}" > "${smtd_temp_file}"
	    
	    while IFS= read -r smtd_entry; do
	        if [ -n "${smtd_entry}" ]; then
	            # Continue with other entries even if one fails (resilient to external modifications)
	            copy_entry_to_target "${smtd_entry}" "${smtd_target_directory}" || true
	        fi
	    done < "${smtd_temp_file}"
	    
	    rm -f "${smtd_temp_file}"
	fi
}

# Check if a filename would be deployed by commit mode
#
# Used by conflict resolution to implement "commit wins" policy. Checks if
# commit mode would deploy a file with the given name, considering both
# individual rules and files within rulesets.
#
# Globals:
#   HAS_COMMIT_MODE - Commit mode state
#   COMMIT_MANIFEST_FILE - Commit manifest filename
#
# Arguments:
#   $1 - Filename to check (just basename, not full path)
#
# Outputs:
#   None
#
# Returns:
#   0 if file would be deployed by commit mode
#   1 otherwise
#
file_exists_in_commit_mode() {
	fecm_filename="${1}"
	
	if [ "${HAS_COMMIT_MODE}" = "false" ] || [ ! -f "${COMMIT_MANIFEST_FILE}" ]; then
	    return 1  # No commit mode, so no conflict
	fi
	
	# Check if commit mode would deploy this filename
	fecm_commit_files=$(get_files_from_manifest "${COMMIT_MANIFEST_FILE}" 2>/dev/null || true)
	if [ -n "${fecm_commit_files}" ]; then
	    echo "${fecm_commit_files}" | grep -q "^${fecm_filename}$"
	    return $?
	fi
	
	return 1  # Not found in commit mode
}

# Copy a single entry (rule or ruleset) to target directory
#
# Handles both individual rules (single file copy) and rulesets (copy all
# .mdc files from directory). Implements conflict resolution by skipping
# files that would conflict with commit mode when syncing to local directory.
# Follows symlinks to copy actual content, not the links themselves.
#
# Globals:
#   REPO_DIR - Repository directory
#   LOCAL_DIR - Local directory name (for conflict detection)
#
# Arguments:
#   $1 - Entry path (relative to repository root)
#   $2 - Target directory path
#
# Outputs:
#   Stderr: Warning messages for missing entries
#
# Returns:
#   0 on success
#   1 if entry not found in repository
#
copy_entry_to_target() {
	cett_entry="${1}"
	cett_target_directory="${2}"
	
	cett_source_path="${REPO_DIR}/${cett_entry}"
	
	# Check if we're syncing to local directory and need to avoid commit conflicts
	cett_is_local_sync=false
	case "${cett_target_directory}" in
	    */"${LOCAL_DIR}")
	        cett_is_local_sync=true
	        ;;
	esac
	
	if [ -f "${cett_source_path}" ]; then
	    # Single file (rule)
	    cett_filename=$(basename "${cett_source_path}")
	    
	    # Skip if file would conflict with commit mode (commit wins)
	    if [ "${cett_is_local_sync}" = "true" ] && file_exists_in_commit_mode "${cett_filename}"; then
	        return 0  # Skip this file
	    fi
	    
	    cp "${cett_source_path}" "${cett_target_directory}/"
	elif [ -d "${cett_source_path}" ]; then
	    # Directory (ruleset) - copy individual .mdc files from ruleset to target directory
	    # Handle symlinks correctly by following them and copying actual content
	    find "${cett_source_path}" -name "*.mdc" -type f -o -name "*.mdc" -type l | \
	            while IFS= read -r cett_rule_file; do
	        if [ -f "${cett_rule_file}" ] || [ -L "${cett_rule_file}" ]; then
	            cett_filename=$(basename "${cett_rule_file}")
	            
	            # Skip if file would conflict with commit mode (commit wins)
	            if [ "${cett_is_local_sync}" = "true" ] && file_exists_in_commit_mode "${cett_filename}"; then
	                continue  # Skip this file
	            fi
	            
	            # Copy the file (following symlinks to get actual content)
	            cp -L "${cett_rule_file}" "${cett_target_directory}/"
	        fi
	    done
	else
	    warn "Entry not found in repository: ${cett_entry}"
	    return 1
	fi
}

# Handle cleanup after sync issues
#
# Performs recovery actions when sync operations fail. Re-caches manifest
# metadata to ensure consistency and validates git exclude state to detect
# manual modifications that might cause issues.
#
# Globals:
#   None (delegates to other functions)
#
# Arguments:
#   None
#
# Outputs:
#   Stderr: Warning messages from validation functions
#
# Returns:
#   0 always
#
handle_sync_cleanup() {
	# Re-cache manifest metadata to ensure consistency
	cache_manifest_metadata
	
	# Validate git exclude state
	hsc_target_dir=$(get_target_directory)
	validate_git_exclude_state "${hsc_target_dir}"
}

# Sync the repository (multi-mode aware)
#
# Updates source repository cache and syncs all manifests to target directories.
# Resolves conflicts using "commit wins" policy, handles network failures
# gracefully, and ensures target directories match manifest contents.
#
# Globals:
#   HAS_COMMIT_MODE - Commit mode state
#   HAS_LOCAL_MODE - Local mode state
#   COMMIT_SOURCE_REPO - Commit mode source repository
#   LOCAL_SOURCE_REPO - Local mode source repository
#
# Arguments:
#   None
#
# Outputs:
#   Stdout: Success message
#   Stderr: Warning messages for network failures
#
# Returns:
#   0 on success
#   1 on error (via error() function)
#
cmd_sync() {
	# Check if any mode is initialized
	if [ "${HAS_COMMIT_MODE}" = "false" ] && [ "${HAS_LOCAL_MODE}" = "false" ]; then
	    error "No ai-rizz configuration found. Run 'ai-rizz init' first."
	fi
	
	# Validate manifest integrity (hard error for mismatched source repos)
	validate_manifest_integrity
	
	# Get source repo from any available manifest
	cs_source_repo=""
	if [ -n "${COMMIT_SOURCE_REPO}" ]; then
	    cs_source_repo="${COMMIT_SOURCE_REPO}"
	elif [ -n "${LOCAL_SOURCE_REPO}" ]; then
	    cs_source_repo="${LOCAL_SOURCE_REPO}"
	fi
	
	# Sync repository first
	if [ -n "${cs_source_repo}" ]; then
	    if ! git_sync "${cs_source_repo}"; then
	        # git_sync already issued a warning, fail the sync operation
	        return 1
	    fi
	fi
	
	# Sync all initialized modes
	sync_all_modes
	
	echo "Sync complete"
	return 0
}



# Display help information
#
# Shows usage information for all commands and their options.
#
# Globals:
#   None
#
# Arguments:
#   None
#
# Outputs:
#   Stdout: Help text with command usage and options
#
# Returns:
#   0 always
#
cmd_help() {
  cat <<EOF
Usage: ai-rizz <command> [command-specific options]

Available commands:
  init [<source_repo>]     Initialize the repository
  deinit                   Deinitialize the repository
  list                     List available rules and rulesets
  add rule <rule>...       Add rule(s) to the repository (.mdc extension optional)
  add ruleset <ruleset>... Add ruleset(s) to the repository
  remove rule <rule>...    Remove rule(s) from the repository (.mdc extension optional)
  remove ruleset <ruleset>... Remove ruleset(s) from the repository
  sync                     Sync the repository
  help                     Show this help

Command-specific options:
  init options:
	-d <target_dir>        Target directory (default: .cursor/rules)
	--local, -l            Use local mode (ignore files)
	--commit, -c           Use commit mode (commit files)

  deinit options:
	-y                     Skip confirmation prompts
EOF
  return 0
}

# Initialization
# ==============

# Initialize ai-rizz state at startup (two-phase to avoid circular dependencies)
#
# Bootstraps ai-rizz state in careful order to avoid circular dependencies.
# Phase 1 does minimal file detection and legacy migration. Phase 2 performs
# full mode detection with directory validation. Phase 3 sets up repository
# directory for the current project. Called once at script startup.
#
# Globals:
#   HAS_COMMIT_MODE - Set during initialization
#   HAS_LOCAL_MODE - Set during initialization
#   COMMIT_SOURCE_REPO - Set during initialization
#   LOCAL_SOURCE_REPO - Set during initialization
#   COMMIT_TARGET_DIR - Set during initialization
#   LOCAL_TARGET_DIR - Set during initialization
#   REPO_DIR - Set during initialization
#
# Arguments:
#   None
#
# Outputs:
#   None (delegates to detection functions)
#
# Returns:
#   0 always
#
initialize_ai_rizz() {
	# Phase 1: Minimal detection and migration (file-based only)
	detect_manifest_files_only
	migrate_legacy_repository_if_needed
	
	# Phase 2: Full initialization with directory checking  
	detect_initialized_modes
	cache_manifest_metadata
	
	# Phase 3: Set repository directory for current project
	REPO_DIR=$(get_repo_dir)
}

# Main
# ====

# Only run main code if script is executed, not sourced
if [ "${0##*/}" = "ai-rizz" ]; then
	# Check if no arguments provided
	if [ $# -eq 0 ]; then
	    cmd_help
	    exit 0
	fi
	
	# Initialize ai-rizz state for production use
	initialize_ai_rizz
	
	# Parse command
	main_command=$1
	shift

	case "${main_command}" in
	init)
	  cmd_init "$@"
	  ;;
	deinit)
	  cmd_deinit "$@"
	  ;;
	list)
	  cmd_list "$@"
	  ;;
	add)
	  if [ $# -eq 0 ]; then
	    error "Missing type: 'rule' or 'ruleset'"
	  fi
	  
	  main_type=$1
	  shift
	  
	  case "${main_type}" in
	    rule)
	      if [ $# -eq 0 ]; then
	        error "Missing rule name"
	      fi
	      cmd_add_rule "$@"
	      ;;
	    ruleset)
	      if [ $# -eq 0 ]; then
	        error "Missing ruleset name"
	      fi
	      cmd_add_ruleset "$@"
	      ;;
	    *)
	      error "Invalid type: ${main_type}. Must be 'rule' or 'ruleset'"
	      ;;
	  esac
	  ;;
	remove)
	  if [ $# -eq 0 ]; then
	    error "Missing type: 'rule' or 'ruleset'"
	  fi
	  
	  main_type=$1
	  shift
	  
	  case "${main_type}" in
	    rule)
	      if [ $# -eq 0 ]; then
	        error "Missing rule name"
	      fi
	      cmd_remove_rule "$@"
	      ;;
	    ruleset)
	      if [ $# -eq 0 ]; then
	        error "Missing ruleset name"
	      fi
	      cmd_remove_ruleset "$@"
	      ;;
	    *)
	      error "Invalid type: ${main_type}. Must be 'rule' or 'ruleset'"
	      ;;
	  esac
	  ;;
	sync)
	  cmd_sync "$@"
	  ;;
	help)
	  cmd_help "$@"
	  ;;
	*)
	  error "Unknown command: ${main_command}. Run 'ai-rizz help' for usage"
	  ;;
  esac
fi

