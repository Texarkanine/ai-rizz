#!/bin/sh
# ai-rizz - A CLI tool to manage rules and rulesets  
# POSIX compliant shell script

set -e  # Exit on error

# Configuration constants
COMMIT_MANIFEST_FILE="ai-rizz.inf"
LOCAL_MANIFEST_FILE="ai-rizz.local.inf"
SHARED_DIR="shared"
LOCAL_DIR="local" 
CONFIG_DIR="$HOME/.config/ai-rizz"
DEFAULT_TARGET_DIR=".cursor/rules"

# Repository Directory Functions
# ==============================

# Get repository directory for the current project
get_repo_dir() {
    # Use git root directory name as project name, fallback to current directory
    if git_root=$(git rev-parse --show-toplevel 2>/dev/null); then
        project_name=$(basename "${git_root}")
    else
        project_name=$(basename "$(pwd)")
    fi
    echo "${CONFIG_DIR}/repos/${project_name}/repo"
}

# Helper function to get repo dir from manifest file (now just calls get_repo_dir)
get_repo_dir_for_manifest() {
    manifest_file="${1}"
    if [ "${manifest_file}" = "${COMMIT_MANIFEST_FILE}" ] || [ "${manifest_file}" = "${LOCAL_MANIFEST_FILE}" ]; then
        get_repo_dir
    else
        error "Unknown manifest file: ${manifest_file}"
    fi
}

# Mode state (set once during initialization, read-only afterward)
HAS_COMMIT_MODE=false
HAS_LOCAL_MODE=false

# Cached manifest metadata (set during initialization for efficiency)
COMMIT_SOURCE_REPO=""
LOCAL_SOURCE_REPO=""
COMMIT_TARGET_DIR=""
LOCAL_TARGET_DIR=""

# Repository directory (set during initialization)
REPO_DIR=""

# Display formatting variables  
COMMITTED_GLYPH="●"
UNINSTALLED_GLYPH="○"
LOCAL_GLYPH="◐"       # For Phase 3 (list command)

# Utilities
# =========

# Print error to stderr and exit
error() {
  echo "Error: $1" >&2
  exit "${2:-1}"
}

# Print warning to stderr
warn() {
  echo "Warning: $1" >&2
}

# Read and validate manifest file
# Sets: SOURCE_REPO, TARGET_DIR, MANIFEST_ENTRIES
read_manifest() {
  if [ ! -f "$MANIFEST_FILE" ]; then
    error "Manifest file '$MANIFEST_FILE' not found"
  fi
  
  # Read first line to get source repo and target dir
  read -r first_line < "$MANIFEST_FILE"
  
  # Check if it has the correct format (tab-separated)
  if ! echo "$first_line" | grep -q "	"; then
    error "Invalid manifest format: First line must be 'source_repo<tab>target_dir'"
  fi
  
  # Extract the source repo and target dir
  SOURCE_REPO=$(echo "$first_line" | cut -f1)
  TARGET_DIR=$(echo "$first_line" | cut -f2)
  
  # Read the rest of the manifest file
  MANIFEST_ENTRIES=""
  while IFS= read -r line; do
    if [ -n "$line" ] && [ "$line" != "$first_line" ]; then
      MANIFEST_ENTRIES="$MANIFEST_ENTRIES
$line"
    fi
  done < "$MANIFEST_FILE"
  
  # Trim leading newline
  MANIFEST_ENTRIES=$(echo "$MANIFEST_ENTRIES" | sed '/./,$!d')
  
  return 0
}

# Write manifest file
write_manifest() {
  if [ -z "$SOURCE_REPO" ] || [ -z "$TARGET_DIR" ]; then
    error "SOURCE_REPO and TARGET_DIR must be set before writing manifest"
  fi
  
  # Write the first line
  echo "$SOURCE_REPO	$TARGET_DIR" > "$MANIFEST_FILE"
  
  # Write the rest of the entries
  if [ -n "$MANIFEST_ENTRIES" ]; then
    echo "$MANIFEST_ENTRIES" >> "$MANIFEST_FILE"
  fi
  
  return 0
}

# Add entry to manifest
add_manifest_entry() {
  entry="$1"
  
  # Check if entry already exists
  if echo "$MANIFEST_ENTRIES" | grep -q "^$entry$"; then
    return 0  # Already exists, nothing to do
  fi
  
  # Add the entry
  if [ -z "$MANIFEST_ENTRIES" ]; then
    MANIFEST_ENTRIES="$entry"
  else
    MANIFEST_ENTRIES="$MANIFEST_ENTRIES
$entry"
  fi
  
  return 0
}

# Remove entry from manifest
remove_manifest_entry() {
  entry="$1"
  
  # Remove the entry
  MANIFEST_ENTRIES=$(echo "$MANIFEST_ENTRIES" | grep -v "^$entry$" || true)
  
  return 0
}

# Progressive Manifest Utilities  
# ==============================

# Read manifest metadata line (returns "source_repo\ttarget_dir" via stdout)
read_manifest_metadata() {
    manifest_file="$1"
    
    if [ ! -f "$manifest_file" ]; then
        return 1
    fi
    
    # Read first line
    read -r first_line < "$manifest_file"
    
    # Validate format
    if ! echo "$first_line" | grep -q "	"; then
        error "Invalid manifest format in $manifest_file: First line must be 'source_repo<tab>target_dir'"
    fi
    
    echo "$first_line"
}

# Read manifest entries (returns entries via stdout, one per line)
read_manifest_entries() {
    manifest_file="$1"
    
    if [ ! -f "$manifest_file" ]; then
        return 1
    fi
    
    # Skip first line (metadata), return rest (handle empty manifests gracefully)
    tail -n +2 "$manifest_file" | grep -v '^$' || true
}

# Write manifest with metadata and entries from stdin
write_manifest_with_entries() {
    manifest_file="$1"
    source_repo="$2"
    target_dir="$3"
    
    # Write header
    echo "$source_repo	$target_dir" > "$manifest_file"
    
    # Read from stdin and append if there's content
    while IFS= read -r line; do
        if [ -n "$line" ]; then
            echo "$line" >> "$manifest_file"
        fi
    done
}

# Add entry to manifest file
add_manifest_entry_to_file() {
    target_manifest_file="$1"
    entry="$2"
    
    # Check if entry already exists
    if [ -f "$target_manifest_file" ]; then
        if read_manifest_entries "$target_manifest_file" | grep -q "^$entry$"; then
            return 0  # Already exists
        fi
    fi
    
    # Add the entry
    echo "$entry" >> "$target_manifest_file"
}

# Remove entry from manifest file
remove_manifest_entry_from_file() {
    local_manifest_file="$1"
    entry="$2"
    
    if [ ! -f "$local_manifest_file" ]; then
        return 0  # Nothing to remove
    fi
    
    # Get metadata
    metadata=$(read_manifest_metadata "$local_manifest_file") || {
        error "Failed to read manifest metadata from $local_manifest_file"
    }
    
    # Get entries excluding the one to remove
    entries=$(read_manifest_entries "$local_manifest_file" | grep -v "^$entry$" || true)
    
    # Rewrite manifest
    source_repo=$(echo "$metadata" | cut -f1)
    target_dir=$(echo "$metadata" | cut -f2)
    
    # Write header first
    echo "$source_repo	$target_dir" > "$local_manifest_file"
    
    # Append entries if any exist (avoid hanging cat with empty input)
    if [ -n "$entries" ]; then
        echo "$entries" >> "$local_manifest_file"
    fi
}

# Get any available manifest metadata (for lazy initialization)
get_any_manifest_metadata() {
    # Try commit manifest first
    if [ -f "$COMMIT_MANIFEST_FILE" ]; then
        read_manifest_metadata "$COMMIT_MANIFEST_FILE"
        return $?
    fi
    
    # Try local manifest
    if [ -f "$LOCAL_MANIFEST_FILE" ]; then
        read_manifest_metadata "$LOCAL_MANIFEST_FILE"
        return $?
    fi
    
    # No manifests available
    return 1
}

# Clone or update a git repository
git_sync() {
  repo_url="${1}"
  
  repo_dir=$(get_repo_dir)
  
  # Ensure config directory exists
  mkdir -p "$(dirname "${repo_dir}")"
  
  # Clone/update project repository
  if [ ! -d "${repo_dir}" ]; then
    git clone "${repo_url}" "${repo_dir}" || error "Failed to clone repository: ${repo_url}"
  else
    (cd "${repo_dir}" && git pull) || error "Failed to update repository: ${repo_url}"
  fi
  
  return 0
}

# Detect if we're in local mode
is_local_mode() {
  # Check if .git directory exists
  if [ ! -d ".git" ]; then
    error "Not in a git repository"
  fi
  
  # Check if target directory is in .git/info/exclude
  if [ -f ".git/info/exclude" ] && grep -q "$TARGET_DIR" ".git/info/exclude"; then
    return 0  # true, local mode
  fi
  
  return 1  # false, commit mode
}

# Git Exclude Management  
# ======================

# Update .git/info/exclude for specific paths
update_git_exclude() {
    path="$1"
    action="$2"  # "add" or "remove"
    
    # Create .git/info directory if it doesn't exist
    mkdir -p ".git/info"
    
    # Create exclude file if it doesn't exist  
    touch ".git/info/exclude"
    
    case "$action" in
        add)
            if ! grep -q "^$path$" ".git/info/exclude"; then
                echo "$path" >> ".git/info/exclude"
            fi
            ;;
        remove)
            # Create a temporary file
            tmp_file=$(mktemp)
            # Filter out the path
            grep -v "^$path$" ".git/info/exclude" > "$tmp_file" || true
            # Replace the original file
            cat "$tmp_file" > ".git/info/exclude"
            # Remove the temporary file
            rm -f "$tmp_file"
            ;;
        *)
            error "Invalid action: $action. Must be 'add' or 'remove'"
            ;;
    esac
}

# Setup git excludes for local mode
setup_local_mode_excludes() {
    target_dir="$1"
    
    update_git_exclude "$LOCAL_MANIFEST_FILE" "add"
    update_git_exclude "$target_dir/$LOCAL_DIR" "add"
}

# Remove all local mode excludes
remove_local_mode_excludes() {
    target_dir="$1"
    
    update_git_exclude "$LOCAL_MANIFEST_FILE" "remove"
    update_git_exclude "$target_dir/$LOCAL_DIR" "remove"
}

# Validate git exclude state matches mode configuration
validate_git_exclude_state() {
    target_dir="$1"
    
    if [ "$HAS_LOCAL_MODE" = "true" ]; then
        # Local mode should be excluded
        if [ ! -f ".git/info/exclude" ] || ! grep -q "^$LOCAL_MANIFEST_FILE$" ".git/info/exclude"; then
            warn "Local manifest file not in git exclude (should be git-ignored)"
        fi
        if [ ! -f ".git/info/exclude" ] || ! grep -q "^$target_dir/$LOCAL_DIR$" ".git/info/exclude"; then
            warn "Local directory not in git exclude (should be git-ignored)"
        fi
    fi
    
    if [ "$HAS_COMMIT_MODE" = "true" ]; then
        # Commit mode should NOT be excluded
        if [ -f ".git/info/exclude" ] && grep -q "^$COMMIT_MANIFEST_FILE$" ".git/info/exclude"; then
            warn "Commit manifest file in git exclude (should be git-tracked)"
        fi
        if [ -f ".git/info/exclude" ] && grep -q "^$target_dir/$SHARED_DIR$" ".git/info/exclude"; then
            warn "Shared directory in git exclude (should be git-tracked)"
        fi
    fi
}

# Mode Detection Utilities
# ========================

# Phase 1: Minimal manifest file detection (no directory dependency)
detect_manifest_files_only() {
    # Quick check - just look for files, don't validate directories yet
    if [ -f "$LOCAL_MANIFEST_FILE" ]; then
        HAS_LOCAL_MODE=true
    else
        HAS_LOCAL_MODE=false
    fi
    
    if [ -f "$COMMIT_MANIFEST_FILE" ]; then
        HAS_COMMIT_MODE=true
    else
        HAS_COMMIT_MODE=false
    fi
}

# Phase 2: Full mode detection including directory validation
detect_initialized_modes() {
    HAS_LOCAL_MODE=false
    HAS_COMMIT_MODE=false
    
    # Get target directory or error if none available
    target_base=$(get_target_directory)
    
    # Check for local mode (manifest + directory)
    if [ -f "$LOCAL_MANIFEST_FILE" ] && [ -d "$target_base/$LOCAL_DIR" ]; then
        HAS_LOCAL_MODE=true
    fi
    
    # Check for commit mode (manifest + directory)  
    if [ -f "$COMMIT_MANIFEST_FILE" ] && [ -d "$target_base/$SHARED_DIR" ]; then
        HAS_COMMIT_MODE=true
    fi
}

# Get target directory from available manifests (returns via stdout)
get_target_directory() {
    # Try commit manifest first
    if [ -f "$COMMIT_MANIFEST_FILE" ]; then
        metadata=$(read_manifest_metadata "$COMMIT_MANIFEST_FILE") || {
            error "Failed to read commit manifest metadata"
        }
        echo "$metadata" | cut -f2
        return 0
    fi
    
    # Try local manifest
    if [ -f "$LOCAL_MANIFEST_FILE" ]; then
        metadata=$(read_manifest_metadata "$LOCAL_MANIFEST_FILE") || {
            error "Failed to read local manifest metadata"
        }
        echo "$metadata" | cut -f2
        return 0
    fi
    
    # No manifests available - use default only during initialization
    echo "$DEFAULT_TARGET_DIR"
}

# Cache manifest metadata in globals for efficiency
cache_manifest_metadata() {
    # Cache commit manifest metadata
    if [ -f "$COMMIT_MANIFEST_FILE" ]; then
        metadata=$(read_manifest_metadata "$COMMIT_MANIFEST_FILE") || {
            error "Failed to read commit manifest metadata"
        }
        COMMIT_SOURCE_REPO=$(echo "$metadata" | cut -f1)
        COMMIT_TARGET_DIR=$(echo "$metadata" | cut -f2)
    fi
    
    # Cache local manifest metadata
    if [ -f "$LOCAL_MANIFEST_FILE" ]; then
        metadata=$(read_manifest_metadata "$LOCAL_MANIFEST_FILE") || {
            error "Failed to read local manifest metadata"
        }
        LOCAL_SOURCE_REPO=$(echo "$metadata" | cut -f1)
        LOCAL_TARGET_DIR=$(echo "$metadata" | cut -f2)
    fi
}

# Test helper functions (for backward compatibility with test suite)
has_local_mode() {
    [ "$HAS_LOCAL_MODE" = "true" ]
}

has_commit_mode() {
    [ "$HAS_COMMIT_MODE" = "true" ]
}

# Legacy Migration Utilities
# ==========================

# Detect if repository needs migration from single-mode to progressive format
needs_migration() {
    # Legacy local mode: ai-rizz.inf exists but is in .git/info/exclude
    if [ -f "$COMMIT_MANIFEST_FILE" ] && [ -f ".git/info/exclude" ]; then
        if grep -q "^$COMMIT_MANIFEST_FILE$" ".git/info/exclude"; then
            return 0  # true, needs migration from legacy local
        fi
    fi
    
    return 1  # false, no migration needed
}

# Migrate legacy repository to progressive format  
migrate_legacy_repository_if_needed() {
    if ! needs_migration; then
        return 0  # No migration needed
    fi
    
    # Get target directory from existing manifest
    if [ -f "$COMMIT_MANIFEST_FILE" ]; then
        metadata=$(read_manifest_metadata "$COMMIT_MANIFEST_FILE") || {
            error "Failed to read legacy manifest metadata"
        }
        legacy_target_dir=$(echo "$metadata" | cut -f2)
        
        # Migrate legacy local mode to new format
        migrate_legacy_local_mode "$legacy_target_dir"
    fi
}

# Migrate from legacy local mode (ai-rizz.inf in git exclude) to new format
migrate_legacy_local_mode() {
    legacy_target_dir="$1"
    
    # 1. Rename manifest file
    mv "$COMMIT_MANIFEST_FILE" "$LOCAL_MANIFEST_FILE"
    
    # 2. Create local directory and move rules from shared directory
    mkdir -p "$legacy_target_dir/$LOCAL_DIR"
    
    if [ -d "$legacy_target_dir/$SHARED_DIR" ]; then
        if [ "$(ls -A "$legacy_target_dir/$SHARED_DIR" 2>/dev/null)" ]; then
            mv "$legacy_target_dir/$SHARED_DIR"/* "$legacy_target_dir/$LOCAL_DIR/"
        fi
        rmdir "$legacy_target_dir/$SHARED_DIR"
    fi
    
    # 3. Update .git/info/exclude entries
    update_git_exclude "$COMMIT_MANIFEST_FILE" "remove"
    update_git_exclude "$legacy_target_dir/$SHARED_DIR" "remove"  
    update_git_exclude "$LOCAL_MANIFEST_FILE" "add"
    update_git_exclude "$legacy_target_dir/$LOCAL_DIR" "add"
}

# Lazy Initialization Utilities
# =============================

# Initialize a mode that doesn't exist yet, copying metadata from existing mode
lazy_init_mode() {
    target_mode="$1"  # "local" or "commit"
    
    # Get metadata from any existing manifest
    metadata=$(get_any_manifest_metadata) || {
        error "No manifest available to copy metadata from for lazy initialization"
    }
    
    source_repo=$(echo "$metadata" | cut -f1)
    target_dir=$(echo "$metadata" | cut -f2)
    
    case "$target_mode" in
        local)
            # Create local mode structure
            mkdir -p "$target_dir/$LOCAL_DIR"
            
            # Write empty manifest with metadata
            echo "" | write_manifest_with_entries "$LOCAL_MANIFEST_FILE" "$source_repo" "$target_dir"
            
            # Update git excludes
            setup_local_mode_excludes "$target_dir"
            
            # Update mode state and cache
            HAS_LOCAL_MODE=true
            LOCAL_SOURCE_REPO="$source_repo"
            LOCAL_TARGET_DIR="$target_dir"
            ;;
            
        commit)
            # Create commit mode structure  
            mkdir -p "$target_dir/$SHARED_DIR"
            
            # Write empty manifest with metadata
            echo "" | write_manifest_with_entries "$COMMIT_MANIFEST_FILE" "$source_repo" "$target_dir"
            
            # Update mode state and cache
            HAS_COMMIT_MODE=true
            COMMIT_SOURCE_REPO="$source_repo"
            COMMIT_TARGET_DIR="$target_dir"
            ;;
            
        *)
            error "Invalid target mode: $target_mode. Must be 'local' or 'commit'"
            ;;
    esac
}

# Check if lazy initialization is needed for a mode (returns 0 if needed)
needs_lazy_init() {
    target_mode="$1"
    
    case "$target_mode" in
        local)
            [ "$HAS_LOCAL_MODE" = "false" ] && [ "$HAS_COMMIT_MODE" = "true" ]
            ;;
        commit)
            [ "$HAS_COMMIT_MODE" = "false" ] && [ "$HAS_LOCAL_MODE" = "true" ]
            ;;
        *)
            return 1
            ;;
    esac
}

# Conflict Resolution Utilities
# =============================

# Get all .mdc files that would be deployed by a manifest
# Returns one filename per line (just the filename, not the full path)
get_files_from_manifest() {
    manifest_file="${1}"
    
    if [ ! -f "${manifest_file}" ]; then
        return 1
    fi
    
    # Get the source repo from manifest metadata
    source_repo=$(read_manifest_metadata "${manifest_file}" | cut -f1)
    
    # Get the appropriate repository directory for this manifest
    repo_dir=$(get_repo_dir_for_manifest "${manifest_file}")
    
    # Get all entries from the manifest
    entries=$(read_manifest_entries "${manifest_file}" 2>/dev/null || true)
    
    if [ -n "${entries}" ]; then
        echo "${entries}" | while IFS= read -r entry; do
            if [ -n "${entry}" ]; then
                # Get the source path for this entry
                source_path="${repo_dir}/${entry}"
                
                if [ -f "${source_path}" ]; then
                    # Single file - extract just the filename
                    basename "${source_path}"
                elif [ -d "${source_path}" ]; then
                    # Directory (ruleset) - list all .mdc files in it
                    find "${source_path}" -name "*.mdc" -type f -o -name "*.mdc" -type l | while IFS= read -r rule_file; do
                        basename "${rule_file}"
                    done
                fi
            fi
        done
    fi
}

# Remove any local manifest entries that would deploy the given filename
# For rulesets, this will remove the entire ruleset and add back individual rules for non-conflicting files
remove_local_entries_deploying_file() {
    filename="${1}"
    
    # Get all local entries
    local_entries=$(read_manifest_entries "${LOCAL_MANIFEST_FILE}" 2>/dev/null || true)
    
    # Get the repository directory
    local_repo_dir=$(get_repo_dir)
    
    if [ -n "${local_entries}" ]; then
        # Use a temporary file to avoid subshell issues
        temp_entries=$(mktemp)
        echo "${local_entries}" > "${temp_entries}"
        
        while IFS= read -r entry; do
            if [ -n "${entry}" ]; then
                # Check if this entry would deploy the target filename
                source_path="${local_repo_dir}/${entry}"
                
                if [ -f "${source_path}" ]; then
                    # Single file - check if it matches
                    if [ "$(basename "${source_path}")" = "${filename}" ]; then
                        remove_manifest_entry_from_file "${LOCAL_MANIFEST_FILE}" "${entry}"
                    fi
                elif [ -d "${source_path}" ]; then
                    # Directory (ruleset) - check if it contains the file
                    if find "${source_path}" -name "${filename}" -type f -o -name "${filename}" -type l | grep -q .; then
                        # Remove the entire ruleset entry
                        remove_manifest_entry_from_file "${LOCAL_MANIFEST_FILE}" "${entry}"
                        
                        # Add back individual rules from this ruleset that don't conflict
                        restore_non_conflicting_rules_from_ruleset "${entry}"
                    fi
                fi
            fi
        done < "${temp_entries}"
        
        # Clean up temporary file
        rm -f "${temp_entries}"
    fi
}

# Restore individual rules from a ruleset that don't conflict with commit manifest
restore_non_conflicting_rules_from_ruleset() {
    ruleset_entry="${1}"
    
    # Get all files that commit manifest would deploy
    commit_files=$(get_files_from_manifest "${COMMIT_MANIFEST_FILE}" 2>/dev/null || true)
    
    # Get the repository directory
    local_repo_dir=$(get_repo_dir)
    
    # Get all files in this ruleset
    ruleset_path="${local_repo_dir}/${ruleset_entry}"
    
    if [ -d "${ruleset_path}" ]; then
        # Use temporary file to avoid subshell issues
        temp_rules=$(mktemp)
        find "${ruleset_path}" -name "*.mdc" -type f -o -name "*.mdc" -type l > "${temp_rules}"
        
        while IFS= read -r rule_file; do
            if [ -n "${rule_file}" ]; then
                rule_filename=$(basename "${rule_file}")
                
                # Check if this rule conflicts with commit manifest
                rule_conflicts=false
                if [ -n "${commit_files}" ]; then
                    # Use grep to check for conflict
                    if echo "${commit_files}" | grep -q "^${rule_filename}$"; then
                        rule_conflicts=true
                    fi
                fi
                
                # If no conflict, add this rule individually to local manifest
                if [ "${rule_conflicts}" = "false" ]; then
                    # Convert absolute path back to relative path from repo root
                    relative_path=$(echo "${rule_file}" | sed "s|^${local_repo_dir}/||")
                    add_manifest_entry_to_file "${LOCAL_MANIFEST_FILE}" "${relative_path}"
                fi
            fi
        done < "${temp_rules}"
        
        # Clean up temporary file
        rm -f "${temp_rules}"
    fi
}

# Detect and resolve conflicts (Phase 4)
# Committed mode wins, local entries silently removed
#
# This function resolves conflicts between commit and local manifests by ensuring
# that any files present in commit mode are removed from local mode. The conflict
# resolution works at the individual file level, not just the manifest entry level.
#
# For example:
# - If local has "rules/rule1.mdc" and commit adds "rulesets/set1" containing rule1.mdc,
#   then "rules/rule1.mdc" should be removed from local manifest
# - If local has "rulesets/set1" and commit adds "rules/rule2.mdc" where rule2.mdc
#   is also in set1, then the entire "rulesets/set1" should be removed from local
#
# Algorithm:
# 1. Get all individual .mdc files that would be deployed by commit manifest
# 2. For each file, check if it would also be deployed by local manifest
# 3. If so, remove the local manifest entry that would deploy that file
# 4. Handle both individual rule entries and ruleset entries appropriately
resolve_conflicts() {
    if [ "${HAS_COMMIT_MODE}" = "false" ] || [ "${HAS_LOCAL_MODE}" = "false" ]; then
        return 0  # No conflicts possible with single mode
    fi
    
    if [ ! -f "${COMMIT_MANIFEST_FILE}" ] || [ ! -f "${LOCAL_MANIFEST_FILE}" ]; then
        return 0  # Can't have conflicts if manifests don't exist
    fi
    
    # Get all .mdc files that would be deployed by commit manifest
    commit_files=$(get_files_from_manifest "${COMMIT_MANIFEST_FILE}" 2>/dev/null || true)
    
    if [ -n "${commit_files}" ]; then
        # Use a temporary file to avoid subshell issues
        temp_file=$(mktemp)
        echo "${commit_files}" > "${temp_file}"
        
        # For each file that commit would deploy, remove any local entries that would deploy the same file
        while IFS= read -r filename; do
            if [ -n "${filename}" ]; then
                remove_local_entries_deploying_file "${filename}"
            fi
        done < "${temp_file}"
        
        # Clean up temporary file
        rm -f "${temp_file}"
    fi
}

# Validation Utilities
# ===================

# Validate manifest file format (minimal implementation)
validate_manifest_format() {
    manifest_file="$1"
    
    if [ ! -f "$manifest_file" ]; then
        return 1
    fi
    
    # Check if file is empty
    if [ ! -s "$manifest_file" ]; then
        warn "Manifest file $manifest_file is empty"
        return 1
    fi
    
    # Check first line format
    first_line=$(head -n1 "$manifest_file")
    if ! echo "$first_line" | grep -q "	"; then
        warn "Invalid manifest format in $manifest_file: First line must be 'source_repo<tab>target_dir'"
        return 1
    fi
    
    return 0
}

# Validate that both manifests use the same source repository (hard error)
validate_manifest_integrity() {
    if [ "${HAS_COMMIT_MODE}" = "true" ] && [ "${HAS_LOCAL_MODE}" = "true" ]; then
        if [ "${COMMIT_SOURCE_REPO}" != "${LOCAL_SOURCE_REPO}" ]; then
            error "Manifest integrity error: Local and commit modes use different source repositories (${LOCAL_SOURCE_REPO} vs ${COMMIT_SOURCE_REPO}). This is not supported. Use 'ai-rizz deinit' to reset."
        fi
    fi
}

# Commands
# ========

# Initialize the repository (progressive initialization)
cmd_init() {
    source_repo=""
    target_dir=""
    mode=""
    
    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            -d)
                target_dir="$2"
                shift 2
                ;;
            --local|-l)
                mode="local"
                shift
                ;;
            --commit|-c)
                mode="commit"
                shift
                ;;
            *)
                if [ -z "$source_repo" ]; then
                    source_repo="$1"
                    shift
                else
                    error "Unknown argument: $1"
                fi
                ;;
        esac
    done
    
    # Prompt for source repo if not provided
    if [ -z "$source_repo" ]; then
        printf "Source repository URL: "
        read -r source_repo
        if [ -z "$source_repo" ]; then
            error "Source repository URL is required"
        fi
    fi
    
    # Use default target directory if not provided
    if [ -z "$target_dir" ]; then
        target_dir="$DEFAULT_TARGET_DIR"
    fi
    
    # Prompt for mode if not provided
    if [ -z "$mode" ]; then
        printf "Mode [local/commit]: "
        read -r mode
        if [ -z "$mode" ]; then
            mode="local"
        fi
    fi
    
        # Validate mode
    case "$mode" in
        local|commit)
            ;;
        *)
            error "Invalid mode: $mode. Must be 'local' or 'commit'"
            ;;
    esac

    # If one mode already exists, use its source_repo (no override allowed)
    if [ "${HAS_COMMIT_MODE}" = "true" ] || [ "${HAS_LOCAL_MODE}" = "true" ]; then
        existing_source_repo=""
        if [ "${HAS_COMMIT_MODE}" = "true" ]; then
            existing_source_repo="${COMMIT_SOURCE_REPO}"
        else
            existing_source_repo="${LOCAL_SOURCE_REPO}"
        fi
        
        # Override user input silently
        source_repo="${existing_source_repo}"
    fi

    # Check if repository is already initialized in the requested mode
    case "$mode" in
        local)
            if [ "$HAS_LOCAL_MODE" = "true" ]; then
                # Check if parameters match existing configuration
                if [ "$LOCAL_SOURCE_REPO" = "$source_repo" ] && [ "$LOCAL_TARGET_DIR" = "$target_dir" ]; then
                    echo "Initialized ai-rizz with source: $source_repo, target: $target_dir, mode: $mode"
                    return 0  # Idempotent success
                else
                    error "Local mode already initialized with different parameters. Use 'ai-rizz deinit --local' first."
                fi
            fi
            ;;
        commit)
            if [ "$HAS_COMMIT_MODE" = "true" ]; then
                # Check if parameters match existing configuration
                if [ "$COMMIT_SOURCE_REPO" = "$source_repo" ] && [ "$COMMIT_TARGET_DIR" = "$target_dir" ]; then
                    echo "Initialized ai-rizz with source: $source_repo, target: $target_dir, mode: $mode"
                    return 0  # Idempotent success
                else
                    error "Commit mode already initialized with different parameters. Use 'ai-rizz deinit --commit' first."
                fi
            fi
            ;;
    esac
    
    # Ensure git repository context
    if [ ! -d ".git" ]; then
        error "Not in a git repository"
    fi
    
    # Clone/sync source repository first
    git_sync "$source_repo"
    
    # Initialize the requested mode
    case "$mode" in
        local)
            # Create local mode structure
            mkdir -p "$target_dir/$LOCAL_DIR"
            
            # Write empty manifest with metadata
            echo "" | write_manifest_with_entries "$LOCAL_MANIFEST_FILE" "$source_repo" "$target_dir"
            
            # Update git excludes
            setup_local_mode_excludes "$target_dir"
            
            # Update mode state and cache
            HAS_LOCAL_MODE=true
            LOCAL_SOURCE_REPO="$source_repo"
            LOCAL_TARGET_DIR="$target_dir"
            ;;
            
        commit)
            # Create commit mode structure  
            mkdir -p "$target_dir/$SHARED_DIR"
            
            # Write empty manifest with metadata
            echo "" | write_manifest_with_entries "$COMMIT_MANIFEST_FILE" "$source_repo" "$target_dir"
            
            # Update mode state and cache
            HAS_COMMIT_MODE=true
            COMMIT_SOURCE_REPO="$source_repo"
            COMMIT_TARGET_DIR="$target_dir"
            ;;
    esac
    
    echo "Initialized ai-rizz with source: $source_repo, target: $target_dir, mode: $mode"
    return 0
}

# Recursively remove empty parent directories
cleanup_empty_parents() {
  dir="$1"
  # Check if directory exists and is empty
  if [ -d "$dir" ] && [ -z "$(ls -A "$dir")" ]; then
    parent_dir=$(dirname "$dir")
    echo "Removing empty directory: $dir"
    rmdir "$dir"
    
    # Stop at filesystem root, home directory, or current directory
    if [ "$parent_dir" != "/" ] && [ "$parent_dir" != "$HOME" ] && [ "$parent_dir" != "." ]; then
      cleanup_empty_parents "$parent_dir"
    fi
  fi
}

# Deinitialize the repository (progressive mode-aware)
cmd_deinit() {
    force=false
    mode=""
    
    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            -y)
                force=true
                shift
                ;;
            --local|-l)
                mode="local"
                shift
                ;;
            --commit|-c)
                mode="commit"
                shift
                ;;
            --all|-a)
                mode="all"
                shift
                ;;
            *)
                error "Unknown argument: $1"
                ;;
        esac
    done
    
    # Check if any mode is initialized
    if [ "$HAS_COMMIT_MODE" = "false" ] && [ "$HAS_LOCAL_MODE" = "false" ]; then
        error "No ai-rizz configuration found."
    fi
    
    # Prompt for mode if not provided
    if [ -z "$mode" ]; then
        if [ "$HAS_LOCAL_MODE" = "true" ] && [ "$HAS_COMMIT_MODE" = "true" ]; then
            printf "Which mode to remove [local/commit/all]: "
            read -r mode
            if [ -z "$mode" ]; then
                mode="all"
            fi
        elif [ "$HAS_LOCAL_MODE" = "true" ]; then
            mode="local"
        elif [ "$HAS_COMMIT_MODE" = "true" ]; then
            mode="commit"
        fi
    fi
    
    # Validate mode
    case "$mode" in
        local|commit|all)
            ;;
        *)
            error "Invalid mode: $mode. Must be 'local', 'commit', or 'all'"
            ;;
    esac
    
    # Determine what to remove
    remove_local=false
    remove_commit=false
    
    case "$mode" in
        local)
            if [ "$HAS_LOCAL_MODE" = "false" ]; then
                error "Local mode not initialized"
            fi
            remove_local=true
            ;;
        commit)
            if [ "$HAS_COMMIT_MODE" = "false" ]; then
                error "Commit mode not initialized"
            fi
            remove_commit=true
            ;;
        all)
            remove_local=true
            remove_commit=true
            ;;
    esac
    
    # Build confirmation message
    items_to_remove=""
    if [ "$remove_local" = "true" ] && [ "$HAS_LOCAL_MODE" = "true" ]; then
        items_to_remove="$items_to_remove $LOCAL_MANIFEST_FILE $LOCAL_TARGET_DIR/$LOCAL_DIR"
    fi
    if [ "$remove_commit" = "true" ] && [ "$HAS_COMMIT_MODE" = "true" ]; then
        items_to_remove="$items_to_remove $COMMIT_MANIFEST_FILE $COMMIT_TARGET_DIR/$SHARED_DIR"
    fi
    
    # Confirm deletion
    if ! $force && [ -n "$items_to_remove" ]; then
        echo "This will delete:$items_to_remove"
        printf "Are you sure? [y/N] "
        read -r confirm
        if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
            echo "Canceled"
            return 0
        fi
    fi
    
    # Remove local mode
    if [ "$remove_local" = "true" ] && [ "$HAS_LOCAL_MODE" = "true" ]; then
        # Remove from git excludes
        remove_local_mode_excludes "$LOCAL_TARGET_DIR"
        
        # Remove files
        rm -rf "$LOCAL_TARGET_DIR/$LOCAL_DIR"
        rm -f "$LOCAL_MANIFEST_FILE"
        
        # Update mode state
        HAS_LOCAL_MODE=false
        LOCAL_SOURCE_REPO=""
        LOCAL_TARGET_DIR=""
        
        echo "Removed local mode configuration"
    fi
    
    # Remove commit mode
    if [ "$remove_commit" = "true" ] && [ "$HAS_COMMIT_MODE" = "true" ]; then
        # Remove files (no git exclude changes needed for commit mode)
        rm -rf "$COMMIT_TARGET_DIR/$SHARED_DIR"
        rm -f "$COMMIT_MANIFEST_FILE"
        
        # Update mode state
        HAS_COMMIT_MODE=false
        COMMIT_SOURCE_REPO=""
        COMMIT_TARGET_DIR=""
        
        echo "Removed commit mode configuration"
    fi
    
    # Clean up empty parent directories
    if [ "$remove_local" = "true" ] && [ "$HAS_LOCAL_MODE" = "true" ]; then
        parent_dir=$(dirname "$LOCAL_TARGET_DIR/$LOCAL_DIR")
        if [ "$parent_dir" != "." ] && [ "$parent_dir" != "/" ]; then
            cleanup_empty_parents "$parent_dir"
        fi
    fi
    
    if [ "$remove_commit" = "true" ] && [ "$HAS_COMMIT_MODE" = "true" ]; then
        parent_dir=$(dirname "$COMMIT_TARGET_DIR/$SHARED_DIR")
        if [ "$parent_dir" != "." ] && [ "$parent_dir" != "/" ]; then
            cleanup_empty_parents "$parent_dir"
        fi
    fi
    
    return 0
}

# List available rules and rulesets (multi-mode aware)
cmd_list() {
    # Check if any mode is initialized
    if [ "$HAS_COMMIT_MODE" = "false" ] && [ "$HAS_LOCAL_MODE" = "false" ]; then
        error "No ai-rizz configuration found. Run 'ai-rizz init' first."
    fi
    
    # Validate manifest integrity (hard error for mismatched source repos)
    validate_manifest_integrity
    
    # Get source repo from any available mode
    source_repo=""
    if [ "$HAS_COMMIT_MODE" = "true" ]; then
        source_repo="$COMMIT_SOURCE_REPO"
    elif [ "$HAS_LOCAL_MODE" = "true" ]; then
        source_repo="$LOCAL_SOURCE_REPO"
    fi
    
    # Update source repository
    git_sync "$source_repo"
    
    # Helper function to check if an item is installed in any mode
    is_installed() {
        _is_installed_item="$1"
        _is_installed_status="uninstalled"
        
        # Helper to check if item is covered by rulesets in a manifest
        check_rulesets_for_item() {
            _check_manifest_file="$1"
            _check_item_basename=$(basename "$_is_installed_item")
            _check_entries=""
            
            _check_entries=$(read_manifest_entries "$_check_manifest_file" 2>/dev/null) || return 1
            
            # Use a for loop instead of while to avoid subshell issues
            for _check_entry in $_check_entries; do
                if [ -n "$_check_entry" ] && echo "$_check_entry" | grep -q "^rulesets/"; then
                    # Check if this ruleset contains the item
                    _check_ruleset_dir="$REPO_DIR/$_check_entry"
                    if [ -d "$_check_ruleset_dir" ] && [ -f "$_check_ruleset_dir/$_check_item_basename" ]; then
                        return 0  # Found in ruleset
                    fi
                fi
            done
            return 1  # Not found in any ruleset
        }
        
        # Check local mode first (weaker glyph)
        if [ "$HAS_LOCAL_MODE" = "true" ]; then
            # Check if item is directly in manifest
            if read_manifest_entries "$LOCAL_MANIFEST_FILE" 2>/dev/null | grep -q "^$_is_installed_item$"; then
                _is_installed_status="local"
            elif check_rulesets_for_item "$LOCAL_MANIFEST_FILE"; then
                _is_installed_status="local"
            fi
        fi
        
        # Check commit mode (stronger glyph - overrides local)
        if [ "$HAS_COMMIT_MODE" = "true" ]; then
            # Check if item is directly in manifest
            if read_manifest_entries "$COMMIT_MANIFEST_FILE" 2>/dev/null | grep -q "^$_is_installed_item$"; then
                _is_installed_status="committed"
            elif check_rulesets_for_item "$COMMIT_MANIFEST_FILE"; then
                _is_installed_status="committed"
            fi
        fi
        
        echo "$_is_installed_status"
    }
    
    # Display rules
    echo "Available rules:"
    rules=$(find "$REPO_DIR/rules" -name "*.mdc" | sort 2>/dev/null)
    if [ -z "$rules" ]; then
        echo "  No rules found"
    else
        for rule in $rules; do
            rule_name=$(basename "$rule")
            rule_path="rules/$rule_name"
            status=$(is_installed "$rule_path")
            
            case "$status" in
                committed)
                    printf "  %s %s\n" "$COMMITTED_GLYPH" "$rule_name"
                    ;;
                local)
                    printf "  %s %s\n" "$LOCAL_GLYPH" "$rule_name"
                    ;;
                *)
                    printf "  %s %s\n" "$UNINSTALLED_GLYPH" "$rule_name"
                    ;;
            esac
        done
    fi
    echo ""
    
    # Display rulesets
    echo "Available rulesets:"
    rulesets=$(find "$REPO_DIR/rulesets" -mindepth 1 -maxdepth 1 -type d | sort 2>/dev/null)
    if [ -z "$rulesets" ]; then
        echo "  No rulesets found"
    else
        for ruleset in $rulesets; do
            ruleset_name=$(basename "$ruleset")
            ruleset_path="rulesets/$ruleset_name"
            status=$(is_installed "$ruleset_path")
            
            # Display ruleset with installation status
            case "$status" in
                committed)
                    printf "  %s %s\n" "$COMMITTED_GLYPH" "$ruleset_name"
                    ;;
                local)
                    printf "  %s %s\n" "$LOCAL_GLYPH" "$ruleset_name"
                    ;;
                *)
                    printf "  %s %s\n" "$UNINSTALLED_GLYPH" "$ruleset_name"
                    ;;
            esac
            
            # Use tree to display ruleset contents
            if [ -d "$ruleset" ]; then
                # Check if tree command exists
                if command -v tree >/dev/null 2>&1; then
                    (cd "$ruleset" && tree -L 1 --noreport) | tail -n +2 | sed 's/^/    /' | sed 's/ -> .*$//'
                else
                    # Fallback if tree is not available
                    find "$ruleset" -maxdepth 1 -name "*.mdc" -exec basename {} \; | sort | sed 's/^/    ├── /'
                fi
            fi
        done
    fi
    
    return 0
}

# Add rule(s) to the repository (progressive mode-aware)
cmd_add_rule() {
    mode=""
    rules=""
    
    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --local|-l)
                mode="local"
                shift
                ;;
            --commit|-c)
                mode="commit"
                shift
                ;;
            *)
                if [ -z "$rules" ]; then
                    rules="$1"
                else
                    rules="$rules $1"
                fi
                shift
                ;;
        esac
    done
    
    # Check if any mode is initialized
    if [ "$HAS_COMMIT_MODE" = "false" ] && [ "$HAS_LOCAL_MODE" = "false" ]; then
        error "No ai-rizz configuration found. Run 'ai-rizz init' first."
    fi
    
    # Validate manifest integrity (hard error for mismatched source repos)
    validate_manifest_integrity
    
    # Smart mode selection
    if [ -z "$mode" ]; then
        if [ "$HAS_LOCAL_MODE" = "true" ] && [ "$HAS_COMMIT_MODE" = "false" ]; then
            mode="local"
        elif [ "$HAS_COMMIT_MODE" = "true" ] && [ "$HAS_LOCAL_MODE" = "false" ]; then
            mode="commit"
        else
            error "Both modes available. Please specify --local or --commit flag."
        fi
    fi
    
    # Check if lazy initialization is needed and track it
    lazy_init_occurred=false
    if needs_lazy_init "$mode"; then
        lazy_init_mode "$mode"
        lazy_init_occurred=true
    fi
    
    # Select manifest and target based on mode
    case "$mode" in
        local)
            manifest_file="$LOCAL_MANIFEST_FILE"
            target_dir="$LOCAL_TARGET_DIR/$LOCAL_DIR"
            source_repo="$LOCAL_SOURCE_REPO"
            ;;
        commit)
            manifest_file="$COMMIT_MANIFEST_FILE"
            target_dir="$COMMIT_TARGET_DIR/$SHARED_DIR"
            source_repo="$COMMIT_SOURCE_REPO"
            ;;
        *)
            error "Invalid mode: $mode"
            ;;
    esac
    
    # Update source repository
    git_sync "$source_repo"
    
    # Process each rule
    for rule in $rules; do
        # Add .mdc extension if not present
        case "$rule" in
            *".mdc") ;;  # Already has extension
            *) rule="${rule}.mdc" ;;  # Add extension
        esac
        
        rule_path="rules/$rule"
        
        # Check if rule exists in source repo
        if [ ! -f "$REPO_DIR/$rule_path" ]; then
            warn "Rule not found: $rule_path"
            continue
        fi
        
        # Check if rule exists in opposite mode (conflict resolution)
        # Skip migration check if we just lazy-initialized the target mode (it's empty)
        if [ "$lazy_init_occurred" = "false" ]; then
            case "$mode" in
                local)
                    if [ "$HAS_COMMIT_MODE" = "true" ]; then
                        if read_manifest_entries "$COMMIT_MANIFEST_FILE" | grep -q "^$rule_path$"; then
                            # Remove from commit mode, add to local mode
                            remove_manifest_entry_from_file "$COMMIT_MANIFEST_FILE" "$rule_path"
                        fi
                    fi
                    ;;
                commit)
                    if [ "$HAS_LOCAL_MODE" = "true" ]; then
                        if read_manifest_entries "$LOCAL_MANIFEST_FILE" | grep -q "^$rule_path$"; then
                            # Remove from local mode, add to commit mode
                            remove_manifest_entry_from_file "$LOCAL_MANIFEST_FILE" "$rule_path"
                        fi
                    fi
                    ;;
            esac
        else
            # Lazy initialization occurred - need to migrate from opposite mode
            case "$mode" in
                local)
                    # We just created local mode, migrate from commit mode if rule exists there
                    if [ "$HAS_COMMIT_MODE" = "true" ]; then
                        if read_manifest_entries "$COMMIT_MANIFEST_FILE" | grep -q "^$rule_path$"; then
                            remove_manifest_entry_from_file "$COMMIT_MANIFEST_FILE" "$rule_path"
                        fi
                    fi
                    ;;
                commit)
                    # We just created commit mode, migrate from local mode if rule exists there
                    if [ "$HAS_LOCAL_MODE" = "true" ]; then
                        if read_manifest_entries "$LOCAL_MANIFEST_FILE" | grep -q "^$rule_path$"; then
                            remove_manifest_entry_from_file "$LOCAL_MANIFEST_FILE" "$rule_path"
                        fi
                    fi
                    ;;
            esac
        fi
        
        # Add to target manifest
        add_manifest_entry_to_file "$manifest_file" "$rule_path"
        
        echo "Added rule: $rule_path"
    done
    
    # Sync to update file locations
    sync_all_modes
    
    return 0
}

# Add ruleset(s) to the repository (progressive mode-aware)
cmd_add_ruleset() {
    mode=""
    rulesets=""
    
    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --local|-l)
                mode="local"
                shift
                ;;
            --commit|-c)
                mode="commit"
                shift
                ;;
            *)
                if [ -z "$rulesets" ]; then
                    rulesets="$1"
                else
                    rulesets="$rulesets $1"
                fi
                shift
                ;;
        esac
    done
    
    # Check if any mode is initialized
    if [ "$HAS_COMMIT_MODE" = "false" ] && [ "$HAS_LOCAL_MODE" = "false" ]; then
        error "No ai-rizz configuration found. Run 'ai-rizz init' first."
    fi
    
    # Validate manifest integrity (hard error for mismatched source repos)
    validate_manifest_integrity
    
    # Smart mode selection
    if [ -z "$mode" ]; then
        if [ "$HAS_LOCAL_MODE" = "true" ] && [ "$HAS_COMMIT_MODE" = "false" ]; then
            mode="local"
        elif [ "$HAS_COMMIT_MODE" = "true" ] && [ "$HAS_LOCAL_MODE" = "false" ]; then
            mode="commit"
        else
            error "Both modes available. Please specify --local or --commit flag."
        fi
    fi
    
    # Check if lazy initialization is needed and track it
    lazy_init_occurred=false
    if needs_lazy_init "$mode"; then
        lazy_init_mode "$mode"
        lazy_init_occurred=true
    fi
    
    # Select manifest and target based on mode
    case "$mode" in
        local)
            manifest_file="$LOCAL_MANIFEST_FILE"
            source_repo="$LOCAL_SOURCE_REPO"
            ;;
        commit)
            manifest_file="$COMMIT_MANIFEST_FILE"
            source_repo="$COMMIT_SOURCE_REPO"
            ;;
        *)
            error "Invalid mode: $mode"
            ;;
    esac
    
    # Update source repository
    git_sync "$source_repo"
    
    # Process each ruleset
    for ruleset in $rulesets; do
        ruleset_path="rulesets/$ruleset"
        
        # Check if ruleset exists in source repo
        if [ ! -d "$REPO_DIR/$ruleset_path" ]; then
            warn "Ruleset not found: $ruleset_path"
            continue
        fi
        
        # Check if ruleset exists in opposite mode (conflict resolution)
        # Skip migration check if we just lazy-initialized the target mode (it's empty)
        if [ "$lazy_init_occurred" = "false" ]; then
            case "$mode" in
                local)
                    if [ "$HAS_COMMIT_MODE" = "true" ]; then
                        if read_manifest_entries "$COMMIT_MANIFEST_FILE" | grep -q "^$ruleset_path$"; then
                            # Remove from commit mode, add to local mode
                            remove_manifest_entry_from_file "$COMMIT_MANIFEST_FILE" "$ruleset_path"
                        fi
                    fi
                    ;;
                commit)
                    if [ "$HAS_LOCAL_MODE" = "true" ]; then
                        if read_manifest_entries "$LOCAL_MANIFEST_FILE" | grep -q "^$ruleset_path$"; then
                            # Remove from local mode, add to commit mode
                            remove_manifest_entry_from_file "$LOCAL_MANIFEST_FILE" "$ruleset_path"
                        fi
                    fi
                    ;;
            esac
        else
            # Lazy initialization occurred - need to migrate from opposite mode
            case "$mode" in
                local)
                    # We just created local mode, migrate from commit mode if ruleset exists there
                    if [ "$HAS_COMMIT_MODE" = "true" ]; then
                        if read_manifest_entries "$COMMIT_MANIFEST_FILE" | grep -q "^$ruleset_path$"; then
                            remove_manifest_entry_from_file "$COMMIT_MANIFEST_FILE" "$ruleset_path"
                        fi
                    fi
                    ;;
                commit)
                    # We just created commit mode, migrate from local mode if ruleset exists there
                    if [ "$HAS_LOCAL_MODE" = "true" ]; then
                        if read_manifest_entries "$LOCAL_MANIFEST_FILE" | grep -q "^$ruleset_path$"; then
                            remove_manifest_entry_from_file "$LOCAL_MANIFEST_FILE" "$ruleset_path"
                        fi
                    fi
                    ;;
            esac
        fi
        
        # Add to target manifest
        add_manifest_entry_to_file "$manifest_file" "$ruleset_path"
        
        echo "Added ruleset: $ruleset_path"
    done
    
    # Sync to update file locations
    sync_all_modes
    
    return 0
}

# Remove rule(s) from the repository (mode-aware)
cmd_remove_rule() {
    # Check if any mode is initialized
    if [ "$HAS_COMMIT_MODE" = "false" ] && [ "$HAS_LOCAL_MODE" = "false" ]; then
        error "No ai-rizz configuration found. Run 'ai-rizz init' first."
    fi
    
    # Validate manifest integrity (hard error for mismatched source repos)
    validate_manifest_integrity
    
    # Process each rule
    for rule in "$@"; do
        # Add .mdc extension if not present
        case "$rule" in
            *".mdc") ;;  # Already has extension
            *) rule="${rule}.mdc" ;;  # Add extension
        esac
        
        rule_path="rules/$rule"
        removed=false
        
        # Remove from whichever mode contains it
        if [ "$HAS_LOCAL_MODE" = "true" ]; then
            if read_manifest_entries "$LOCAL_MANIFEST_FILE" | grep -q "^$rule_path$"; then
                remove_manifest_entry_from_file "$LOCAL_MANIFEST_FILE" "$rule_path"
                removed=true
            fi
        fi
        
        if [ "$HAS_COMMIT_MODE" = "true" ]; then
            if read_manifest_entries "$COMMIT_MANIFEST_FILE" | grep -q "^$rule_path$"; then
                remove_manifest_entry_from_file "$COMMIT_MANIFEST_FILE" "$rule_path"
                removed=true
            fi
        fi
        
        if [ "$removed" = "true" ]; then
            echo "Removed rule: $rule_path"
        else
            warn "Rule not found in any mode: $rule_path"
        fi
    done
    
    # Sync to ensure proper cleanup
    sync_all_modes
    
    return 0
}

# Remove ruleset(s) from the repository (mode-aware)
cmd_remove_ruleset() {
    # Check if any mode is initialized
    if [ "$HAS_COMMIT_MODE" = "false" ] && [ "$HAS_LOCAL_MODE" = "false" ]; then
        error "No ai-rizz configuration found. Run 'ai-rizz init' first."
    fi
    
    # Validate manifest integrity (hard error for mismatched source repos)
    validate_manifest_integrity
    
    # Process each ruleset
    for ruleset in "$@"; do
        ruleset_path="rulesets/$ruleset"
        removed=false
        
        # Remove from whichever mode contains it
        if [ "$HAS_LOCAL_MODE" = "true" ]; then
            if read_manifest_entries "$LOCAL_MANIFEST_FILE" | grep -q "^$ruleset_path$"; then
                remove_manifest_entry_from_file "$LOCAL_MANIFEST_FILE" "$ruleset_path"
                removed=true
            fi
        fi
        
        if [ "$HAS_COMMIT_MODE" = "true" ]; then
            if read_manifest_entries "$COMMIT_MANIFEST_FILE" | grep -q "^$ruleset_path$"; then
                remove_manifest_entry_from_file "$COMMIT_MANIFEST_FILE" "$ruleset_path"
                removed=true
            fi
        fi
        
        if [ "$removed" = "true" ]; then
            echo "Removed ruleset: $ruleset_path"
        else
            warn "Ruleset not found in any mode: $ruleset_path"
        fi
    done
    
    # Sync to ensure proper cleanup
    sync_all_modes
    
    return 0
}

# Sync all available manifests to their target directories
sync_all_modes() {
    sync_success=true
    
    # Resolve conflicts first (commit mode wins)
    resolve_conflicts
    
    # Sync commit mode if initialized
    if [ "$HAS_COMMIT_MODE" = "true" ]; then
        sync_manifest_to_directory "$COMMIT_MANIFEST_FILE" "$COMMIT_TARGET_DIR/$SHARED_DIR" || sync_success=false
    fi
    
    # Sync local mode if initialized  
    if [ "$HAS_LOCAL_MODE" = "true" ]; then
        sync_manifest_to_directory "$LOCAL_MANIFEST_FILE" "$LOCAL_TARGET_DIR/$LOCAL_DIR" || sync_success=false
    fi
    
    # Handle any cleanup needed
    if [ "$sync_success" = "false" ]; then
        handle_sync_cleanup
    fi
}

# Sync a single manifest to its target directory
sync_manifest_to_directory() {
    manifest_file="$1"
    target_directory="$2"
    
    if [ ! -f "$manifest_file" ]; then
        return 0  # No manifest to sync
    fi
    
    # Create target directory if needed
    mkdir -p "$target_directory"
    
    # Safety check: Only operate in our managed directories (local or shared)
    case "$target_directory" in
        */"$LOCAL_DIR"|*/"$SHARED_DIR")
            # Clear existing .mdc files to ensure removed rules are deleted
            # Only delete regular .mdc files, never directories or other files
            find "$target_directory" -maxdepth 1 -name "*.mdc" -type f -delete 2>/dev/null || true
            ;;
        *)
            warn "Refusing to clear unrecognized target directory: $target_directory"
            return 1
            ;;
    esac
    
    # Get entries from manifest
    entries=$(read_manifest_entries "$manifest_file") || {
        warn "Failed to read entries from $manifest_file"
        return 1
    }
    
    # Copy each entry
    if [ -n "$entries" ]; then
        echo "$entries" | while IFS= read -r entry; do
            if [ -n "$entry" ]; then
                copy_entry_to_target "$entry" "$target_directory" || return 1
            fi
        done
    fi
}

# Copy a single entry (rule or ruleset) to target directory
copy_entry_to_target() {
    entry="$1"
    target_directory="$2"
    
    source_path="$REPO_DIR/$entry"
    
    if [ -f "$source_path" ]; then
        # Single file (rule)
        cp "$source_path" "$target_directory/"
    elif [ -d "$source_path" ]; then
        # Directory (ruleset) - copy individual .mdc files from ruleset to target directory
        # Handle symlinks correctly by following them and copying actual content
        find "$source_path" -name "*.mdc" -type f -o -name "*.mdc" -type l | while IFS= read -r rule_file; do
            if [ -f "$rule_file" ] || [ -L "$rule_file" ]; then
                # Copy the file (following symlinks to get actual content)
                cp -L "$rule_file" "$target_directory/"
            fi
        done
    else
        warn "Entry not found in repository: $entry"
        return 1
    fi
}

# Handle cleanup after sync issues
handle_sync_cleanup() {
    # Re-cache manifest metadata to ensure consistency
    cache_manifest_metadata
    
    # Validate git exclude state
    target_dir=$(get_target_directory)
    validate_git_exclude_state "$target_dir"
}

# Sync the repository (multi-mode aware)
cmd_sync() {
    # Check if any mode is initialized
    if [ "$HAS_COMMIT_MODE" = "false" ] && [ "$HAS_LOCAL_MODE" = "false" ]; then
        error "No ai-rizz configuration found. Run 'ai-rizz init' first."
    fi
    
    # Validate manifest integrity (hard error for mismatched source repos)
    validate_manifest_integrity
    
    # Get source repo from any available manifest
    source_repo=""
    if [ -n "$COMMIT_SOURCE_REPO" ]; then
        source_repo="$COMMIT_SOURCE_REPO"
    elif [ -n "$LOCAL_SOURCE_REPO" ]; then
        source_repo="$LOCAL_SOURCE_REPO"
    fi
    
    # Sync repository first
    if [ -n "$source_repo" ]; then
        git_sync "$source_repo"
    fi
    
    # Sync all initialized modes
    sync_all_modes
    
    echo "Sync complete"
    return 0
}



# Help command
cmd_help() {
  cat <<EOF
Usage: ai-rizz <command> [command-specific options]

Available commands:
  init [<source_repo>]     Initialize the repository
  deinit                   Deinitialize the repository
  list                     List available rules and rulesets
  add rule <rule>...       Add rule(s) to the repository (.mdc extension optional)
  add ruleset <ruleset>... Add ruleset(s) to the repository
  remove rule <rule>...    Remove rule(s) from the repository (.mdc extension optional)
  remove ruleset <ruleset>... Remove ruleset(s) from the repository
  sync                     Sync the repository
  help                     Show this help

Command-specific options:
  init options:
    -d <target_dir>        Target directory (default: .cursor/rules)
    --local, -l            Use local mode (ignore files)
    --commit, -c           Use commit mode (commit files)

  deinit options:
    -y                     Skip confirmation prompts
EOF
  return 0
}

# Initialization
# ==============

# Initialize ai-rizz state at startup (two-phase to avoid circular dependencies)
initialize_ai_rizz() {
    # Phase 1: Minimal detection and migration (file-based only)
    detect_manifest_files_only
    migrate_legacy_repository_if_needed
    
    # Phase 2: Full initialization with directory checking  
    detect_initialized_modes
    cache_manifest_metadata
    
    # Phase 3: Set repository directory for current project
    REPO_DIR=$(get_repo_dir)
}

# Main
# ====

# Only run main code if script is executed, not sourced
if [ "${0##*/}" = "ai-rizz" ]; then
    # Check if no arguments provided
    if [ $# -eq 0 ]; then
        cmd_help
        exit 0
    fi
    
    # Initialize ai-rizz state for production use
    initialize_ai_rizz
    
    # Parse command
    command=$1
    shift

    case "$command" in
    init)
      cmd_init "$@"
      ;;
    deinit)
      cmd_deinit "$@"
      ;;
    list)
      cmd_list "$@"
      ;;
    add)
      if [ $# -eq 0 ]; then
        error "Missing type: 'rule' or 'ruleset'"
      fi
      
      type=$1
      shift
      
      case "$type" in
        rule)
          if [ $# -eq 0 ]; then
            error "Missing rule name"
          fi
          cmd_add_rule "$@"
          ;;
        ruleset)
          if [ $# -eq 0 ]; then
            error "Missing ruleset name"
          fi
          cmd_add_ruleset "$@"
          ;;
        *)
          error "Invalid type: $type. Must be 'rule' or 'ruleset'"
          ;;
      esac
      ;;
    remove)
      if [ $# -eq 0 ]; then
        error "Missing type: 'rule' or 'ruleset'"
      fi
      
      type=$1
      shift
      
      case "$type" in
        rule)
          if [ $# -eq 0 ]; then
            error "Missing rule name"
          fi
          cmd_remove_rule "$@"
          ;;
        ruleset)
          if [ $# -eq 0 ]; then
            error "Missing ruleset name"
          fi
          cmd_remove_ruleset "$@"
          ;;
        *)
          error "Invalid type: $type. Must be 'rule' or 'ruleset'"
          ;;
      esac
      ;;
    sync)
      cmd_sync "$@"
      ;;
    help)
      cmd_help "$@"
      ;;
    *)
      error "Unknown command: $command. Run 'ai-rizz help' for usage"
      ;;
  esac
fi
