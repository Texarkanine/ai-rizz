# Creative Phase: Ruleset Rule Structure Design

## Problem Statement

The current implementation has a partially-implemented feature for preserving directory structure of rules within rulesets. However, there's a fundamental design question about how to handle two types of rules:

1. **Symlinked rules**: Rules from the `rules/` directory, symlinked into rulesets. These should be copied flat because all instances are the same rule.
2. **File rules**: Actual files in rulesets. Their URI is `ruleset/path/to/rule.mdc`, so `rule.mdc` in different rulesets are fundamentally different entities.

**Current State**: The code flattens both types, but the user notes that:
- Symlinked rules SHOULD be flat (correct behavior)
- File rules SHOULD preserve directory structure (currently broken)

**User's Requirements** (UPDATED):
- **NEEDS** a way to ship a rule tree like `.cursor/rules/isolation_rules`:
  - Multiple levels deep (Core/, Level1/, Level2/, Level3/, Level4/, Phases/, visual-maps/)
  - Many, many rules (55+ rules in the example)
  - Rules don't work in isolation; they must be part of a ruleset bundle
  - Can't put them all in top-level `rules/` because `ai-rizz list` will become useless
  - So local to a single ruleset makes good sense
- Also considering: Putting them in a subdir of `rules/` and symlinking from a ruleset
  - Would work provided that directories in upstream rule repos `rules/` just remain invisible

## Requirements Analysis

### Core Requirements
1. **Symlinked rules**: Must be copied flat (all instances are the same rule from `rules/`)
2. **File rules**: Should preserve directory structure (URI is `ruleset/path/to/rule.mdc`)
3. **Conflict detection**: Currently uses basename only - needs to work with both flat and structured rules
4. **User experience**: Users should be able to explicitly select rules in subdirs in `rules/` if using directory structure there

### Constraints
- Current conflict detection uses basename only (`file_exists_in_commit_mode()`)
- Rules are identified by filename in manifests
- The "filename IS a unique URI" property is important for rules in `rules/` directory

## Design Options

### Option 1: Finish Support for File Rules in Rulesets (Preserve Structure) ⭐ RECOMMENDED

**Approach**: Complete the implementation to preserve directory structure for file rules while keeping symlinked rules flat.

**Implementation**:
- Detect if a rule is a symlink or a file
- If symlink: Copy flat to target root (current behavior, correct)
- If file: Preserve directory structure (e.g., `Core/memory-bank-paths.mdc` → `.cursor/rules/shared/Core/memory-bank-paths.mdc`)

**Pros**:
- ✅ **Solves user's actual need**: Can ship large rule trees in rulesets (like isolation_rules with 55+ rules)
- ✅ Completes partially-implemented feature
- ✅ Mathematically correct: file rules have URI `ruleset/path/to/rule.mdc`
- ✅ Allows rulesets to organize rules in subdirectories
- ✅ No breaking changes to existing behavior (symlinks still work)
- ✅ Rules stay bundled with ruleset (don't clutter `ai-rizz list`)

**Cons**:
- More complex implementation (need to detect symlink vs file)
- Conflict detection becomes more complex (need to check both flat and structured paths)
- May confuse users (some rules flat, some structured) - but this is acceptable given the use case

**Complexity**: Medium - need to:
- Detect symlink vs file in `copy_entry_to_target()`
- Update conflict detection to handle both flat and structured rules
- Update removal logic to handle structured rules
- Update list display to show structured rules correctly

### Option 2: Block File Rules in Subdirectories (Enforce Flat Structure)

**Approach**: Reject rulesets that contain file rules in subdirectories, enforce that all rules in rulesets must be symlinks or files at root level.

**Implementation**:
- Add validation in `cmd_add_ruleset()` to check for file rules in subdirectories
- Show error message explaining that only symlinked rules or root-level file rules are allowed
- Keep current flat copying behavior

**Pros**:
- Simple: no changes to copying logic
- Clear user guidance: error message explains the constraint
- Maintains "filename IS a unique URI" property
- No confusion about flat vs structured rules

**Cons**:
- Blocks a use case (even if user doesn't need it)
- Leaves partially-implemented code in place
- Less flexible for future use cases

**Complexity**: Low - need to:
- Add validation function to check for file rules in subdirectories
- Show error message in `cmd_add_ruleset()`
- Document the constraint

### Option 3: Use Directory Structure in `rules/` with Symlinks (Requires List Changes)

**Approach**: Allow directory structure in the upstream `rules/` directory, and have rulesets symlink into subdirs of `rules/`. Make subdirectories in `rules/` invisible to `ai-rizz list`.

**Example Structure**:
```
rules/
  ├── core/
  │   ├── rule1.mdc
  │   └── rule2.mdc
  └── supporting/
      └── rule3.mdc

rulesets/
  └── isolation-rules/
      ├── Core/
      │   ├── rule1.mdc -> ../../rules/core/rule1.mdc
      │   └── rule2.mdc -> ../../rules/core/rule2.mdc
      └── supporting/
          └── rule3.mdc -> ../../../rules/supporting/rule3.mdc
```

**Implementation**:
- Allow directory structure in `rules/`
- **Change `ai-rizz list`**: Only show rules at root level of `rules/` (hide subdirectories)
- Rulesets symlink into subdirs of `rules/`
- All rules are symlinks, so all copied flat (correct behavior)
- Users can select rules from subdirs in `rules/` using path: `ai-rizz add rule core/rule1.mdc` (but they won't see them in list)

**Pros**:
- All rules are symlinks, so all copied flat (consistent behavior)
- Users can organize rules in `rules/` with directory structure
- Subdirectories in `rules/` don't clutter `ai-rizz list` (only root-level rules shown)
- No conflict detection complexity (all flat)
- Rules in subdirs of `rules/` are "hidden" from list (as user requested)

**Cons**:
- **Requires changing `ai-rizz list` behavior**: Currently shows all .mdc files recursively
- Doesn't enforce "filename IS a unique URI" property at the source level (two rules with same filename in different subdirs of `rules/` would conflict when copied)
- Requires users to restructure their `rules/` directory
- More complex symlink management in rulesets
- May be confusing: ruleset has directory structure but rules are still flat when copied
- Users can't see rules in subdirs of `rules/` in list (they're hidden)

**Complexity**: Medium - need to:
- Update `cmd_add_rule()` to handle paths like `core/rule1.mdc`
- Update validation to allow directory structure in `rules/`
- Update documentation
- No changes to copying logic (all symlinks, all flat)

## Analysis

### Current Implementation State

Looking at `copy_entry_to_target()` (line 3341):
- Currently finds all `.mdc` files (both `-type f` and `-type l`)
- Copies all to target root (flattens everything)
- Uses `cp -L` which follows symlinks

The code doesn't currently distinguish between symlinks and files when copying rules from rulesets.

### Conflict Detection

Current conflict detection (`file_exists_in_commit_mode()`) uses basename only:
- Checks if a filename exists in commit mode
- Doesn't consider path structure
- Would need updates if we preserve structure for file rules

### User's Actual Needs

The user states:
- Doesn't actually need file rules in subdirectories
- But doesn't want to leave it broken
- Wants to investigate options

This suggests **Option 2 (Block)** might be the best fit, but we should assess the alternatives.

## Recommendation

### Primary Recommendation: **Option 1 - Finish Support for File Rules in Rulesets** ⭐

**Rationale**:
1. **User DOES need it**: User needs to ship large rule trees (55+ rules) in rulesets
2. **Solves the actual problem**: Rules stay bundled with ruleset, don't clutter `ai-rizz list`
3. **Mathematically correct**: File rules have URI `ruleset/path/to/rule.mdc`, so structure should be preserved
4. **No breaking changes**: Symlinks still work correctly (copied flat)
5. **Completes partially-implemented feature**: Code is already partially there

**Implementation**:
- Detect symlink vs file in `copy_entry_to_target()`
- If symlink: Copy flat (current behavior, correct)
- If file: Preserve directory structure (calculate relative path, create target dirs)
- Update conflict detection to handle both flat and structured paths
- Update removal logic to handle structured rules

**Complexity**: Medium - need to:
- Detect symlink vs file
- Preserve structure for files only
- Update conflict detection
- Update removal logic
- Update list display (already shows structure in tree)

### Alternative Consideration: **Option 3 - Directory Structure in `rules/` with Hidden Subdirs**

If the user prefers symlinks, Option 3 could work but requires:
- **Changing `ai-rizz list`**: Only show root-level rules from `rules/` directory
- Restructuring `rules/` directory to have subdirectories
- Rulesets symlink to rules in subdirs
- All rules copied flat (consistent)

**Trade-offs**:
- ✅ All rules are symlinks (consistent behavior)
- ✅ Subdirectories in `rules/` hidden from list
- ❌ Requires changing `ai-rizz list` behavior
- ❌ Requires restructuring `rules/` directory
- ❌ More complex symlink management
- ❌ Rules in subdirs of `rules/` invisible to users (can't see them in list)

**Assessment**: Option 1 is better because:
- Rules stay bundled with ruleset (better organization)
- No need to change `ai-rizz list` behavior
- No need to restructure `rules/` directory
- Rules visible in ruleset tree display

## Decision

**Recommended**: **Option 1 - Finish Support for File Rules in Rulesets (Preserve Structure)** ⭐

**Rationale**: User needs to ship large rule trees (55+ rules) in rulesets. Option 1 solves this directly without requiring changes to `ai-rizz list` or restructuring `rules/` directory.

**Implementation Plan**:
1. Update `copy_entry_to_target()` to detect symlink vs file
2. If symlink: Copy flat (current behavior, correct)
3. If file: Preserve directory structure (calculate relative path, create target dirs)
4. Update conflict detection to handle both flat and structured paths
5. Update removal logic to handle structured rules
6. Update `sync_manifest_to_directory()` to clear nested `.mdc` files recursively

**Alternative**: Option 3 (directory structure in `rules/` with hidden subdirs) is viable but requires changing `ai-rizz list` behavior and restructuring `rules/` directory. Option 1 is cleaner for the use case.

## Implementation Guidelines

### Copy Logic with Symlink Detection
```bash
# In copy_entry_to_target(), when copying ruleset:
# Use temporary file to avoid subshell exit code issues (per POSIX style guide)
cett_temp_file=$(mktemp)
find "${cett_source_path}" -name "*.mdc" \( -type f -o -type l \) > "${cett_temp_file}" 2>/dev/null
cett_find_status=$?

if [ ${cett_find_status} -eq 0 ]; then
    while IFS= read -r cett_rule_file; do
        if [ -n "${cett_rule_file}" ] && ([ -f "${cett_rule_file}" ] || [ -L "${cett_rule_file}" ]); then
            # Detect if this is a symlink or a file
            if [ -L "${cett_rule_file}" ]; then
                # Symlink: Copy flat to target root (all instances are the same rule)
                cett_filename=$(basename "${cett_rule_file}")
                
                # Skip if file would conflict with commit mode (commit wins)
                if [ "${cett_is_local_sync}" = "true" ] && file_exists_in_commit_mode "${cett_filename}"; then
                    continue
                fi
                
                # Copy flat (following symlink to get actual content)
                cp -L "${cett_rule_file}" "${cett_target_directory}/"
            else
                # File: Preserve directory structure (URI is ruleset/path/to/rule.mdc)
                cett_rel_path="${cett_rule_file#${cett_source_path}/}"
                cett_target_file="${cett_target_directory}/${cett_rel_path}"
                
                # Create target directory structure if needed
                cett_target_dir=$(dirname "${cett_target_file}")
                if [ ! -d "${cett_target_dir}" ]; then
                    if ! mkdir -p "${cett_target_dir}"; then
                        warn "Failed to create directory for: ${cett_rel_path}"
                        continue
                    fi
                fi
                
                # Skip if file would conflict with commit mode (commit wins)
                # For structured files, check by basename (conflict detection uses basename)
                cett_filename=$(basename "${cett_rule_file}")
                if [ "${cett_is_local_sync}" = "true" ] && file_exists_in_commit_mode "${cett_filename}"; then
                    continue
                fi
                
                # Copy the file (preserving structure)
                if ! cp "${cett_rule_file}" "${cett_target_file}"; then
                    warn "Failed to copy rule file: ${cett_rel_path}"
                fi
            fi
        fi
    done < "${cett_temp_file}"
fi

rm -f "${cett_temp_file}"
```

### Update sync_manifest_to_directory()
```bash
# Current (line 3151): Only clears top-level .mdc files
find "${smtd_target_directory}" -maxdepth 1 -name "*.mdc" -type f -delete

# New: Clear all .mdc files recursively (to handle structured rules)
find "${smtd_target_directory}" -name "*.mdc" -type f -delete
```

## Verification

After implementation:
- ✅ Rulesets with symlinked rules in subdirectories: Should work (copied flat)
- ✅ Rulesets with file rules at root: Should work (copied flat)
- ✅ Rulesets with file rules in subdirectories: Should preserve structure
- ✅ Large rule trees (55+ rules): Should work correctly with preserved structure
- ✅ Existing behavior preserved: Symlinks still copied flat
